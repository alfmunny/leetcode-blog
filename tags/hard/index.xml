<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hard on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/hard/</link>
    <description>Recent content in hard on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Nov 2020 23:23:00 +0100</lastBuildDate><atom:link href="//alfmunny.com/leetcode-blog/tags/hard/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>30 - Substring with Concatenation of All Words</title>
      <link>//alfmunny.com/leetcode-blog/posts/30-substring-with-concatenation-of-all-words/</link>
      <pubDate>Mon, 30 Nov 2020 23:23:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/30-substring-with-concatenation-of-all-words/</guid>
      <description>leetcode
Problem You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters. You can return the answer in any order. Example 1: Input: s = &amp;#34;barfoothefoobarman&amp;#34;, words = [&amp;#34;foo&amp;#34;,&amp;#34;bar&amp;#34;] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are &amp;#34;barfoo&amp;#34; and &amp;#34;foobar&amp;#34; respectively.</description>
    </item>
    
    <item>
      <title>140 - Word Breaker II</title>
      <link>//alfmunny.com/leetcode-blog/posts/140-word-breaker-ii/</link>
      <pubDate>Mon, 30 Nov 2020 01:13:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/140-word-breaker-ii/</guid>
      <description>leetcode
Problem Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = &amp;#34;catsanddog&amp;#34; wordDict = [&amp;#34;cat&amp;#34;, &amp;#34;cats&amp;#34;, &amp;#34;and&amp;#34;, &amp;#34;sand&amp;#34;, &amp;#34;dog&amp;#34;] Output: [ &amp;#34;cats and dog&amp;#34;, &amp;#34;cat sand dog&amp;#34; ] Example 2: Input: s = &amp;#34;pineapplepenapple&amp;#34; wordDict = [&amp;#34;apple&amp;#34;, &amp;#34;pen&amp;#34;, &amp;#34;applepen&amp;#34;, &amp;#34;pine&amp;#34;, &amp;#34;pineapple&amp;#34;] Output: [ &amp;#34;pine apple pen apple&amp;#34;, &amp;#34;pineapple pen apple&amp;#34;, &amp;#34;pine applepen apple&amp;#34; ] Explanation: Note that you are allowed to reuse a dictionary word.</description>
    </item>
    
    <item>
      <title>381 - Insert Delete GetRandom O(1) - Duplicates allowed</title>
      <link>//alfmunny.com/leetcode-blog/posts/381-insert-delete-getrandom-o1-duplicates-allowed/</link>
      <pubDate>Fri, 27 Nov 2020 23:14:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/381-insert-delete-getrandom-o1-duplicates-allowed/</guid>
      <description>leetcode
Problem Design a data structure that supports all following operations in average O(1) time. Note: Duplicate elements are allowed. insert(val): Inserts an item val to the collection. remove(val): Removes an item val from the collection if present. getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains. Example: // Init an empty collection.</description>
    </item>
    
    <item>
      <title>295 - Find Median from Data Stream</title>
      <link>//alfmunny.com/leetcode-blog/posts/295-find-median-from-data-stream/</link>
      <pubDate>Tue, 24 Nov 2020 00:40:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/295-find-median-from-data-stream/</guid>
      <description>leetcode
Problem Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure.</description>
    </item>
    
    <item>
      <title>691 - Stickers to Spell Word</title>
      <link>//alfmunny.com/leetcode-blog/posts/691-stickers-to-spell-word/</link>
      <pubDate>Sun, 22 Nov 2020 18:35:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/691-stickers-to-spell-word/</guid>
      <description>leetcode
Problem We are given N different types of stickers. Each sticker has a lowercase English word on it. You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker. What is the minimum number of stickers that you need to spell out the target?</description>
    </item>
    
    <item>
      <title>126 - Word Ladder II</title>
      <link>//alfmunny.com/leetcode-blog/posts/126-word-ladder-ii/</link>
      <pubDate>Sun, 22 Nov 2020 00:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/126-word-ladder-ii/</guid>
      <description>leetcode
Problem Given two words (beginWord and endWord), and a dictionary&amp;#39;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note: Return an empty list if there is no such transformation sequence. All words have the same length. All words contain only lowercase alphabetic characters.</description>
    </item>
    
    <item>
      <title>115 - Distinct Subsequences</title>
      <link>//alfmunny.com/leetcode-blog/posts/115-distinct-subsequences/</link>
      <pubDate>Sat, 21 Nov 2020 02:56:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/115-distinct-subsequences/</guid>
      <description>leetcode
Problem Given two strings s and t, return the number of distinct subsequences of s which equals t. A string&amp;#39;s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &amp;#34;ACE&amp;#34; is a subsequence of &amp;#34;ABCDE&amp;#34; while &amp;#34;AEC&amp;#34; is not). It&amp;#39;s guaranteed the answer fits on a 32-bit signed integer. Example 1: Input: s = &amp;#34;rabbbit&amp;#34;, t = &amp;#34;rabbit&amp;#34; Output: 3 Explanation: As shown below, there are 3 ways you can generate &amp;#34;rabbit&amp;#34; from S.</description>
    </item>
    
    <item>
      <title>403 - Frog Jump</title>
      <link>//alfmunny.com/leetcode-blog/posts/403-frog-jump/</link>
      <pubDate>Sun, 08 Nov 2020 01:34:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/403-frog-jump/</guid>
      <description>leetcode
Problem A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones&amp;#39; positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.</description>
    </item>
    
    <item>
      <title>354 - Russian Doll Envelopes</title>
      <link>//alfmunny.com/leetcode-blog/posts/354-russian-doll-envelopes/</link>
      <pubDate>Sun, 11 Oct 2020 18:39:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/354-russian-doll-envelopes/</guid>
      <description>leetcode
Problem You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example: Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&amp;gt; [5,4] =&amp;gt; [6,7]).</description>
    </item>
    
    <item>
      <title>980 - Unique Paths III</title>
      <link>//alfmunny.com/leetcode-blog/posts/980-unique-paths-iii/</link>
      <pubDate>Thu, 27 Aug 2020 13:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/980-unique-paths-iii/</guid>
      <description>leetcode
Problem On a 2-dimensional grid, there are 4 types of squares: 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</description>
    </item>
    
    <item>
      <title>132 - Palindrome Partitioning II</title>
      <link>//alfmunny.com/leetcode-blog/posts/132-palindrome-partitioning-ii/</link>
      <pubDate>Wed, 26 Aug 2020 01:00:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/132-palindrome-partitioning-ii/</guid>
      <description>leetcode
Problem Given a string s, partition s such that every substring of the partition is a palindrome Return the minimum cuts needed for a palindrome partitioning of s. Example 1: Input: s = &amp;#34;aab&amp;#34; Output: 1 Explanation: The palindrome partitioning [&amp;#34;aa&amp;#34;,&amp;#34;b&amp;#34;] could be produced using 1 cut. Example 2: Input: s = &amp;#34;a&amp;#34; Output: 0 Example 3: Input: s = &amp;#34;ab&amp;#34; Output: 1 Constraints: 1 &amp;lt;= s.length &amp;lt;= 2000 s consists of lower-case English letters only.</description>
    </item>
    
    <item>
      <title>1032 - Stream of Characters</title>
      <link>//alfmunny.com/leetcode-blog/posts/1032-stream-of-characters/</link>
      <pubDate>Sun, 23 Aug 2020 16:34:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1032-stream-of-characters/</guid>
      <description>leetcode
Problem Implement the StreamChecker class as follows: StreamChecker(words): Constructor, init the data structure with the given words. query(letter): returns true if and only if for some k &amp;gt;= 1, the last k characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list. Example: StreamChecker streamChecker = new StreamChecker([&amp;#34;cd&amp;#34;,&amp;#34;f&amp;#34;,&amp;#34;kl&amp;#34;]); // init the dictionary. streamChecker.query(&amp;#39;a&amp;#39;); // return false streamChecker.query(&amp;#39;b&amp;#39;); // return false streamChecker.</description>
    </item>
    
    <item>
      <title>97 - Interleaving String</title>
      <link>//alfmunny.com/leetcode-blog/posts/97-interleaving-string/</link>
      <pubDate>Tue, 18 Aug 2020 15:15:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/97-interleaving-string/</guid>
      <description>leetcode
Problem Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = &amp;#34;aabcc&amp;#34;, s2 = &amp;#34;dbbca&amp;#34;, s3 = &amp;#34;aadbbcbcac&amp;#34; Output: true Example 2: Input: s1 = &amp;#34;aabcc&amp;#34;, s2 = &amp;#34;dbbca&amp;#34;, s3 = &amp;#34;aadbbbaccc&amp;#34; Output: false Solution DP problem.
Imagin you have a matrix with s1 as its row and s2 as its column.
You have to find a path from upper left corner to bottom right corner, which consisits the s3.</description>
    </item>
    
    <item>
      <title>32 - Longest Valid Parentheses</title>
      <link>//alfmunny.com/leetcode-blog/posts/32-longest-valid-parentheses/</link>
      <pubDate>Thu, 13 Aug 2020 17:14:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/32-longest-valid-parentheses/</guid>
      <description>leetcode
Problem Given a string containing just the characters &amp;#39;(&amp;#39; and &amp;#39;)&amp;#39;, find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: &amp;#34;(()&amp;#34; Output: 2 Explanation: The longest valid parentheses substring is &amp;#34;()&amp;#34; Example 2: Input: &amp;#34;)()())&amp;#34; Output: 4 Explanation: The longest valid parentheses substring is &amp;#34;()()&amp;#34; Solution class Solution: def longestValidParentheses(self, s: str) -&amp;gt; int: stack = [-1] ans = 0 for i in range(len(s)): if s[i] == &amp;#39;(&amp;#39;: stack.</description>
    </item>
    
    <item>
      <title>37 - Sudoku Solver</title>
      <link>//alfmunny.com/leetcode-blog/posts/37-sodoku-solver/</link>
      <pubDate>Fri, 10 Jul 2020 17:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/37-sodoku-solver/</guid>
      <description>leetcode
Problem Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character &amp;#39;.</description>
    </item>
    
    <item>
      <title>10 - Regular Expression Matching</title>
      <link>//alfmunny.com/leetcode-blog/posts/10-regular-expression-matching/</link>
      <pubDate>Fri, 10 Jul 2020 02:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/10-regular-expression-matching/</guid>
      <description>leetcode
Problem Given an input string (s) and a pattern (p), implement regular expression matching with support for &amp;#39;.&amp;#39; and &amp;#39;*&amp;#39;. &amp;#39;.&amp;#39; Matches any single character. &amp;#39;*&amp;#39; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.</description>
    </item>
    
    <item>
      <title>212 - Word Search II</title>
      <link>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</link>
      <pubDate>Wed, 01 Jul 2020 00:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</guid>
      <description>leetcode
Problem Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input: board = [ [&amp;#39;o&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;n&amp;#39;], [&amp;#39;e&amp;#39;,&amp;#39;t&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;e&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;h&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;r&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;v&amp;#39;] ] words = [&amp;#34;oath&amp;#34;,&amp;#34;pea&amp;#34;,&amp;#34;eat&amp;#34;,&amp;#34;rain&amp;#34;] Output: [&amp;#34;eat&amp;#34;,&amp;#34;oath&amp;#34;] Note: All inputs are consist of lowercase letters a-z.</description>
    </item>
    
    <item>
      <title>52 - N-Queens II</title>
      <link>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</link>
      <pubDate>Fri, 12 Jun 2020 17:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Solution class Solution: def totalNQueens(self, n): self.ans = 0 self.dfs(0, n, []) return self.ans def dfs(self, row, n, path): if row == n and len(path) == n: self.ans += 1 for i in range(n): if self.</description>
    </item>
    
    <item>
      <title>51 - N-Queens</title>
      <link>//alfmunny.com/leetcode-blog/posts/51-n-queens/</link>
      <pubDate>Fri, 12 Jun 2020 17:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/51-n-queens/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens&amp;#39; placement, where &amp;#39;Q&amp;#39; and &amp;#39;.&amp;#39; both indicate a queen and an empty space respectively. Solution class Solution: def solveNQueens(self, n): ans = [] self.dfs(0, n, [], ans) return ans def dfs(self, row, n, path, ans): if row == n and len(path) == n: ans.</description>
    </item>
    
    <item>
      <title>72 - Edit Distance</title>
      <link>//alfmunny.com/leetcode-blog/posts/72-edit-distance/</link>
      <pubDate>Sun, 31 May 2020 17:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/72-edit-distance/</guid>
      <description>leetcode
Problem Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = &amp;#34;horse&amp;#34;, word2 = &amp;#34;ros&amp;#34; Output: 3 Explanation: horse -&amp;gt; rorse (replace &amp;#39;h&amp;#39; with &amp;#39;r&amp;#39;) rorse -&amp;gt; rose (remove &amp;#39;r&amp;#39;) rose -&amp;gt; ros (remove &amp;#39;e&amp;#39;) Example 2: Input: word1 = &amp;#34;intention&amp;#34;, word2 = &amp;#34;execution&amp;#34; Output: 5 Explanation: intention -&amp;gt; inention (remove &amp;#39;t&amp;#39;) inention -&amp;gt; enention (replace &amp;#39;i&amp;#39; with &amp;#39;e&amp;#39;) enention -&amp;gt; exention (replace &amp;#39;n&amp;#39; with &amp;#39;x&amp;#39;) exention -&amp;gt; exection (replace &amp;#39;n&amp;#39; with &amp;#39;c&amp;#39;) exection -&amp;gt; execution (insert &amp;#39;u&amp;#39;) Solution class Solution: def minDistance(self, word1: str, word2: str) -&amp;gt; int: dp = [[0] * (1+len(word2)) for _ in range(1+len(word1))] for i in range(1+len(word1)): dp[i][0] = i for j in range(1+len(word2)): dp[0][j] = j for i in range(1, 1+len(word1)): for j in range(1, 1+len(word2)): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1 return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>76 - Minimum Window Substring</title>
      <link>//alfmunny.com/leetcode-blog/posts/76-minimum-window-substring/</link>
      <pubDate>Fri, 22 May 2020 00:41:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/76-minimum-window-substring/</guid>
      <description>leetcode
Problem Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = &amp;#34;ADOBECODEBANC&amp;#34;, T = &amp;#34;ABC&amp;#34; Output: &amp;#34;BANC&amp;#34; Note: If there is no such window in S that covers all characters in T, return the empty string &amp;#34;&amp;#34;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</description>
    </item>
    
    <item>
      <title>887 - Super Egg Drop</title>
      <link>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</link>
      <pubDate>Sun, 03 May 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</guid>
      <description>leetcode
Problem You are given K eggs, and you have access to a building with N floors from 1 to N. Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.</description>
    </item>
    
    <item>
      <title>128 - Longest Consecutive Sequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</link>
      <pubDate>Sat, 02 May 2020 16:34:20 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</guid>
      <description>leetcode
Problem Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution Solution 1: Hash Map For each value, we maintain the left bound and right bound of range and also update the bounds for left value and right value.</description>
    </item>
    
    <item>
      <title>28 - Implement strStr() (KMP Algorithm)</title>
      <link>//alfmunny.com/leetcode-blog/posts/28-kmp/</link>
      <pubDate>Wed, 29 Apr 2020 21:42:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/28-kmp/</guid>
      <description>leetcode
Problem Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = &amp;#34;hello&amp;#34;, needle = &amp;#34;ll&amp;#34; Output: 2 Example 2: Input: haystack = &amp;#34;aaaaa&amp;#34;, needle = &amp;#34;bba&amp;#34; Output: -1 Solution KMP tutorial
class Solution: def __init__(self, pat): self.pat = pat self.dp = [] self.KMP(self.pat) def KMP(self, pat): M = len(pat) self.dp = [[0] * 256 for _ in range(M)] self.</description>
    </item>
    
    <item>
      <title>124 - Binary Tree Maximum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</link>
      <pubDate>Wed, 29 Apr 2020 16:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</guid>
      <description>leetcode
Problem Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3]
1 / \
2 3
Output: 6 Example 2:
Input: [-10,9,20,null,null,15,7]</description>
    </item>
    
    <item>
      <title>460 - LFU Cache</title>
      <link>//alfmunny.com/leetcode-blog/posts/460-lfu-cache/</link>
      <pubDate>Sun, 26 Apr 2020 00:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/460-lfu-cache/</guid>
      <description>leetcode
Problem Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>309 - Best Time to Buy and Sell Stock with Cooldown</title>
      <link>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Tue, 24 Mar 2020 22:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>188 - Best Time to Buy and Sell Stock IV</title>
      <link>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</link>
      <pubDate>Tue, 24 Mar 2020 21:46:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</guid>
      <description>leetcode
Problem Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</description>
    </item>
    
    <item>
      <title>123 - Best Time to Buy and Sell Stock III</title>
      <link>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Tue, 24 Mar 2020 18:25:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</description>
    </item>
    
    <item>
      <title>85 - Maximal Rectangle</title>
      <link>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</link>
      <pubDate>Tue, 24 Mar 2020 00:57:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</guid>
      <description>Problem Notes Solution  leetcode
Problem Given a 2D binary matrix filled with 0&amp;#39;s and 1&amp;#39;s, find the largest rectangle containing only 1&amp;#39;s and return its area. Example: Input: [ [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;] ] Output: 6 Notes Two parts:
 generate a heights histogram for every row. apple &amp;ldquo;largest rectangle in histogram&amp;rdquo; on each row of histogram  Solution class Solution: def maximalRectangle(self, matrix): if not matrix or not matrix[0]: return 0 m = len(matrix) n = len(matrix[0]) histograms = [[0] * n for i in range(m)] res = 0 for i in range(m): for j in range(n): if matrix[i][j] == &amp;#34;1&amp;#34;: histograms[i][j] = histograms[i - 1][j] + 1 if i &amp;gt; 0 else 1 for histogram in histograms: res = max(res, self.</description>
    </item>
    
    <item>
      <title>84 - Largest Rectangle in Histogram</title>
      <link>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</link>
      <pubDate>Mon, 23 Mar 2020 00:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</guid>
      <description>leetcode
Problem Given n non-negative integers representing the histogram&amp;#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Example: Input: [2,1,5,6,2,3] Output: 10 Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
The largest rectangle is shown in the shaded area, which has area = 10 unit.
Notes Main idea is to caculate both left edge and right edge for every entry in the array</description>
    </item>
    
    <item>
      <title>41 - First Missing Positive</title>
      <link>//alfmunny.com/leetcode-blog/posts/41-first-missing-positive/</link>
      <pubDate>Sat, 21 Mar 2020 16:29:53 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/41-first-missing-positive/</guid>
      <description>Problem Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Notes Run in O(n) time and uses constant extra space
  Say the length of the array is l, the number must be in 1&amp;hellip;l+1 (also l possible numbers)</description>
    </item>
    
  </channel>
</rss>
