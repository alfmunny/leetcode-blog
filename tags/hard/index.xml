<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hard on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/hard/</link>
    <description>Recent content in hard on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Aug 2020 13:21:00 +0200</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/hard/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>980 - Unique Paths III</title>
      <link>//alfmunny.com/leetcode-blog/posts/980-unique-paths-iii/</link>
      <pubDate>Thu, 27 Aug 2020 13:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/980-unique-paths-iii/</guid>
      <description>leetcode
Problem On a 2-dimensional grid, there are 4 types of squares: 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</description>
    </item>
    
    <item>
      <title>132 - Palindrome Partitioning II</title>
      <link>//alfmunny.com/leetcode-blog/posts/132-palindrome-partitioning-ii/</link>
      <pubDate>Wed, 26 Aug 2020 01:00:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/132-palindrome-partitioning-ii/</guid>
      <description>leetcode
Problem Given a string s, partition s such that every substring of the partition is a palindrome Return the minimum cuts needed for a palindrome partitioning of s. Example 1: Input: s = &amp;#34;aab&amp;#34; Output: 1 Explanation: The palindrome partitioning [&amp;#34;aa&amp;#34;,&amp;#34;b&amp;#34;] could be produced using 1 cut. Example 2: Input: s = &amp;#34;a&amp;#34; Output: 0 Example 3: Input: s = &amp;#34;ab&amp;#34; Output: 1 Constraints: 1 &amp;lt;= s.length &amp;lt;= 2000 s consists of lower-case English letters only.</description>
    </item>
    
    <item>
      <title>1032 - Stream of Characters</title>
      <link>//alfmunny.com/leetcode-blog/posts/1032-stream-of-characters/</link>
      <pubDate>Sun, 23 Aug 2020 16:34:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1032-stream-of-characters/</guid>
      <description>leetcode
Problem Implement the StreamChecker class as follows: StreamChecker(words): Constructor, init the data structure with the given words. query(letter): returns true if and only if for some k &amp;gt;= 1, the last k characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list. Example: StreamChecker streamChecker = new StreamChecker([&amp;#34;cd&amp;#34;,&amp;#34;f&amp;#34;,&amp;#34;kl&amp;#34;]); // init the dictionary. streamChecker.query(&amp;#39;a&amp;#39;); // return false streamChecker.query(&amp;#39;b&amp;#39;); // return false streamChecker.</description>
    </item>
    
    <item>
      <title>97 - Interleaving String</title>
      <link>//alfmunny.com/leetcode-blog/posts/97-interleaving-string/</link>
      <pubDate>Tue, 18 Aug 2020 15:15:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/97-interleaving-string/</guid>
      <description>leetcode
Problem Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = &amp;#34;aabcc&amp;#34;, s2 = &amp;#34;dbbca&amp;#34;, s3 = &amp;#34;aadbbcbcac&amp;#34; Output: true Example 2: Input: s1 = &amp;#34;aabcc&amp;#34;, s2 = &amp;#34;dbbca&amp;#34;, s3 = &amp;#34;aadbbbaccc&amp;#34; Output: false Solution DP problem.
Imagin you have a matrix with s1 as its row and s2 as its column.
You have to find a path from upper left corner to bottom right corner, which consisits the s3.</description>
    </item>
    
    <item>
      <title>32 - Longest Valid Parentheses</title>
      <link>//alfmunny.com/leetcode-blog/posts/32-longest-valid-parentheses/</link>
      <pubDate>Thu, 13 Aug 2020 17:14:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/32-longest-valid-parentheses/</guid>
      <description>leetcode
Problem Given a string containing just the characters &amp;#39;(&amp;#39; and &amp;#39;)&amp;#39;, find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: &amp;#34;(()&amp;#34; Output: 2 Explanation: The longest valid parentheses substring is &amp;#34;()&amp;#34; Example 2: Input: &amp;#34;)()())&amp;#34; Output: 4 Explanation: The longest valid parentheses substring is &amp;#34;()()&amp;#34; Solution class Solution: def longestValidParentheses(self, s: str) -&amp;gt; int: stack = [-1] ans = 0 for i in range(len(s)): if s[i] == &amp;#39;(&amp;#39;: stack.</description>
    </item>
    
    <item>
      <title>37 - Sudoku Solver</title>
      <link>//alfmunny.com/leetcode-blog/posts/37-sodoku-solver/</link>
      <pubDate>Fri, 10 Jul 2020 17:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/37-sodoku-solver/</guid>
      <description>leetcode
Problem Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character &amp;#39;.</description>
    </item>
    
    <item>
      <title>10 - Regular Expression Matching</title>
      <link>//alfmunny.com/leetcode-blog/posts/10-regular-expression-matching/</link>
      <pubDate>Fri, 10 Jul 2020 02:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/10-regular-expression-matching/</guid>
      <description>leetcode
Problem Given an input string (s) and a pattern (p), implement regular expression matching with support for &amp;#39;.&amp;#39; and &amp;#39;*&amp;#39;. &amp;#39;.&amp;#39; Matches any single character. &amp;#39;*&amp;#39; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.</description>
    </item>
    
    <item>
      <title>212 - Word Search II</title>
      <link>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</link>
      <pubDate>Wed, 01 Jul 2020 00:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</guid>
      <description>leetcode
Problem Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input: board = [ [&amp;#39;o&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;n&amp;#39;], [&amp;#39;e&amp;#39;,&amp;#39;t&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;e&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;h&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;r&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;v&amp;#39;] ] words = [&amp;#34;oath&amp;#34;,&amp;#34;pea&amp;#34;,&amp;#34;eat&amp;#34;,&amp;#34;rain&amp;#34;] Output: [&amp;#34;eat&amp;#34;,&amp;#34;oath&amp;#34;] Note: All inputs are consist of lowercase letters a-z.</description>
    </item>
    
    <item>
      <title>52 - N-Queens II</title>
      <link>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</link>
      <pubDate>Fri, 12 Jun 2020 17:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Solution class Solution: def totalNQueens(self, n): self.ans = 0 self.dfs(0, n, []) return self.ans def dfs(self, row, n, path): if row == n and len(path) == n: self.ans += 1 for i in range(n): if self.</description>
    </item>
    
    <item>
      <title>51 - N-Queens</title>
      <link>//alfmunny.com/leetcode-blog/posts/51-n-queens/</link>
      <pubDate>Fri, 12 Jun 2020 17:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/51-n-queens/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens&amp;#39; placement, where &amp;#39;Q&amp;#39; and &amp;#39;.&amp;#39; both indicate a queen and an empty space respectively. Solution class Solution: def solveNQueens(self, n): ans = [] self.dfs(0, n, [], ans) return ans def dfs(self, row, n, path, ans): if row == n and len(path) == n: ans.</description>
    </item>
    
    <item>
      <title>72 - Edit Distance</title>
      <link>//alfmunny.com/leetcode-blog/posts/72-edit-distance/</link>
      <pubDate>Sun, 31 May 2020 17:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/72-edit-distance/</guid>
      <description>leetcode
Problem Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = &amp;#34;horse&amp;#34;, word2 = &amp;#34;ros&amp;#34; Output: 3 Explanation: horse -&amp;gt; rorse (replace &amp;#39;h&amp;#39; with &amp;#39;r&amp;#39;) rorse -&amp;gt; rose (remove &amp;#39;r&amp;#39;) rose -&amp;gt; ros (remove &amp;#39;e&amp;#39;) Example 2: Input: word1 = &amp;#34;intention&amp;#34;, word2 = &amp;#34;execution&amp;#34; Output: 5 Explanation: intention -&amp;gt; inention (remove &amp;#39;t&amp;#39;) inention -&amp;gt; enention (replace &amp;#39;i&amp;#39; with &amp;#39;e&amp;#39;) enention -&amp;gt; exention (replace &amp;#39;n&amp;#39; with &amp;#39;x&amp;#39;) exention -&amp;gt; exection (replace &amp;#39;n&amp;#39; with &amp;#39;c&amp;#39;) exection -&amp;gt; execution (insert &amp;#39;u&amp;#39;) Solution class Solution: def minDistance(self, word1: str, word2: str) -&amp;gt; int: dp = [[0] * (1+len(word2)) for _ in range(1+len(word1))] for i in range(1+len(word1)): dp[i][0] = i for j in range(1+len(word2)): dp[0][j] = j for i in range(1, 1+len(word1)): for j in range(1, 1+len(word2)): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1 return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>76 - Minimum Window Substring</title>
      <link>//alfmunny.com/leetcode-blog/posts/76-minimum-window-substring/</link>
      <pubDate>Fri, 22 May 2020 00:41:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/76-minimum-window-substring/</guid>
      <description>leetcode
Problem Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = &amp;#34;ADOBECODEBANC&amp;#34;, T = &amp;#34;ABC&amp;#34; Output: &amp;#34;BANC&amp;#34; Note: If there is no such window in S that covers all characters in T, return the empty string &amp;#34;&amp;#34;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</description>
    </item>
    
    <item>
      <title>887 - Super Egg Drop</title>
      <link>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</link>
      <pubDate>Sun, 03 May 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</guid>
      <description>leetcode
Problem You are given K eggs, and you have access to a building with N floors from 1 to N. Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.</description>
    </item>
    
    <item>
      <title>128 - Longest Consecutive Sequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</link>
      <pubDate>Sat, 02 May 2020 16:34:20 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</guid>
      <description>leetcode
Problem Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution Solution 1: Hash Map For each value, we maintain the left bound and right bound of range and also update the bounds for left value and right value.</description>
    </item>
    
    <item>
      <title>28 - Implement strStr() (KMP Algorithm)</title>
      <link>//alfmunny.com/leetcode-blog/posts/28-kmp/</link>
      <pubDate>Wed, 29 Apr 2020 21:42:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/28-kmp/</guid>
      <description>leetcode
Problem Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = &amp;#34;hello&amp;#34;, needle = &amp;#34;ll&amp;#34; Output: 2 Example 2: Input: haystack = &amp;#34;aaaaa&amp;#34;, needle = &amp;#34;bba&amp;#34; Output: -1 Solution KMP tutorial
class Solution: def __init__(self, pat): self.pat = pat self.dp = [] self.KMP(self.pat) def KMP(self, pat): M = len(pat) self.dp = [[0] * 256 for _ in range(M)] self.</description>
    </item>
    
    <item>
      <title>124 - Binary Tree Maximum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</link>
      <pubDate>Wed, 29 Apr 2020 16:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</guid>
      <description>leetcode
Problem Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3]
1 / \
2 3
Output: 6 Example 2:
Input: [-10,9,20,null,null,15,7]</description>
    </item>
    
    <item>
      <title>460 - LFU Cache</title>
      <link>//alfmunny.com/leetcode-blog/posts/460-lfu-cache/</link>
      <pubDate>Sun, 26 Apr 2020 00:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/460-lfu-cache/</guid>
      <description>leetcode
Problem Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>309 - Best Time to Buy and Sell Stock with Cooldown</title>
      <link>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Tue, 24 Mar 2020 22:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>188 - Best Time to Buy and Sell Stock IV</title>
      <link>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</link>
      <pubDate>Tue, 24 Mar 2020 21:46:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</guid>
      <description>leetcode
Problem Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</description>
    </item>
    
    <item>
      <title>123 - Best Time to Buy and Sell Stock III</title>
      <link>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Tue, 24 Mar 2020 18:25:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</description>
    </item>
    
    <item>
      <title>85 - Maximal Rectangle</title>
      <link>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</link>
      <pubDate>Tue, 24 Mar 2020 00:57:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</guid>
      <description>Problem Notes Solution  leetcode
Problem Given a 2D binary matrix filled with 0&amp;#39;s and 1&amp;#39;s, find the largest rectangle containing only 1&amp;#39;s and return its area. Example: Input: [ [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;] ] Output: 6 Notes Two parts:
 generate a heights histogram for every row. apple &amp;ldquo;largest rectangle in histogram&amp;rdquo; on each row of histogram  Solution class Solution: def maximalRectangle(self, matrix): if not matrix or not matrix[0]: return 0 m = len(matrix) n = len(matrix[0]) histograms = [[0] * n for i in range(m)] res = 0 for i in range(m): for j in range(n): if matrix[i][j] == &amp;#34;1&amp;#34;: histograms[i][j] = histograms[i - 1][j] + 1 if i &amp;gt; 0 else 1 for histogram in histograms: res = max(res, self.</description>
    </item>
    
    <item>
      <title>84 - Largest Rectangle in Histogram</title>
      <link>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</link>
      <pubDate>Mon, 23 Mar 2020 00:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</guid>
      <description>leetcode
Problem Given n non-negative integers representing the histogram&amp;#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Example: Input: [2,1,5,6,2,3] Output: 10 Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
The largest rectangle is shown in the shaded area, which has area = 10 unit.
Notes Main idea is to caculate both left edge and right edge for every entry in the array</description>
    </item>
    
    <item>
      <title>41 - First Missing Positive</title>
      <link>//alfmunny.com/leetcode-blog/posts/41-first-missing-positive/</link>
      <pubDate>Sat, 21 Mar 2020 16:29:53 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/41-first-missing-positive/</guid>
      <description>Problem Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Notes Run in O(n) time and uses constant extra space
  Say the length of the array is l, the number must be in 1&amp;hellip;l+1 (also l possible numbers)</description>
    </item>
    
  </channel>
</rss>