<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>1-pass on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/1-pass/</link>
    <description>Recent content in 1-pass on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Nov 2020 18:35:00 +0100</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/1-pass/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>691 - Stickers to Spell Word</title>
      <link>//alfmunny.com/leetcode-blog/posts/691-stickers-to-spell-word/</link>
      <pubDate>Sun, 22 Nov 2020 18:35:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/691-stickers-to-spell-word/</guid>
      <description>leetcode
Problem We are given N different types of stickers. Each sticker has a lowercase English word on it. You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them. You can use each sticker more than once if you want, and you have infinite quantities of each sticker. What is the minimum number of stickers that you need to spell out the target?</description>
    </item>
    
    <item>
      <title>257 - Binary Tree Paths</title>
      <link>//alfmunny.com/leetcode-blog/posts/257-binary-tree-paths/</link>
      <pubDate>Sun, 22 Nov 2020 16:42:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/257-binary-tree-paths/</guid>
      <description>leetcode
Problem iven a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input: 1 / \ 2 3 \ 5 Output: [&amp;#34;1-&amp;gt;2-&amp;gt;5&amp;#34;, &amp;#34;1-&amp;gt;3&amp;#34;] Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3 Solution class Solution: def binaryTreePaths(self, root: TreeNode) -&amp;gt; List[str]: if not root: return [] if not root.right and not root.left: return [str(root.val)] paths = [str(root.val) + &amp;#34;-&amp;gt;&amp;#34; + s for s in self.</description>
    </item>
    
    <item>
      <title>86 - Partition List</title>
      <link>//alfmunny.com/leetcode-blog/posts/86-partition-list/</link>
      <pubDate>Wed, 18 Nov 2020 19:29:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/86-partition-list/</guid>
      <description>leetcode
Problem Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example: Input: head = 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;2, x = 3 Output: 1-&amp;gt;2-&amp;gt;2-&amp;gt;4-&amp;gt;3-&amp;gt;5 Solution Solution 1: Two Dummy Pointers Simple version: just create two list, and append them in the end</description>
    </item>
    
    <item>
      <title>376 - Wiggle Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/376-wiggle-subsequence/</link>
      <pubDate>Mon, 09 Nov 2020 22:12:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/376-wiggle-subsequence/</guid>
      <description>leetcode
Problem A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</description>
    </item>
    
    <item>
      <title>403 - Frog Jump</title>
      <link>//alfmunny.com/leetcode-blog/posts/403-frog-jump/</link>
      <pubDate>Sun, 08 Nov 2020 01:34:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/403-frog-jump/</guid>
      <description>leetcode
Problem A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water. Given a list of stones&amp;#39; positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.</description>
    </item>
    
    <item>
      <title>Beautiful Arrangement</title>
      <link>//alfmunny.com/leetcode-blog/posts/526-beautiful-arrangement/</link>
      <pubDate>Sat, 10 Oct 2020 11:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/526-beautiful-arrangement/</guid>
      <description>leetcode
Problem Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 &amp;lt;= i &amp;lt;= N) in this array: The number at the ith position is divisible by i. i is divisible by the number at the ith position. Now given N, how many beautiful arrangements can you construct?</description>
    </item>
    
    <item>
      <title>450 - Delete Node in a BST</title>
      <link>//alfmunny.com/leetcode-blog/posts/450-delete-node-in-a-bst/</link>
      <pubDate>Mon, 31 Aug 2020 23:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/450-delete-node-in-a-bst/</guid>
      <description>leetcode
Problem Design an Iterator class, which has: A constructor that takes a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments. A function next() that returns the next combination of length combinationLength in lexicographical order. A function hasNext() that returns True if and only if there exists a next combination. Example: CombinationIterator iterator = new CombinationIterator(&amp;#34;abc&amp;#34;, 2); // creates the iterator. iterator.next(); // returns &amp;#34;ab&amp;#34; iterator.</description>
    </item>
    
    <item>
      <title>980 - Unique Paths III</title>
      <link>//alfmunny.com/leetcode-blog/posts/980-unique-paths-iii/</link>
      <pubDate>Thu, 27 Aug 2020 13:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/980-unique-paths-iii/</guid>
      <description>leetcode
Problem On a 2-dimensional grid, there are 4 types of squares: 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</description>
    </item>
    
    <item>
      <title>436 - Find Right Interval</title>
      <link>//alfmunny.com/leetcode-blog/posts/436-find-right-interval/</link>
      <pubDate>Thu, 27 Aug 2020 12:31:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/436-find-right-interval/</guid>
      <description>leetcode
Problem Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the &amp;#34;right&amp;#34; of i. For any interval i, you need to store the minimum interval j&amp;#39;s index, which means that the interval j has the minimum start point to build the &amp;#34;right&amp;#34; relationship for interval i.</description>
    </item>
    
    <item>
      <title>93 - Restore IP Addresses</title>
      <link>//alfmunny.com/leetcode-blog/posts/93-restore-ip-addresses/</link>
      <pubDate>Thu, 27 Aug 2020 01:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/93-restore-ip-addresses/</guid>
      <description>leetcode
Problem Given a string s containing only digits. Return all possible valid IP addresses that can be obtained from s. You can return them in any order. A valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single points and cannot have leading zeros. For example, &amp;#34;0.1.2.201&amp;#34; and &amp;#34;192.168.1.1&amp;#34; are valid IP addresses and &amp;#34;0.011.255.245&amp;#34;, &amp;#34;192.168.1.312&amp;#34; and &amp;#34;192.168@1.1&amp;#34; are invalid IP addresses.</description>
    </item>
    
    <item>
      <title>412 - Fizz Buzz</title>
      <link>//alfmunny.com/leetcode-blog/posts/412-fizz-buzz/</link>
      <pubDate>Wed, 26 Aug 2020 23:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/412-fizz-buzz/</guid>
      <description>leetcode
Problem Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15, Return: [ &amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;Fizz&amp;#34;, &amp;#34;4&amp;#34;, &amp;#34;Buzz&amp;#34;, &amp;#34;Fizz&amp;#34;, &amp;#34;7&amp;#34;, &amp;#34;8&amp;#34;, &amp;#34;Fizz&amp;#34;, &amp;#34;Buzz&amp;#34;, &amp;#34;11&amp;#34;, &amp;#34;Fizz&amp;#34;, &amp;#34;13&amp;#34;, &amp;#34;14&amp;#34;, &amp;#34;FizzBuzz&amp;#34; ] Solution class Solution: def fizzBuzz(self, n: int) -&amp;gt; List[str]: ans = [] for i in range(1, n+1): if not i % 3 and not i % 5: ans.</description>
    </item>
    
    <item>
      <title>131 - Palindrome Partitioning</title>
      <link>//alfmunny.com/leetcode-blog/posts/131-palindrome-partitioning/</link>
      <pubDate>Wed, 26 Aug 2020 00:00:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/131-palindrome-partitioning/</guid>
      <description>leetcode
Problem Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: Input: &amp;#34;aab&amp;#34; Output: [ [&amp;#34;aa&amp;#34;,&amp;#34;b&amp;#34;], [&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;] ] Solution class Solution: def partition(self, s: str) -&amp;gt; List[List[str]]: ans = [] self.dfs(s, 0, ans, []) return ans def dfs(self, s, start, ans, path): if start == len(s): ans.append(path.copy()) return for i in range(start, len(s)): w = s[start:i+1] if w == w[::-1]: path.</description>
    </item>
    
    <item>
      <title>404 - Sum of Left Leaves</title>
      <link>//alfmunny.com/leetcode-blog/posts/404-sum-of-left-leaves/</link>
      <pubDate>Mon, 24 Aug 2020 22:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/404-sum-of-left-leaves/</guid>
      <description>leetcode
Problem Find the sum of all left leaves in a given binary tree. Example: 3 / \ 9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. Solution class Solution: def sumOfLeftLeaves(self, root: TreeNode) -&amp;gt; int: return self.dfs(root, 0, False) def dfs(self, root, presum, isLeft): if not root: return 0 if not root.left and not root.right and isLeft: return presum + root.</description>
    </item>
    
    <item>
      <title>1219 - Path with Maximum Gold</title>
      <link>//alfmunny.com/leetcode-blog/posts/1219-path-with-maximum-gold/</link>
      <pubDate>Sun, 23 Aug 2020 19:07:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1219-path-with-maximum-gold/</guid>
      <description>leetcode
Problem In a gold mine grid of size m * n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty. Return the maximum amount of gold you can collect under the conditions: Every time you are located in a cell you will collect all the gold in that cell. From your position you can walk one step to the left, right, up or down.</description>
    </item>
    
    <item>
      <title>199 - Binary Tree Right Side View</title>
      <link>//alfmunny.com/leetcode-blog/posts/199-binary-tree-right-side-view/</link>
      <pubDate>Sun, 23 Aug 2020 17:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/199-binary-tree-right-side-view/</guid>
      <description>leetcode
Problem Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- Solution Comprare the depth. DFS.
Keep track of the current depth. And the length of current answer is the previous depth.</description>
    </item>
    
    <item>
      <title>1079 - Letter Tile Possibilities</title>
      <link>//alfmunny.com/leetcode-blog/posts/1079-letter-tile-possibilities/</link>
      <pubDate>Wed, 19 Aug 2020 20:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1079-letter-tile-possibilities/</guid>
      <description>leetcode
Problem You have n tiles, where each tile has one letter tiles[i] printed on it. Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles. Example 1: Input: tiles = &amp;#34;AAB&amp;#34; Output: 8 Explanation: The possible sequences are &amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;AA&amp;#34;, &amp;#34;AB&amp;#34;, &amp;#34;BA&amp;#34;, &amp;#34;AAB&amp;#34;, &amp;#34;ABA&amp;#34;, &amp;#34;BAA&amp;#34;. Example 2: Input: tiles = &amp;#34;AAABBC&amp;#34; Output: 188 Example 3: Input: tiles = &amp;#34;V&amp;#34; Output: 1 Constraints: 1 &amp;lt;= tiles.</description>
    </item>
    
    <item>
      <title>784 - Letter Case Permutation</title>
      <link>//alfmunny.com/leetcode-blog/posts/784-letter-case-permutation/</link>
      <pubDate>Wed, 19 Aug 2020 19:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/784-letter-case-permutation/</guid>
      <description>leetcode
Problem Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. You can return the output in any order. Example 1: Input: S = &amp;#34;a1b2&amp;#34; Output: [&amp;#34;a1b2&amp;#34;,&amp;#34;a1B2&amp;#34;,&amp;#34;A1b2&amp;#34;,&amp;#34;A1B2&amp;#34;] Example 2: Input: S = &amp;#34;3z4&amp;#34; Output: [&amp;#34;3z4&amp;#34;,&amp;#34;3Z4&amp;#34;] Example 3: Input: S = &amp;#34;12345&amp;#34; Output: [&amp;#34;12345&amp;#34;] Example 4: Input: S = &amp;#34;0&amp;#34; Output: [&amp;#34;0&amp;#34;] Constraints: S will be a string with length between 1 and 12.</description>
    </item>
    
    <item>
      <title>368 - Largest Divisible Subset</title>
      <link>//alfmunny.com/leetcode-blog/posts/368-largest-divisible-subset/</link>
      <pubDate>Wed, 19 Aug 2020 16:05:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/368-largest-divisible-subset/</guid>
      <description>leetcode
Problem Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1: Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok) Example 2: Input: [1,2,4,8] Output: [1,2,4,8] Solution Solution 1: DP class Solution: def largestDivisibleSubset(self, nums: List[int]) -&amp;gt; List[int]: if not nums: return nums dp = [1] * len(nums) pre = [i for i in range(len(nums))] nums.</description>
    </item>
    
    <item>
      <title>824 - Goat Latin</title>
      <link>//alfmunny.com/leetcode-blog/posts/824-goat-latin/</link>
      <pubDate>Wed, 19 Aug 2020 12:31:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/824-goat-latin/</guid>
      <description>leetcode
Problem A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to &amp;#34;Goat Latin&amp;#34; (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append &amp;#34;ma&amp;#34; to the end of the word. For example, the word &amp;#39;apple&amp;#39; becomes &amp;#39;applema&amp;#39;.</description>
    </item>
    
    <item>
      <title>110 - Balanced Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/110-balanced-binary-tree/</link>
      <pubDate>Wed, 19 Aug 2020 11:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/110-balanced-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \ 9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \ 2 2 / \ 3 3 / \ 4 4 Return false.</description>
    </item>
    
    <item>
      <title>97 - Interleaving String</title>
      <link>//alfmunny.com/leetcode-blog/posts/97-interleaving-string/</link>
      <pubDate>Tue, 18 Aug 2020 15:15:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/97-interleaving-string/</guid>
      <description>leetcode
Problem Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = &amp;#34;aabcc&amp;#34;, s2 = &amp;#34;dbbca&amp;#34;, s3 = &amp;#34;aadbbcbcac&amp;#34; Output: true Example 2: Input: s1 = &amp;#34;aabcc&amp;#34;, s2 = &amp;#34;dbbca&amp;#34;, s3 = &amp;#34;aadbbbaccc&amp;#34; Output: false Solution DP problem.
Imagin you have a matrix with s1 as its row and s2 as its column.
You have to find a path from upper left corner to bottom right corner, which consisits the s3.</description>
    </item>
    
    <item>
      <title>967 - Numbers With Same Consecutive Differences</title>
      <link>//alfmunny.com/leetcode-blog/posts/967-numbers-with-same-consecutive-differences/</link>
      <pubDate>Tue, 18 Aug 2020 14:27:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/967-numbers-with-same-consecutive-differences/</guid>
      <description>leetcode
Problem Return all non-negative integers of length N such that the absolute difference between every two consecutive digits is K. Note that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid. You may return the answer in any order. Example 1: Input: N = 3, K = 7 Output: [181,292,707,818,929] Explanation: Note that 070 is not a valid number, because it has leading zeroes.</description>
    </item>
    
    <item>
      <title>142 - Reorder List</title>
      <link>//alfmunny.com/leetcode-blog/posts/142-reorder-list/</link>
      <pubDate>Tue, 18 Aug 2020 01:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/142-reorder-list/</guid>
      <description>leetcode
Problem Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list&amp;#39;s nodes, only nodes itself may be changed. Example 1: Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, reorder it to 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. Example 2: Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, reorder it to 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3. Solution class Solution: def reorderList(self, head: ListNode) -&amp;gt; None: if not head or not head.next: return fast = slow = head while fast.next and fast.next.next: fast = fast.</description>
    </item>
    
    <item>
      <title>148 - Sort List</title>
      <link>//alfmunny.com/leetcode-blog/posts/148-sort-list/</link>
      <pubDate>Mon, 17 Aug 2020 16:41:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/148-sort-list/</guid>
      <description>leetcode
Problem Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4 Example 2: Input: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0 Output: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5 Solution Merge Sort
 Slow-Fast-Pointer to split the list into half. Do not forget slow.next = None Sort two part recursively and merge together  class Solution: def sortList(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head # split in half fast = slow = head while fast.</description>
    </item>
    
    <item>
      <title>1103 - Distribute Candies to People</title>
      <link>//alfmunny.com/leetcode-blog/posts/1103-distribute-candies-to-people/</link>
      <pubDate>Mon, 17 Aug 2020 15:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1103-distribute-candies-to-people/</guid>
      <description>leetcode
Problem We distribute some number of candies, to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.</description>
    </item>
    
    <item>
      <title>191 - Number of 1 Bits</title>
      <link>//alfmunny.com/leetcode-blog/posts/191-number-of-1-bits/</link>
      <pubDate>Fri, 14 Aug 2020 00:01:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/191-number-of-1-bits/</guid>
      <description>leetcode
Problem Write a function that takes an unsigned integer and return the number of &amp;#39;1&amp;#39; bits it has (also known as the Hamming weight). Example 1: Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three &amp;#39;1&amp;#39; bits. Example 2: Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one &amp;#39;1&amp;#39; bit. Example 3: Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &amp;#39;1&amp;#39; bits.</description>
    </item>
    
    <item>
      <title>461 - Hamming Distance</title>
      <link>//alfmunny.com/leetcode-blog/posts/461-hamming-distance/</link>
      <pubDate>Sat, 18 Jul 2020 00:30:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/461-hamming-distance/</guid>
      <description>leetcode
Problem The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y &amp;lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different.</description>
    </item>
    
    <item>
      <title>36 - Valid Sudoku</title>
      <link>//alfmunny.com/leetcode-blog/posts/36-valid-sudoku/</link>
      <pubDate>Sun, 12 Jul 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/36-valid-sudoku/</guid>
      <description>leetcode
Problem Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solution class Solution: def isValidSudoku(self, board: List[List[str]]) -&amp;gt; bool: for row in board: nums = [x for x in row if x !</description>
    </item>
    
    <item>
      <title>37 - Sudoku Solver</title>
      <link>//alfmunny.com/leetcode-blog/posts/37-sodoku-solver/</link>
      <pubDate>Fri, 10 Jul 2020 17:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/37-sodoku-solver/</guid>
      <description>leetcode
Problem Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character &amp;#39;.</description>
    </item>
    
    <item>
      <title>15 - 3SUM</title>
      <link>//alfmunny.com/leetcode-blog/posts/15-3sum/</link>
      <pubDate>Thu, 09 Jul 2020 23:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/15-3sum/</guid>
      <description>leetcode
Problem Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Solution class Solution: def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]: if len(nums) &amp;lt; 3: return [] ans = [] nums.</description>
    </item>
    
    <item>
      <title>695 - Max Area of Island</title>
      <link>//alfmunny.com/leetcode-blog/posts/695-max-area-of-island/</link>
      <pubDate>Tue, 07 Jul 2020 16:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/695-max-area-of-island/</guid>
      <description>leetcode
Problem Given a non-empty 2D array grid of 0&amp;#39;s and 1&amp;#39;s, an island is a group of 1&amp;#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6.</description>
    </item>
    
    <item>
      <title>463 - Island Perimeter</title>
      <link>//alfmunny.com/leetcode-blog/posts/463-island-perimeter/</link>
      <pubDate>Tue, 07 Jul 2020 16:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/463-island-perimeter/</guid>
      <description>leetcode
Problem You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn&amp;#39;t have &amp;#34;lakes&amp;#34; (water inside that isn&amp;#39;t connected to the water around the island). One cell is a square with side length 1.</description>
    </item>
    
    <item>
      <title>107 - Binary Tree Level Order Traversal II</title>
      <link>//alfmunny.com/leetcode-blog/posts/107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Fri, 03 Jul 2020 22:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/107-binary-tree-level-order-traversal-ii/</guid>
      <description>leetcode
Problem Given a binary tree, return the bottom-up level order traversal of its nodes&amp;#39; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Solution class Solution: def levelOrderBottom(self, root: TreeNode) -&amp;gt; List[List[int]]: if not root: return [] queue = [root] stack = [] while queue: next_queue = [] tmp = [] while queue: n = queue.</description>
    </item>
    
    <item>
      <title>263 - Ugly Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/263-ugly-number/</link>
      <pubDate>Sat, 27 Jun 2020 23:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/263-ugly-number/</guid>
      <description>leetcode
Problem Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2 Example 3: Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7.</description>
    </item>
    
    <item>
      <title>303 - Range Sum Query - Immutable</title>
      <link>//alfmunny.com/leetcode-blog/posts/303-range-sum-query-immutable/</link>
      <pubDate>Sat, 27 Jun 2020 15:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/303-range-sum-query-immutable/</guid>
      <description>leetcode
Problem Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. Solution class NumArray: def __init__(self, nums: List[int]): self.dp = list(nums) self.</description>
    </item>
    
    <item>
      <title>130 - Surrounded Regions</title>
      <link>//alfmunny.com/leetcode-blog/posts/130-surrounded-regions/</link>
      <pubDate>Fri, 26 Jun 2020 01:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/130-surrounded-regions/</guid>
      <description>leetcode
Problem Given a 2D board containing &amp;#39;X&amp;#39; and &amp;#39;O&amp;#39; (the letter O), capture all regions surrounded by &amp;#39;X&amp;#39;. A region is captured by flipping all &amp;#39;O&amp;#39;s into &amp;#39;X&amp;#39;s in that surrounded region. Example: X X X X X O O X X X O X X O X X After running your function, the board should be: X X X X X X X X X X X X X O X X Explanation: Surrounded regions shouldn’t be on the border, which means that any &amp;#39;O&amp;#39; on the border of the board are not flipped to &amp;#39;X&amp;#39;.</description>
    </item>
    
    <item>
      <title>83 - Remove Duplicates from Sorted List</title>
      <link>//alfmunny.com/leetcode-blog/posts/83-remove-duplicates-from-sorted-list/</link>
      <pubDate>Sat, 20 Jun 2020 01:42:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/83-remove-duplicates-from-sorted-list/</guid>
      <description>leetcode
Problem Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2 Example 2: Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3 Solution class Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head first = head second = first.next while second: if first.val == second.val: first.next = second.next second = first.next else: first, second = second, second.next return head </description>
    </item>
    
    <item>
      <title>162 - Find Peak Element</title>
      <link>//alfmunny.com/leetcode-blog/posts/162-find-peak-element/</link>
      <pubDate>Thu, 18 Jun 2020 16:09:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/162-find-peak-element/</guid>
      <description>leetcode
Problem A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
    
    <item>
      <title>74 - Search a 2D Matrix</title>
      <link>//alfmunny.com/leetcode-blog/posts/74-search-a-2d-matrix/</link>
      <pubDate>Thu, 18 Jun 2020 14:46:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/74-search-a-2d-matrix/</guid>
      <description>leetcode
Problem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false Solution class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: if not matrix or not matrix[0]: return False rl, rr = 0, len(matrix) - 1 cl, cr = 0, len(matrix[0]) - 1 while rl &amp;lt;= rr: mid = (rl + rr) // 2 if target &amp;lt; matrix[mid][0]: rr = mid - 1 elif target &amp;gt; matrix[mid][-1]: rl = mid + 1 else: rl = mid break if rl &amp;gt; rr: return False while cl &amp;lt;= cr: mid = (cl + cr) // 2 if target &amp;lt; matrix[rl][mid]: cr = mid - 1 elif target &amp;gt; matrix[rl][mid]: cl = mid + 1 else: return True return False </description>
    </item>
    
    <item>
      <title>63 - Unique Paths II</title>
      <link>//alfmunny.com/leetcode-blog/posts/63-unique-paths-ii/</link>
      <pubDate>Thu, 18 Jun 2020 14:25:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/63-unique-paths-ii/</guid>
      <description>leetcode
Problem A robot is located at the top-left corner of a m x n grid (marked &amp;#39;Start&amp;#39; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;#39;Finish&amp;#39; in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?</description>
    </item>
    
    <item>
      <title>61 - Rotate List</title>
      <link>//alfmunny.com/leetcode-blog/posts/61-rotate-list/</link>
      <pubDate>Thu, 18 Jun 2020 14:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/61-rotate-list/</guid>
      <description>leetcode
Problem Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 Output: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Explanation: rotate 1 steps to the right: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL rotate 2 steps to the right: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Example 2: Input: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL, k = 4 Output: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Explanation: rotate 1 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL rotate 2 steps to the right: 1-&amp;gt;2-&amp;gt;0-&amp;gt;NULL rotate 3 steps to the right: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL rotate 4 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Solution Note: k may be larger than the total count of nodes.</description>
    </item>
    
    <item>
      <title>59 - Spiral Matrix II</title>
      <link>//alfmunny.com/leetcode-blog/posts/59-spiral-matrix-ii/</link>
      <pubDate>Thu, 18 Jun 2020 13:59:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/59-spiral-matrix-ii/</guid>
      <description>leetcode
Problem Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] Solution class Solution: def generateMatrix(self, n: int) -&amp;gt; List[List[int]]: matrix = [[0] * n for _ in range(n)] step = [[0,1], [1, 0], [0, -1], [-1, 0]] i = j = di = 0 for x in range(1, n * n+1): matrix[i][j] = x ni = i + step[di][0] nj = j + step[di][1] if 0 &amp;lt;= ni &amp;lt; n and 0 &amp;lt;= nj &amp;lt; n and not matrix[ni][nj]: i, j = ni, nj else: di = (di + 1) % 4 i, j = i + step[di][0], j + step[di][1] return matrix </description>
    </item>
    
    <item>
      <title>118 - Pascal&#39;s Triangle</title>
      <link>//alfmunny.com/leetcode-blog/posts/118-pascals-triangle/</link>
      <pubDate>Wed, 17 Jun 2020 23:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/118-pascals-triangle/</guid>
      <description>leetcode
Problem Given a non-negative integer numRows, generate the first numRows of Pascal&amp;#39;s triangle. Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] Solution class Solution: def generate(self, numRows: int) -&amp;gt; List[List[int]]: ans = [] for i in range(1, numRows+1): level = [1] * i if ans: for j in range(1, i-1): level[j] = ans[-1][j-1] + ans[-1][j] ans.append(level) return ans </description>
    </item>
    
    <item>
      <title>113 - Path Sum II</title>
      <link>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</link>
      <pubDate>Wed, 17 Jun 2020 23:51:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</guid>
      <description>leetcode
Problem Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;#39;s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] Solution class Solution: def pathSum(self, root: TreeNode, sum: int) -&amp;gt; List[List[int]]: ans = [] self.</description>
    </item>
    
    <item>
      <title>112 - Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/112-path-sum/</link>
      <pubDate>Wed, 17 Jun 2020 23:50:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/112-path-sum/</guid>
      <description>leetcode
Problem Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>100 - Same Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/100-same-tree/</link>
      <pubDate>Wed, 17 Jun 2020 23:48:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/100-same-tree/</guid>
      <description>leetcode
Problem Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false Solution class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&amp;gt; bool: if p and not q: return False if not p and q: return False if not p and not q: return True if p.</description>
    </item>
    
    <item>
      <title>90 - Subsets II</title>
      <link>//alfmunny.com/leetcode-blog/posts/90-subsets-ii/</link>
      <pubDate>Wed, 17 Jun 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/90-subsets-ii/</guid>
      <description>leetcode
Problem Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] Solution class Solution: def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]: ans = [] marked = [False] * len(nums) self.dfs(sorted(nums), 0, [], ans, marked) return ans def dfs(self, nums, index, path, ans, marked): ans.</description>
    </item>
    
    <item>
      <title>77 - Combinations</title>
      <link>//alfmunny.com/leetcode-blog/posts/77-combinations/</link>
      <pubDate>Fri, 12 Jun 2020 17:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/77-combinations/</guid>
      <description>leetcode
Problem Share Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] Solution class Solution: def combine(self, n: int, k: int) -&amp;gt; List[List[int]]: ans = [] self.dfs(1, n, k, [], ans) return ans def dfs(self, index, n, k, path, ans): if k == 0: ans.</description>
    </item>
    
    <item>
      <title>52 - N-Queens II</title>
      <link>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</link>
      <pubDate>Fri, 12 Jun 2020 17:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Solution class Solution: def totalNQueens(self, n): self.ans = 0 self.dfs(0, n, []) return self.ans def dfs(self, row, n, path): if row == n and len(path) == n: self.ans += 1 for i in range(n): if self.</description>
    </item>
    
    <item>
      <title>51 - N-Queens</title>
      <link>//alfmunny.com/leetcode-blog/posts/51-n-queens/</link>
      <pubDate>Fri, 12 Jun 2020 17:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/51-n-queens/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens&amp;#39; placement, where &amp;#39;Q&amp;#39; and &amp;#39;.&amp;#39; both indicate a queen and an empty space respectively. Solution class Solution: def solveNQueens(self, n): ans = [] self.dfs(0, n, [], ans) return ans def dfs(self, row, n, path, ans): if row == n and len(path) == n: ans.</description>
    </item>
    
    <item>
      <title>17 - Letter Combinations of a Phone Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/17-letter-combinations-of-a-phone-number/</link>
      <pubDate>Thu, 11 Jun 2020 16:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/17-letter-combinations-of-a-phone-number/</guid>
      <description>leetcode
Problem Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: &amp;#34;23&amp;#34; Output: [&amp;#34;ad&amp;#34;, &amp;#34;ae&amp;#34;, &amp;#34;af&amp;#34;, &amp;#34;bd&amp;#34;, &amp;#34;be&amp;#34;, &amp;#34;bf&amp;#34;, &amp;#34;cd&amp;#34;, &amp;#34;ce&amp;#34;, &amp;#34;cf&amp;#34;]. Solution Solution 1: DFS class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: m = { 2: &amp;#34;abc&amp;#34;, 3: &amp;#34;def&amp;#34;, 4: &amp;#34;ghi&amp;#34;, 5: &amp;#34;jkl&amp;#34;, 6: &amp;#34;mno&amp;#34;, 7: &amp;#34;pqrs&amp;#34;, 8: &amp;#34;tuv&amp;#34;, 9: &amp;#34;wxyz&amp;#34; } ans = [] self.</description>
    </item>
    
    <item>
      <title>216 - Combination Sum III</title>
      <link>//alfmunny.com/leetcode-blog/posts/216-combination-sum-iii/</link>
      <pubDate>Thu, 11 Jun 2020 15:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/216-combination-sum-iii/</guid>
      <description>leetcode
Problem Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] Solution class Solution: def combinationSum3(self, k: int, n: int) -&amp;gt; List[List[int]]: ans = [] self.</description>
    </item>
    
    <item>
      <title>39 - Combination Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/39-combination-sum/</link>
      <pubDate>Wed, 10 Jun 2020 23:55:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/39-combination-sum/</guid>
      <description>leetcode
Problem Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] Solution Backtracking problem.</description>
    </item>
    
    <item>
      <title>392 - Is Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/392-is-subsequence/</link>
      <pubDate>Tue, 09 Jun 2020 23:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/392-is-subsequence/</guid>
      <description>leetcode
Problem Given a string s and a string t, check if s is subsequence of t. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &amp;#34;ace&amp;#34; is a subsequence of &amp;#34;abcde&amp;#34; while &amp;#34;aec&amp;#34; is not). Follow up: If there are lots of incoming S, say S1, S2, .</description>
    </item>
    
    <item>
      <title>66 - Plus One</title>
      <link>//alfmunny.com/leetcode-blog/posts/66-plus-one/</link>
      <pubDate>Mon, 08 Jun 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/66-plus-one/</guid>
      <description>leetcode
Problem Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title>38 - Count and Say</title>
      <link>//alfmunny.com/leetcode-blog/posts/38-count-and-say/</link>
      <pubDate>Mon, 08 Jun 2020 23:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/38-count-and-say/</guid>
      <description>leetcode
Problem The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as &amp;#34;one 1&amp;#34; or 11. 11 is read off as &amp;#34;two 1s&amp;#34; or 21. 21 is read off as &amp;#34;one 2, then one 1&amp;#34; or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</description>
    </item>
    
    <item>
      <title>213 - House Robber II</title>
      <link>//alfmunny.com/leetcode-blog/posts/213-house-robber-ii/</link>
      <pubDate>Mon, 08 Jun 2020 23:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/213-house-robber-ii/</guid>
      <description>leetcode
Problem You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>231 - Power of Two</title>
      <link>//alfmunny.com/leetcode-blog/posts/231-power-of-two/</link>
      <pubDate>Mon, 08 Jun 2020 22:35:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/231-power-of-two/</guid>
      <description>leetcode
Problem Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true Explanation: 20 = 1 Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false Solution Solution 1: Straight forward class Solution: def powerOfTwo(self, n): while n != 1: if n % 2: return False n //= 2 return True Solution 2: Bit manipulation power of two: n = 1000000 n - 1 = 111111 n &amp;amp; (n-1) == 0</description>
    </item>
    
    <item>
      <title>518 - Coin Change 2</title>
      <link>//alfmunny.com/leetcode-blog/posts/518-coin-change-2/</link>
      <pubDate>Sun, 07 Jun 2020 21:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/518-coin-change-2/</guid>
      <description>leetcode
Problem You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.</description>
    </item>
    
    <item>
      <title>237 - Delete Node in a Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/237-delete-node-in-a-linked-list/</link>
      <pubDate>Wed, 03 Jun 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/237-delete-node-in-a-linked-list/</guid>
      <description>leetcode
Problem Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following: Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&amp;gt; 1 -&amp;gt; 9 after calling your function. Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -&amp;gt; 5 -&amp;gt; 9 after calling your function.</description>
    </item>
    
    <item>
      <title>746 - Min Cost Climbing Stairs</title>
      <link>//alfmunny.com/leetcode-blog/posts/746-min-cost-climbing-stairs/</link>
      <pubDate>Tue, 02 Jun 2020 00:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/746-min-cost-climbing-stairs/</guid>
      <description>leetcode
Problem On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</description>
    </item>
    
    <item>
      <title>226 - Invert Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/226-invert-binary-tree/</link>
      <pubDate>Mon, 01 Jun 2020 23:36:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/226-invert-binary-tree/</guid>
      <description>leetcode
Problem Invert a binary tree. Example: Input: 4 / \ 2 7 / \ / \ 1 3 6 9 Output: 4 / \ 7 2 / \ / \ 9 6 3 1 Solution class Solution: def invertTree(self): if root: tmp = root.left root.left = self.invertTree(root.right) root.right = self.invertTree(tmp) return root </description>
    </item>
    
    <item>
      <title>973 - K Closest Points to Origin</title>
      <link>//alfmunny.com/leetcode-blog/posts/973-k-closest-points-to-origin/</link>
      <pubDate>Sat, 30 May 2020 23:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/973-k-closest-points-to-origin/</guid>
      <description>leetcode
Problem We have a list of points on the plane. Find the K closest points to the origin (0, 0). (Here, the distance between two points on a plane is the Euclidean distance.) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.) Example 1: Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10).</description>
    </item>
    
    <item>
      <title>210 - Course Schedule II</title>
      <link>//alfmunny.com/leetcode-blog/posts/210-course-schedule-ii/</link>
      <pubDate>Fri, 29 May 2020 20:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/210-course-schedule-ii/</guid>
      <description>leetcode
Problem There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them.</description>
    </item>
    
    <item>
      <title>1035 - Uncrossed Lines</title>
      <link>//alfmunny.com/leetcode-blog/posts/1035-uncrossed-lines/</link>
      <pubDate>Mon, 25 May 2020 16:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1035-uncrossed-lines/</guid>
      <description>leetcode
Problem We write the integers of A and B (in the order they are given) on two separate horizontal lines. Now, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j] such that: A[i] == B[j]; The line we draw does not intersect any other connecting (non-horizontal) line. Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</description>
    </item>
    
    <item>
      <title>451 - Sort Characters By Frequency</title>
      <link>//alfmunny.com/leetcode-blog/posts/451-sort-characters-by-frequency/</link>
      <pubDate>Fri, 22 May 2020 14:19:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/451-sort-characters-by-frequency/</guid>
      <description>leetcode
Problem Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: &amp;#34;tree&amp;#34; Output: &amp;#34;eert&amp;#34; Explanation: &amp;#39;e&amp;#39; appears twice while &amp;#39;r&amp;#39; and &amp;#39;t&amp;#39; both appear once. So &amp;#39;e&amp;#39; must appear before both &amp;#39;r&amp;#39; and &amp;#39;t&amp;#39;. Therefore &amp;#34;eetr&amp;#34; is also a valid answer. Example 2: Input: &amp;#34;cccaaa&amp;#34; Output: &amp;#34;cccaaa&amp;#34; Explanation: Both &amp;#39;c&amp;#39; and &amp;#39;a&amp;#39; appear three times, so &amp;#34;aaaccc&amp;#34; is also a valid answer. Note that &amp;#34;cacaca&amp;#34; is incorrect, as the same characters must be together.</description>
    </item>
    
    <item>
      <title>76 - Minimum Window Substring</title>
      <link>//alfmunny.com/leetcode-blog/posts/76-minimum-window-substring/</link>
      <pubDate>Fri, 22 May 2020 00:41:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/76-minimum-window-substring/</guid>
      <description>leetcode
Problem Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = &amp;#34;ADOBECODEBANC&amp;#34;, T = &amp;#34;ABC&amp;#34; Output: &amp;#34;BANC&amp;#34; Note: If there is no such window in S that covers all characters in T, return the empty string &amp;#34;&amp;#34;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</description>
    </item>
    
    <item>
      <title>1277 - Count Square Submatrices with All Ones</title>
      <link>//alfmunny.com/leetcode-blog/posts/1227-count-square-submatrices-with-all-ones/</link>
      <pubDate>Fri, 22 May 2020 00:01:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1227-count-square-submatrices-with-all-ones/</guid>
      <description>leetcode
Problem Given a m * n matrix of ones and zeros, return how many square submatrices have all ones. Example 1: Input: matrix = [ [0,1,1,1], [1,1,1,1], [0,1,1,1] ] Output: 15 Explanation: There are 10 squares of side 1. There are 4 squares of side 2. There is 1 square of side 3. Total number of squares = 10 + 4 + 1 = 15. Example 2: Input: matrix = [ [1,0,1], [1,1,0], [1,1,0] ] Output: 7 Explanation: There are 6 squares of side 1.</description>
    </item>
    
    <item>
      <title>567 - Permutation in String</title>
      <link>//alfmunny.com/leetcode-blog/posts/567-permutation-in-string/</link>
      <pubDate>Mon, 18 May 2020 18:14:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/567-permutation-in-string/</guid>
      <description>leetcode
Problem Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string&amp;#39;s permutations is the substring of the second string. Example 1: Input: s1 = &amp;#34;ab&amp;#34; s2 = &amp;#34;eidbaooo&amp;#34; Output: True Explanation: s2 contains one permutation of s1 (&amp;#34;ba&amp;#34;). Example 2: Input:s1= &amp;#34;ab&amp;#34; s2 = &amp;#34;eidboaoo&amp;#34; Output: False Note: The input strings only contain lower case letters.</description>
    </item>
    
    <item>
      <title>328 - Odd Even Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/328-odd-even-linked-list/</link>
      <pubDate>Sat, 16 May 2020 17:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/328-odd-even-linked-list/</guid>
      <description>leetcode
Problem Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL Example 2: Input: 2-&amp;gt;1-&amp;gt;3-&amp;gt;5-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;NULL Output: 2-&amp;gt;3-&amp;gt;6-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;4-&amp;gt;NULL Note: The relative order inside both the even and odd groups should remain as it was in the input.</description>
    </item>
    
    <item>
      <title>540 - Single Element in a Sorted Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/540-single-element-in-a-sorted-array/</link>
      <pubDate>Tue, 12 May 2020 18:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/540-single-element-in-a-sorted-array/</guid>
      <description>leetcode
Problem  You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.
Example 1:
Input: [1,1,2,3,3,4,4,8,8] Output: 2
Example 2:
Input: [3,3,7,7,10,11,11] Output: 10
 Solution class Solution: def singleNonDuplicate(self, nums): lo = 0 hi = len(nums) - 1 while lo &amp;lt; hi: mid = (lo + hi) // 2 if mid == 0: return mid if (mid - lo + 1) % 2 == 0: if nums[mid] == nums[mid - 1]: lo = mid + 1 else: hi = mid - 1 else: if nums[mid] == nums[mid - 1]: hi = mid - 2 else: lo = mid return nums[lo] print(Solution().</description>
    </item>
    
    <item>
      <title>997 - Find the Town Judge</title>
      <link>//alfmunny.com/leetcode-blog/posts/997-find-the-town-judge/</link>
      <pubDate>Sun, 10 May 2020 21:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/997-find-the-town-judge/</guid>
      <description>leetcode
Problem In a town, there are N people labelled from 1 to N. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: 1. The town judge trusts nobody. 2. Everybody (except for the town judge) trusts the town judge. 3. There is exactly one person that satisfies properties 1 and 2. You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.</description>
    </item>
    
    <item>
      <title>733 - Flood Fill</title>
      <link>//alfmunny.com/leetcode-blog/posts/733-flood-fill/</link>
      <pubDate>Sat, 09 May 2020 15:50:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/733-flood-fill/</guid>
      <description>leetcode
Problem An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535). Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, &amp;#34;flood fill&amp;#34; the image. To perform a &amp;#34;flood fill&amp;#34;, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.</description>
    </item>
    
    <item>
      <title>1232 - Check If It Is a Straight Line</title>
      <link>//alfmunny.com/leetcode-blog/posts/1232-check-if-it-is-a-straight-line/</link>
      <pubDate>Sat, 09 May 2020 01:18:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1232-check-if-it-is-a-straight-line/</guid>
      <description>leetcode
Problem You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane. Solution Important
Notice the divider. It may be zero, when the lines are horizontal.
class Solution: def checkStraightLine(self, coordinates: List[List[int]]) -&amp;gt; bool: p1 = coordinates[0] p2 = coordinates[1] slope = self.slope(p1, p2) for i in range(2, len(coordinates)): if self.</description>
    </item>
    
    <item>
      <title>Cousins in Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/counsins-in-binary-tree/</link>
      <pubDate>Thu, 07 May 2020 21:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/counsins-in-binary-tree/</guid>
      <description>leetcode
Problem In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins.</description>
    </item>
    
    <item>
      <title>337 - House Robber III</title>
      <link>//alfmunny.com/leetcode-blog/posts/337-house-robber-ii/</link>
      <pubDate>Wed, 06 May 2020 17:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/337-house-robber-ii/</guid>
      <description>leetcode
Problem The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;#34;root.&amp;#34; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;#34;all houses in this place forms a binary tree&amp;#34;. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description>
    </item>
    
    <item>
      <title>1009 - Complement of Base 10 Integer</title>
      <link>//alfmunny.com/leetcode-blog/posts/1009-complement-of-base-10-integer/</link>
      <pubDate>Mon, 04 May 2020 17:59:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1009-complement-of-base-10-integer/</guid>
      <description>leetcode
Problem Every non-negative integer N has a binary representation. For example, 5 can be represented as &amp;#34;101&amp;#34; in binary, 11 as &amp;#34;1011&amp;#34; in binary, and so on. Note that except for N = 0, there are no leading zeroes in any binary representation. The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1. For example, the complement of &amp;#34;101&amp;#34; in binary is &amp;#34;010&amp;#34; in binary.</description>
    </item>
    
    <item>
      <title>98 - Validate Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/98-validate-binary-search-tree/</link>
      <pubDate>Sat, 02 May 2020 17:19:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/98-validate-binary-search-tree/</guid>
      <description>leetcode
Problem Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: - The left subtree of a node contains only nodes with keys less than the node&amp;#39;s key. - The right subtree of a node contains only nodes with keys greater than the node&amp;#39;s key. - Both the left and right subtrees must also be binary search trees. Example 1: 2 / \ 1 3 Input: [2,1,3] Output: true Example 2: 5 / \ 1 4 / \ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node&amp;#39;s value is 5 but its right child&amp;#39;s value is 4.</description>
    </item>
    
    <item>
      <title>128 - Longest Consecutive Sequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</link>
      <pubDate>Sat, 02 May 2020 16:34:20 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</guid>
      <description>leetcode
Problem Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution Solution 1: Hash Map For each value, we maintain the left bound and right bound of range and also update the bounds for left value and right value.</description>
    </item>
    
    <item>
      <title>106 - Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Sat, 02 May 2020 00:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>leetcode
Problem Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution The problem is almost the same as 105 Construct BT from Preorder and Inorder. Notes can be found there.
class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&amp;gt; TreeNode: if inorder: node = TreeNode(postorder.</description>
    </item>
    
    <item>
      <title>278 - First Bad Version</title>
      <link>//alfmunny.com/leetcode-blog/posts/278-first-bad-version/</link>
      <pubDate>Fri, 01 May 2020 22:00:09 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/278-first-bad-version/</guid>
      <description>leetcode
Problem You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
    <item>
      <title>124 - Binary Tree Maximum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</link>
      <pubDate>Wed, 29 Apr 2020 16:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</guid>
      <description>leetcode
Problem Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3]
1 / \
2 3
Output: 6 Example 2:
Input: [-10,9,20,null,null,15,7]</description>
    </item>
    
    <item>
      <title>448 - Find All Numbers Disappeard in an Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/448-find-all-numbers-disappeard-in-an-array/</link>
      <pubDate>Tue, 28 Apr 2020 17:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/448-find-all-numbers-disappeard-in-an-array/</guid>
      <description>leetcode
Problem Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
Example:
Input: [4,3,2,7,8,2,3,1]
Output: [5,6]
Solution Move all the numbers to its position.</description>
    </item>
    
    <item>
      <title>169 - Majority Element</title>
      <link>//alfmunny.com/leetcode-blog/posts/169-majority-element/</link>
      <pubDate>Tue, 28 Apr 2020 16:22:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/169-majority-element/</guid>
      <description>leetcode
Problem Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
Example 1:
Input: [3,2,3] Output: 3
Example 2:
Input: [2,2,1,1,1,2,2] Output: 2
Solution Solution 1: Hash Table from collections import Counter class Solution: def majorityElement(self, nums): c = Counter() l = len(nums) for n in nums: c[n] += 1 if c[n] &amp;gt; l/2: return n print(Solution().</description>
    </item>
    
    <item>
      <title>146 - LRU Cache</title>
      <link>//alfmunny.com/leetcode-blog/posts/146-lru-cache/</link>
      <pubDate>Sat, 25 Apr 2020 00:17:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/146-lru-cache/</guid>
      <description>leetcode
Problem Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>Leftmost Column with at Least a One</title>
      <link>//alfmunny.com/leetcode-blog/posts/leftmost-column-with-at-least-a-one/</link>
      <pubDate>Wed, 22 Apr 2020 01:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/leftmost-column-with-at-least-a-one/</guid>
      <description>leetcode
Problem A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn&amp;#39;t exist, return -1. You can&amp;#39;t access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface: BinaryMatrix.get(x, y) returns the element of the matrix at index (x, y) (0-indexed).</description>
    </item>
    
    <item>
      <title>46 - Permutations</title>
      <link>//alfmunny.com/leetcode-blog/posts/46-permutations/</link>
      <pubDate>Sun, 19 Apr 2020 02:11:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/46-permutations/</guid>
      <description>leetcode
Problem Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] Solution Solution 1 class Solution: def permute(self, nums): ans = [] self.backtrack([], nums, ans) return ans def backtrack(self, path, nums, ans): if not nums: ans.append(path[:]) return for i, v in enumerate(nums): self.backtrack(path+[v], nums[:i]+nums[i+1:], ans) Solution 2 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: ans = [] marked = [False] * len(nums) self.</description>
    </item>
    
    <item>
      <title>200 - Number of Islands</title>
      <link>//alfmunny.com/leetcode-blog/posts/200-numebr-of-islands/</link>
      <pubDate>Fri, 17 Apr 2020 17:01:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/200-numebr-of-islands/</guid>
      <description>leetcode
Problem Given a 2d grid map of &amp;#39;1&amp;#39;s (land) and &amp;#39;0&amp;#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3 Solution DFS problem. Straight forward.</description>
    </item>
    
    <item>
      <title>Perform String Shifts</title>
      <link>//alfmunny.com/leetcode-blog/posts/perform-string-shifts/</link>
      <pubDate>Wed, 15 Apr 2020 00:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/perform-string-shifts/</guid>
      <description>leetcode
Problem You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [direction, amount]: direction can be 0 (for left shift) or 1 (for right shift). amount is the amount by which string s is to be shifted. A left shift by 1 means remove the first character of s and append it to the end. Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.</description>
    </item>
    
    <item>
      <title>1046 - Last Stone Weight</title>
      <link>//alfmunny.com/leetcode-blog/posts/1046-last-stone-weight/</link>
      <pubDate>Mon, 13 Apr 2020 01:46:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1046-last-stone-weight/</guid>
      <description>leetcode
Problem We have a collection of stones, each stone has a positive integer weight. Each turn, we choose the two heaviest stones and smash them together. Suppose the stones have weights x and y with x &amp;lt;= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.</description>
    </item>
    
    <item>
      <title>543 - Diameter of Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/543-diameter-of-binary-tree/</link>
      <pubDate>Sat, 11 Apr 2020 23:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/543-diameter-of-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example: Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    
    <item>
      <title>155 - Min Stack</title>
      <link>//alfmunny.com/leetcode-blog/posts/155-min-stack/</link>
      <pubDate>Fri, 10 Apr 2020 20:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/155-min-stack/</guid>
      <description>leetcode
Problem Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.pop(); minStack.top(); --&amp;gt; Returns 0. minStack.getMin(); --&amp;gt; Returns -2.</description>
    </item>
    
    <item>
      <title>844 - Backspace String Compare</title>
      <link>//alfmunny.com/leetcode-blog/posts/844-backspace-string-compare/</link>
      <pubDate>Thu, 09 Apr 2020 22:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/844-backspace-string-compare/</guid>
      <description>leetcode
Problem Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character. Example 1: Input: S = &amp;#34;ab#c&amp;#34;, T = &amp;#34;ad#c&amp;#34; Output: true Explanation: Both S and T become &amp;#34;ac&amp;#34;. Example 2: Input: S = &amp;#34;ab##&amp;#34;, T = &amp;#34;c#d#&amp;#34; Output: true Explanation: Both S and T become &amp;#34;&amp;#34;. Example 3: Input: S = &amp;#34;a##c&amp;#34;, T = &amp;#34;#a#c&amp;#34; Output: true Explanation: Both S and T become &amp;#34;c&amp;#34;.</description>
    </item>
    
    <item>
      <title>876 - Middle of the Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/876-middle-of-the-linked-list/</link>
      <pubDate>Wed, 08 Apr 2020 11:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/876-middle-of-the-linked-list/</guid>
      <description>leetcode
Problem Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge&amp;#39;s serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.</description>
    </item>
    
    <item>
      <title>215 - Kth Largest Element in an Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/215-kth-largest-element-in-an-array/</link>
      <pubDate>Mon, 06 Apr 2020 01:05:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/215-kth-largest-element-in-an-array/</guid>
      <description>leetcode
Problem 215. Kth Largest Element in an Array Medium 3152 222 Add to List Share Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note: You may assume k is always valid, 1 ≤ k ≤ array&amp;#39;s length.</description>
    </item>
    
    <item>
      <title>416 - Partition Equal Subset Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</link>
      <pubDate>Sun, 05 Apr 2020 21:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</guid>
      <description>leetcode
Problem Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets.</description>
    </item>
    
    <item>
      <title>283 - Move Zeros</title>
      <link>//alfmunny.com/leetcode-blog/posts/283-move-zeros/</link>
      <pubDate>Sat, 04 Apr 2020 17:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/283-move-zeros/</guid>
      <description>leetcode
Problem Given an array nums, write a function to move all 0&amp;#39;s to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Solution Two pointers.
One pointer is for the start of 0.
One pointer keeps going forward.
class Solution: def moveZeros(self, nums): p1, p2 = 0, 0 for p2 &amp;lt; len(nums): if nums[p1] !</description>
    </item>
    
    <item>
      <title>202 - Happy Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/202-happy-number/</link>
      <pubDate>Thu, 02 Apr 2020 16:03:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/202-happy-number/</guid>
      <description>leetcode
Problem Write an algorithm to determine if a number is &amp;#34;happy&amp;#34;. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>136 - Single Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/136-single-number/</link>
      <pubDate>Wed, 01 Apr 2020 22:36:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/136-single-number/</guid>
      <description>leetcode
Problem Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 Notes Solution 1: Hash Table Solution 2: Bit manipulation Consider XOR all element together. The left number is the single number.
Solution Solution 1: Hash Table class Solution: def singleNumber(self, nums): table = {} for i in nums: table[i] = table.</description>
    </item>
    
    <item>
      <title>5 - Longest Palindromic Substring</title>
      <link>//alfmunny.com/leetcode-blog/posts/5-longest-palindromic-substring/</link>
      <pubDate>Tue, 31 Mar 2020 23:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/5-longest-palindromic-substring/</guid>
      <description>leetcode
Problem Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: &amp;#34;babad&amp;#34; Output: &amp;#34;bab&amp;#34; Note: &amp;#34;aba&amp;#34; is also a valid answer. Example 2: Input: &amp;#34;cbbd&amp;#34; Output: &amp;#34;bb&amp;#34; Notes DP problem
  States:
left_index, right_index, mark if s[left_index, right_index+1] is palindromic
  Transition:
if s[l] == s[r]: # mark it only when both ends are same values dp[l][r] = 1 if r == l # if only one element dp[l][r] = 1 if r+1 == l # if only two elements dp[l][r] = 1 if dp[l+1][r+1] = 1 # if the string in between is palindromic results = s[l:r+1] if r-l+1&amp;gt;len(results) # comparing the length, record the maximum   Base case:</description>
    </item>
    
    <item>
      <title>221 - Maximal Square</title>
      <link>//alfmunny.com/leetcode-blog/posts/221-maximal-square/</link>
      <pubDate>Mon, 30 Mar 2020 20:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/221-maximal-square/</guid>
      <description>leetcode
Problem Given a 2D binary matrix filled with 0&amp;#39;s and 1&amp;#39;s, find the largest square containing only 1&amp;#39;s and return its area. Example: Input: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4 Notes DP Problem:
  States:
 position -&amp;gt; [i][j] how many continues 1 in vertical direction -&amp;gt; [i][j][0] how many continues 1 in horizontal direction -&amp;gt; [i][j][1] square value(or the length of the square) -&amp;gt; [i][j][2]  dp[i][j][0 or 1 or 2]</description>
    </item>
    
    <item>
      <title>96 - Unique Binary Search Trees</title>
      <link>//alfmunny.com/leetcode-blog/posts/96-unique-binary-search-trees/</link>
      <pubDate>Mon, 30 Mar 2020 15:17:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/96-unique-binary-search-trees/</guid>
      <description>leetcode
Problem Given n, how many structurally unique BST&amp;#39;s (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST&amp;#39;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 Notes Solution 1: DP In this dp problem, the hard part is to figure out the transition.</description>
    </item>
    
    <item>
      <title>198 - House Robber</title>
      <link>//alfmunny.com/leetcode-blog/posts/198-house-robber/</link>
      <pubDate>Fri, 27 Mar 2020 23:58:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/198-house-robber/</guid>
      <description>leetcode
Problem You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>101 - Symmetric Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/101-symmetric-tree/</link>
      <pubDate>Wed, 25 Mar 2020 21:02:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/101-symmetric-tree/</guid>
      <description>leetcode
Problem Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Notes Recursion !
Solution Solution 1: recursive class Solution: def isSymmetric(self, root): if not root: return True return self.</description>
    </item>
    
    <item>
      <title>21 - Merge Two Sorted Lists</title>
      <link>//alfmunny.com/leetcode-blog/posts/21-merge-two-sorted-lists/</link>
      <pubDate>Wed, 25 Mar 2020 19:55:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/21-merge-two-sorted-lists/</guid>
      <description>leetcode
Problem Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 Notes Recursion is your friend!
Solution Solution 1: Recursive class Solution: def mergeTwoLists(self, l1, l2): if not l1: return l2 if not l2: return l1 if l1.val &amp;gt; l2.val: l2.next = self.mergeTwoLists(l1, l2.next) return l2 else: l1.</description>
    </item>
    
    <item>
      <title>104 - Maximum Depth of Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Wed, 25 Mar 2020 17:16:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/104-maximum-depth-of-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 Notes Recursion is your friend!
Solution class Solution: def maxDepth(self, root): return 1 + max(self.maxDepth(root.right), self.</description>
    </item>
    
    <item>
      <title>122 - Best Time to Buy and Sell Stock II</title>
      <link>//alfmunny.com/leetcode-blog/posts/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Tue, 24 Mar 2020 15:26:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</description>
    </item>
    
    <item>
      <title>121 - Best Time to Buy and Sell Stock</title>
      <link>//alfmunny.com/leetcode-blog/posts/121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Tue, 24 Mar 2020 12:13:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/121-best-time-to-buy-and-sell-stock/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
  </channel>
</rss>