<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tree on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/tree/</link>
    <description>Recent content in tree on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Dec 2020 13:05:00 +0100</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>701 - Insert into a Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/701-insert-into-a-binary-search-tree/</link>
      <pubDate>Mon, 14 Dec 2020 13:05:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/701-insert-into-a-binary-search-tree/</guid>
      <description>leetcode
Problem You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</description>
    </item>
    
    <item>
      <title>235 - Lowest Common Ancestor of a Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/235-lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Mon, 14 Dec 2020 12:50:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/235-lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>leetcode
Problem Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.</description>
    </item>
    
    <item>
      <title>116 - Populating Next Right Pointers in Each Node</title>
      <link>//alfmunny.com/leetcode-blog/posts/116-populating-next-right-pointers-in-each-node/</link>
      <pubDate>Mon, 23 Nov 2020 22:18:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/116-populating-next-right-pointers-in-each-node/</guid>
      <description>leetcode
Problem You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL.</description>
    </item>
    
    <item>
      <title>257 - Binary Tree Paths</title>
      <link>//alfmunny.com/leetcode-blog/posts/257-binary-tree-paths/</link>
      <pubDate>Sun, 22 Nov 2020 16:42:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/257-binary-tree-paths/</guid>
      <description>leetcode
Problem iven a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input: 1 / \ 2 3 \ 5 Output: [&amp;#34;1-&amp;gt;2-&amp;gt;5&amp;#34;, &amp;#34;1-&amp;gt;3&amp;#34;] Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3 Solution class Solution: def binaryTreePaths(self, root: TreeNode) -&amp;gt; List[str]: if not root: return [] if not root.right and not root.left: return [str(root.val)] paths = [str(root.val) + &amp;#34;-&amp;gt;&amp;#34; + s for s in self.</description>
    </item>
    
    <item>
      <title>450 - Delete Node in a BST</title>
      <link>//alfmunny.com/leetcode-blog/posts/450-delete-node-in-a-bst/</link>
      <pubDate>Mon, 31 Aug 2020 23:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/450-delete-node-in-a-bst/</guid>
      <description>leetcode
Problem Design an Iterator class, which has: A constructor that takes a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments. A function next() that returns the next combination of length combinationLength in lexicographical order. A function hasNext() that returns True if and only if there exists a next combination. Example: CombinationIterator iterator = new CombinationIterator(&amp;#34;abc&amp;#34;, 2); // creates the iterator. iterator.next(); // returns &amp;#34;ab&amp;#34; iterator.</description>
    </item>
    
    <item>
      <title>404 - Sum of Left Leaves</title>
      <link>//alfmunny.com/leetcode-blog/posts/404-sum-of-left-leaves/</link>
      <pubDate>Mon, 24 Aug 2020 22:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/404-sum-of-left-leaves/</guid>
      <description>leetcode
Problem Find the sum of all left leaves in a given binary tree. Example: 3 / \ 9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. Solution class Solution: def sumOfLeftLeaves(self, root: TreeNode) -&amp;gt; int: return self.dfs(root, 0, False) def dfs(self, root, presum, isLeft): if not root: return 0 if not root.left and not root.right and isLeft: return presum + root.</description>
    </item>
    
    <item>
      <title>199 - Binary Tree Right Side View</title>
      <link>//alfmunny.com/leetcode-blog/posts/199-binary-tree-right-side-view/</link>
      <pubDate>Sun, 23 Aug 2020 17:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/199-binary-tree-right-side-view/</guid>
      <description>leetcode
Problem Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- Solution Comprare the depth. DFS.
Keep track of the current depth. And the length of current answer is the previous depth.</description>
    </item>
    
    <item>
      <title>114 - Flatten Binary Tree to Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/114-flatten-binary-tree-to-linked-list/</link>
      <pubDate>Wed, 19 Aug 2020 14:55:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/114-flatten-binary-tree-to-linked-list/</guid>
      <description>leetcode
Problem Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 Solution  Traverse the tree in reverse preorder, the opposite of root-left-right. Save the root, and use it in the upper level.  class Solution: def flatten(self, root: TreeNode) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34;Do not return anything, modify root in-place instead.</description>
    </item>
    
    <item>
      <title>110 - Balanced Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/110-balanced-binary-tree/</link>
      <pubDate>Wed, 19 Aug 2020 11:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/110-balanced-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \ 9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \ 2 2 / \ 3 3 / \ 4 4 Return false.</description>
    </item>
    
    <item>
      <title>107 - Binary Tree Level Order Traversal II</title>
      <link>//alfmunny.com/leetcode-blog/posts/107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Fri, 03 Jul 2020 22:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/107-binary-tree-level-order-traversal-ii/</guid>
      <description>leetcode
Problem Given a binary tree, return the bottom-up level order traversal of its nodes&amp;#39; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Solution class Solution: def levelOrderBottom(self, root: TreeNode) -&amp;gt; List[List[int]]: if not root: return [] queue = [root] stack = [] while queue: next_queue = [] tmp = [] while queue: n = queue.</description>
    </item>
    
    <item>
      <title>988 - Smallest String Starting From Leaf</title>
      <link>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</link>
      <pubDate>Sat, 27 Jun 2020 15:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</guid>
      <description>leetcode
Problem Given the root of a binary tree, each node has a value from 0 to 25 representing the letters &amp;#39;a&amp;#39; to &amp;#39;z&amp;#39;: a value of 0 represents &amp;#39;a&amp;#39;, a value of 1 represents &amp;#39;b&amp;#39;, and so on. Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root. (As a reminder, any shorter prefix of a string is lexicographically smaller: for example, &amp;#34;ab&amp;#34; is lexicographically smaller than &amp;#34;aba&amp;#34;.</description>
    </item>
    
    <item>
      <title>95 - Unique Binary Search Trees II</title>
      <link>//alfmunny.com/leetcode-blog/posts/95-unique-binary-search-treea-ii/</link>
      <pubDate>Sat, 20 Jun 2020 02:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/95-unique-binary-search-treea-ii/</guid>
      <description>leetcode
Problem Given an integer n, generate all structurally unique BST&amp;#39;s (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST&amp;#39;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 Solution class Solution: def generateTrees(self, n: int) -&amp;gt; List[TreeNode]: if n == 0: return [] return self.</description>
    </item>
    
    <item>
      <title>113 - Path Sum II</title>
      <link>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</link>
      <pubDate>Wed, 17 Jun 2020 23:51:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</guid>
      <description>leetcode
Problem Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;#39;s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] Solution class Solution: def pathSum(self, root: TreeNode, sum: int) -&amp;gt; List[List[int]]: ans = [] self.</description>
    </item>
    
    <item>
      <title>112 - Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/112-path-sum/</link>
      <pubDate>Wed, 17 Jun 2020 23:50:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/112-path-sum/</guid>
      <description>leetcode
Problem Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>100 - Same Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/100-same-tree/</link>
      <pubDate>Wed, 17 Jun 2020 23:48:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/100-same-tree/</guid>
      <description>leetcode
Problem Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false Solution class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&amp;gt; bool: if p and not q: return False if not p and q: return False if not p and not q: return True if p.</description>
    </item>
    
    <item>
      <title>226 - Invert Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/226-invert-binary-tree/</link>
      <pubDate>Mon, 01 Jun 2020 23:36:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/226-invert-binary-tree/</guid>
      <description>leetcode
Problem Invert a binary tree. Example: Input: 4 / \ 2 7 / \ / \ 1 3 6 9 Output: 4 / \ 7 2 / \ / \ 9 6 3 1 Solution class Solution: def invertTree(self): if root: tmp = root.left root.left = self.invertTree(root.right) root.right = self.invertTree(tmp) return root </description>
    </item>
    
    <item>
      <title>230 - Kth Smallest Element in a BST</title>
      <link>//alfmunny.com/leetcode-blog/posts/230-kth-smallest-element-in-a-bst/</link>
      <pubDate>Wed, 20 May 2020 22:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/230-kth-smallest-element-in-a-bst/</guid>
      <description>leetcode
Problem 230. Kth Smallest Element in a BST Medium 2239 57 Add to List Share Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 ≤ k ≤ BST&amp;#39;s total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 Output: 3 Solution class Solution: def kthSmallest(self, root): self.</description>
    </item>
    
    <item>
      <title>Cousins in Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/counsins-in-binary-tree/</link>
      <pubDate>Thu, 07 May 2020 21:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/counsins-in-binary-tree/</guid>
      <description>leetcode
Problem In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins.</description>
    </item>
    
    <item>
      <title>337 - House Robber III</title>
      <link>//alfmunny.com/leetcode-blog/posts/337-house-robber-ii/</link>
      <pubDate>Wed, 06 May 2020 17:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/337-house-robber-ii/</guid>
      <description>leetcode
Problem The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;#34;root.&amp;#34; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;#34;all houses in this place forms a binary tree&amp;#34;. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description>
    </item>
    
    <item>
      <title>98 - Validate Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/98-validate-binary-search-tree/</link>
      <pubDate>Sat, 02 May 2020 17:19:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/98-validate-binary-search-tree/</guid>
      <description>leetcode
Problem Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: - The left subtree of a node contains only nodes with keys less than the node&amp;#39;s key. - The right subtree of a node contains only nodes with keys greater than the node&amp;#39;s key. - Both the left and right subtrees must also be binary search trees. Example 1: 2 / \ 1 3 Input: [2,1,3] Output: true Example 2: 5 / \ 1 4 / \ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node&amp;#39;s value is 5 but its right child&amp;#39;s value is 4.</description>
    </item>
    
    <item>
      <title>106 - Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Sat, 02 May 2020 00:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>leetcode
Problem Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution The problem is almost the same as 105 Construct BT from Preorder and Inorder. Notes can be found there.
class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&amp;gt; TreeNode: if inorder: node = TreeNode(postorder.</description>
    </item>
    
    <item>
      <title>105 - Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Sat, 02 May 2020 00:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>leetcode
Problem Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution  The first node of the preorder is always the root. Find the root in the inorder array, split it there.</description>
    </item>
    
    <item>
      <title>124 - Binary Tree Maximum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</link>
      <pubDate>Wed, 29 Apr 2020 16:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</guid>
      <description>leetcode
Problem Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3]
1 / \
2 3
Output: 6 Example 2:
Input: [-10,9,20,null,null,15,7]</description>
    </item>
    
    <item>
      <title>437 - Path Sum III</title>
      <link>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</link>
      <pubDate>Sun, 26 Apr 2020 15:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</guid>
      <description>leetcode
Problem You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</description>
    </item>
    
    <item>
      <title>543 - Diameter of Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/543-diameter-of-binary-tree/</link>
      <pubDate>Sat, 11 Apr 2020 23:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/543-diameter-of-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example: Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    
    <item>
      <title>96 - Unique Binary Search Trees</title>
      <link>//alfmunny.com/leetcode-blog/posts/96-unique-binary-search-trees/</link>
      <pubDate>Mon, 30 Mar 2020 15:17:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/96-unique-binary-search-trees/</guid>
      <description>leetcode
Problem Given n, how many structurally unique BST&amp;#39;s (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST&amp;#39;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 Notes Solution 1: DP In this dp problem, the hard part is to figure out the transition.</description>
    </item>
    
    <item>
      <title>101 - Symmetric Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/101-symmetric-tree/</link>
      <pubDate>Wed, 25 Mar 2020 21:02:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/101-symmetric-tree/</guid>
      <description>leetcode
Problem Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Notes Recursion !
Solution Solution 1: recursive class Solution: def isSymmetric(self, root): if not root: return True return self.</description>
    </item>
    
    <item>
      <title>104 - Maximum Depth of Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Wed, 25 Mar 2020 17:16:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/104-maximum-depth-of-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 Notes Recursion is your friend!
Solution class Solution: def maxDepth(self, root): return 1 + max(self.maxDepth(root.right), self.</description>
    </item>
    
  </channel>
</rss>