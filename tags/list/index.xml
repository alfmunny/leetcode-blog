<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>list on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/list/</link>
    <description>Recent content in list on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Aug 2020 01:13:00 +0200</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/list/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>142 - Reorder List</title>
      <link>//alfmunny.com/leetcode-blog/posts/142-reorder-list/</link>
      <pubDate>Tue, 18 Aug 2020 01:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/142-reorder-list/</guid>
      <description>leetcode
Problem Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list&amp;#39;s nodes, only nodes itself may be changed. Example 1: Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, reorder it to 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. Example 2: Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, reorder it to 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3. Solution class Solution: def reorderList(self, head: ListNode) -&amp;gt; None: if not head or not head.next: return fast = slow = head while fast.next and fast.next.next: fast = fast.</description>
    </item>
    
    <item>
      <title>148 - Sort List</title>
      <link>//alfmunny.com/leetcode-blog/posts/148-sort-list/</link>
      <pubDate>Mon, 17 Aug 2020 16:41:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/148-sort-list/</guid>
      <description>leetcode
Problem Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4 Example 2: Input: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0 Output: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5 Solution Merge Sort
 Slow-Fast-Pointer to split the list into half. Do not forget slow.next = None Sort two part recursively and merge together  class Solution: def sortList(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head # split in half fast = slow = head while fast.</description>
    </item>
    
    <item>
      <title>83 - Remove Duplicates from Sorted List</title>
      <link>//alfmunny.com/leetcode-blog/posts/83-remove-duplicates-from-sorted-list/</link>
      <pubDate>Sat, 20 Jun 2020 01:42:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/83-remove-duplicates-from-sorted-list/</guid>
      <description>leetcode
Problem Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2 Example 2: Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3 Solution class Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head first = head second = first.next while second: if first.val == second.val: first.next = second.next second = first.next else: first, second = second, second.next return head </description>
    </item>
    
    <item>
      <title>61 - Rotate List</title>
      <link>//alfmunny.com/leetcode-blog/posts/61-rotate-list/</link>
      <pubDate>Thu, 18 Jun 2020 14:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/61-rotate-list/</guid>
      <description>leetcode
Problem Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 Output: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Explanation: rotate 1 steps to the right: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL rotate 2 steps to the right: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Example 2: Input: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL, k = 4 Output: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Explanation: rotate 1 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL rotate 2 steps to the right: 1-&amp;gt;2-&amp;gt;0-&amp;gt;NULL rotate 3 steps to the right: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL rotate 4 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Solution Note: k may be larger than the total count of nodes.</description>
    </item>
    
    <item>
      <title>237 - Delete Node in a Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/237-delete-node-in-a-linked-list/</link>
      <pubDate>Wed, 03 Jun 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/237-delete-node-in-a-linked-list/</guid>
      <description>leetcode
Problem Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following: Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&amp;gt; 1 -&amp;gt; 9 after calling your function. Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -&amp;gt; 5 -&amp;gt; 9 after calling your function.</description>
    </item>
    
    <item>
      <title>328 - Odd Even Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/328-odd-even-linked-list/</link>
      <pubDate>Sat, 16 May 2020 17:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/328-odd-even-linked-list/</guid>
      <description>leetcode
Problem Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL Example 2: Input: 2-&amp;gt;1-&amp;gt;3-&amp;gt;5-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;NULL Output: 2-&amp;gt;3-&amp;gt;6-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;4-&amp;gt;NULL Note: The relative order inside both the even and odd groups should remain as it was in the input.</description>
    </item>
    
    <item>
      <title>146 - LRU Cache</title>
      <link>//alfmunny.com/leetcode-blog/posts/146-lru-cache/</link>
      <pubDate>Sat, 25 Apr 2020 00:17:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/146-lru-cache/</guid>
      <description>leetcode
Problem Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>21 - Merge Two Sorted Lists</title>
      <link>//alfmunny.com/leetcode-blog/posts/21-merge-two-sorted-lists/</link>
      <pubDate>Wed, 25 Mar 2020 19:55:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/21-merge-two-sorted-lists/</guid>
      <description>leetcode
Problem Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 Notes Recursion is your friend!
Solution Solution 1: Recursive class Solution: def mergeTwoLists(self, l1, l2): if not l1: return l2 if not l2: return l1 if l1.val &amp;gt; l2.val: l2.next = self.mergeTwoLists(l1, l2.next) return l2 else: l1.</description>
    </item>
    
  </channel>
</rss>