<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bs on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/bs/</link>
    <description>Recent content in bs on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 19 Nov 2020 15:55:00 +0100</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/bs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>378 - Kth Smallest Element in a Sorted Matrix</title>
      <link>//alfmunny.com/leetcode-blog/posts/378-kth-smallest-element-in-a-sorted-matrix/</link>
      <pubDate>Thu, 19 Nov 2020 15:55:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/378-kth-smallest-element-in-a-sorted-matrix/</guid>
      <description>leetcode
Problem Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example: matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, return 13. Solution Solution 1: Heap with marker Maintain a heap, pop the first one, and push the right one and lower one into the heap.</description>
    </item>
    
    <item>
      <title>436 - Find Right Interval</title>
      <link>//alfmunny.com/leetcode-blog/posts/436-find-right-interval/</link>
      <pubDate>Thu, 27 Aug 2020 12:31:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/436-find-right-interval/</guid>
      <description>leetcode
Problem Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the &amp;#34;right&amp;#34; of i. For any interval i, you need to store the minimum interval j&amp;#39;s index, which means that the interval j has the minimum start point to build the &amp;#34;right&amp;#34; relationship for interval i.</description>
    </item>
    
    <item>
      <title>81 - Search in Rotated Sorted Array II</title>
      <link>//alfmunny.com/leetcode-blog/posts/81-search-in-rotated-sorted-array-ii/</link>
      <pubDate>Thu, 13 Aug 2020 23:48:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/81-search-in-rotated-sorted-array-ii/</guid>
      <description>leetcode
Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.</description>
    </item>
    
    <item>
      <title>162 - Find Peak Element</title>
      <link>//alfmunny.com/leetcode-blog/posts/162-find-peak-element/</link>
      <pubDate>Thu, 18 Jun 2020 16:09:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/162-find-peak-element/</guid>
      <description>leetcode
Problem A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
    
    <item>
      <title>74 - Search a 2D Matrix</title>
      <link>//alfmunny.com/leetcode-blog/posts/74-search-a-2d-matrix/</link>
      <pubDate>Thu, 18 Jun 2020 14:46:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/74-search-a-2d-matrix/</guid>
      <description>leetcode
Problem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false Solution class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: if not matrix or not matrix[0]: return False rl, rr = 0, len(matrix) - 1 cl, cr = 0, len(matrix[0]) - 1 while rl &amp;lt;= rr: mid = (rl + rr) // 2 if target &amp;lt; matrix[mid][0]: rr = mid - 1 elif target &amp;gt; matrix[mid][-1]: rl = mid + 1 else: rl = mid break if rl &amp;gt; rr: return False while cl &amp;lt;= cr: mid = (cl + cr) // 2 if target &amp;lt; matrix[rl][mid]: cr = mid - 1 elif target &amp;gt; matrix[rl][mid]: cl = mid + 1 else: return True return False </description>
    </item>
    
    <item>
      <title>540 - Single Element in a Sorted Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/540-single-element-in-a-sorted-array/</link>
      <pubDate>Tue, 12 May 2020 18:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/540-single-element-in-a-sorted-array/</guid>
      <description>leetcode
Problem  You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.
Example 1:
Input: [1,1,2,3,3,4,4,8,8] Output: 2
Example 2:
Input: [3,3,7,7,10,11,11] Output: 10
 Solution class Solution: def singleNonDuplicate(self, nums): lo = 0 hi = len(nums) - 1 while lo &amp;lt; hi: mid = (lo + hi) // 2 if mid == 0: return mid if (mid - lo + 1) % 2 == 0: if nums[mid] == nums[mid - 1]: lo = mid + 1 else: hi = mid - 1 else: if nums[mid] == nums[mid - 1]: hi = mid - 2 else: lo = mid return nums[lo] print(Solution().</description>
    </item>
    
    <item>
      <title>887 - Super Egg Drop</title>
      <link>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</link>
      <pubDate>Sun, 03 May 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</guid>
      <description>leetcode
Problem You are given K eggs, and you have access to a building with N floors from 1 to N. Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.</description>
    </item>
    
    <item>
      <title>278 - First Bad Version</title>
      <link>//alfmunny.com/leetcode-blog/posts/278-first-bad-version/</link>
      <pubDate>Fri, 01 May 2020 22:00:09 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/278-first-bad-version/</guid>
      <description>leetcode
Problem You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
  </channel>
</rss>