<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dfs on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/dfs/</link>
    <description>Recent content in dfs on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 01 Jul 2020 00:49:00 +0200</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>212 - Word Search II</title>
      <link>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</link>
      <pubDate>Wed, 01 Jul 2020 00:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</guid>
      <description>leetcode
Problem Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input: board = [ [&amp;#39;o&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;n&amp;#39;], [&amp;#39;e&amp;#39;,&amp;#39;t&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;e&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;h&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;r&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;v&amp;#39;] ] words = [&amp;#34;oath&amp;#34;,&amp;#34;pea&amp;#34;,&amp;#34;eat&amp;#34;,&amp;#34;rain&amp;#34;] Output: [&amp;#34;eat&amp;#34;,&amp;#34;oath&amp;#34;] Note: All inputs are consist of lowercase letters a-z.</description>
    </item>
    
    <item>
      <title>332 - Reconstruct Itinerary</title>
      <link>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinerary/</link>
      <pubDate>Mon, 29 Jun 2020 23:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinerary/</guid>
      <description>leetcode
Problem Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&amp;#34;JFK&amp;#34;, &amp;#34;LGA&amp;#34;] has a smaller lexical order than [&amp;#34;JFK&amp;#34;, &amp;#34;LGB&amp;#34;].</description>
    </item>
    
    <item>
      <title>332 - Reconstruct Itinrary</title>
      <link>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinrary/</link>
      <pubDate>Mon, 29 Jun 2020 23:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinrary/</guid>
      <description>leetcode
Problem Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&amp;#34;JFK&amp;#34;, &amp;#34;LGA&amp;#34;] has a smaller lexical order than [&amp;#34;JFK&amp;#34;, &amp;#34;LGB&amp;#34;].</description>
    </item>
    
    <item>
      <title>988 - Smallest String Starting From Leaf</title>
      <link>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</link>
      <pubDate>Sat, 27 Jun 2020 15:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</guid>
      <description>leetcode
Problem Given the root of a binary tree, each node has a value from 0 to 25 representing the letters &amp;#39;a&amp;#39; to &amp;#39;z&amp;#39;: a value of 0 represents &amp;#39;a&amp;#39;, a value of 1 represents &amp;#39;b&amp;#39;, and so on. Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root. (As a reminder, any shorter prefix of a string is lexicographically smaller: for example, &amp;#34;ab&amp;#34; is lexicographically smaller than &amp;#34;aba&amp;#34;.</description>
    </item>
    
    <item>
      <title>130 - Surrounded Regions</title>
      <link>//alfmunny.com/leetcode-blog/posts/130-surrounded-regions/</link>
      <pubDate>Fri, 26 Jun 2020 01:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/130-surrounded-regions/</guid>
      <description>leetcode
Problem Given a 2D board containing &amp;#39;X&amp;#39; and &amp;#39;O&amp;#39; (the letter O), capture all regions surrounded by &amp;#39;X&amp;#39;. A region is captured by flipping all &amp;#39;O&amp;#39;s into &amp;#39;X&amp;#39;s in that surrounded region. Example: X X X X X O O X X X O X X O X X After running your function, the board should be: X X X X X X X X X X X X X O X X Explanation: Surrounded regions shouldn’t be on the border, which means that any &amp;#39;O&amp;#39; on the border of the board are not flipped to &amp;#39;X&amp;#39;.</description>
    </item>
    
    <item>
      <title>113 - Path Sum II</title>
      <link>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</link>
      <pubDate>Wed, 17 Jun 2020 23:51:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</guid>
      <description>leetcode
Problem Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;#39;s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] Solution class Solution: def pathSum(self, root: TreeNode, sum: int) -&amp;gt; List[List[int]]: ans = [] self.</description>
    </item>
    
    <item>
      <title>90 - Subsets II</title>
      <link>//alfmunny.com/leetcode-blog/posts/90-subsets-ii/</link>
      <pubDate>Wed, 17 Jun 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/90-subsets-ii/</guid>
      <description>leetcode
Problem Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] Solution class Solution: def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]: ans = [] marked = [False] * len(nums) self.dfs(sorted(nums), 0, [], ans, marked) return ans def dfs(self, nums, index, path, ans, marked): ans.</description>
    </item>
    
    <item>
      <title>77 - Combinations</title>
      <link>//alfmunny.com/leetcode-blog/posts/77-combinations/</link>
      <pubDate>Fri, 12 Jun 2020 17:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/77-combinations/</guid>
      <description>leetcode
Problem Share Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] Solution class Solution: def combine(self, n: int, k: int) -&amp;gt; List[List[int]]: ans = [] self.dfs(1, n, k, [], ans) return ans def dfs(self, index, n, k, path, ans): if k == 0: ans.</description>
    </item>
    
    <item>
      <title>52 - N-Queens II</title>
      <link>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</link>
      <pubDate>Fri, 12 Jun 2020 17:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Solution class Solution: def totalNQueens(self, n): self.ans = 0 self.dfs(0, n, []) return self.ans def dfs(self, row, n, path): if row == n and len(path) == n: self.ans += 1 for i in range(n): if self.</description>
    </item>
    
    <item>
      <title>51 - N-Queens</title>
      <link>//alfmunny.com/leetcode-blog/posts/51-n-queens/</link>
      <pubDate>Fri, 12 Jun 2020 17:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/51-n-queens/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens&amp;#39; placement, where &amp;#39;Q&amp;#39; and &amp;#39;.&amp;#39; both indicate a queen and an empty space respectively. Solution class Solution: def solveNQueens(self, n): ans = [] self.dfs(0, n, [], ans) return ans def dfs(self, row, n, path, ans): if row == n and len(path) == n: ans.</description>
    </item>
    
    <item>
      <title>39 Combination Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/39-combination-sum/</link>
      <pubDate>Wed, 10 Jun 2020 23:55:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/39-combination-sum/</guid>
      <description>leetcode
Problem Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] Solution Backtracking problem.</description>
    </item>
    
    <item>
      <title>40 - Combination Sum II</title>
      <link>//alfmunny.com/leetcode-blog/posts/40-combination-sum-ii/</link>
      <pubDate>Wed, 10 Jun 2020 23:33:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/40-combination-sum-ii/</guid>
      <description>leetcode
Problem Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ] Solution Backtracking problem.</description>
    </item>
    
    <item>
      <title>207 - Course Schedule</title>
      <link>//alfmunny.com/leetcode-blog/posts/207-course-schedule/</link>
      <pubDate>Fri, 29 May 2020 19:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/207-course-schedule/</guid>
      <description>leetcode
Problem There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take.</description>
    </item>
    
    <item>
      <title>124 - Binary Tree Maximum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</link>
      <pubDate>Wed, 29 Apr 2020 16:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</guid>
      <description>leetcode
Problem Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3]
1 / \
2 3
Output: 6 Example 2:
Input: [-10,9,20,null,null,15,7]</description>
    </item>
    
    <item>
      <title>200 - Number of Islands</title>
      <link>//alfmunny.com/leetcode-blog/posts/200-numebr-of-islands/</link>
      <pubDate>Fri, 17 Apr 2020 17:01:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/200-numebr-of-islands/</guid>
      <description>leetcode
Problem Given a 2d grid map of &amp;#39;1&amp;#39;s (land) and &amp;#39;0&amp;#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3 Solution DFS problem. Straight forward.</description>
    </item>
    
    <item>
      <title>1306 - Jump Game III</title>
      <link>//alfmunny.com/leetcode-blog/posts/1306-jump-game-iii/</link>
      <pubDate>Sun, 22 Mar 2020 20:42:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1306-jump-game-iii/</guid>
      <description>leetcode
Problem Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0. Notice that you can not jump outside of the array at any time. Example 1: Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 index 5 -&amp;gt; index 6 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 2: Input: arr = [4,2,3,0,3,1,2], start = 0 Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 3: Input: arr = [3,0,2,1,2], start = 2 Output: false Explanation: There is no way to reach at index 1 with value 0.</description>
    </item>
    
    <item>
      <title>79 - Word Search</title>
      <link>//alfmunny.com/leetcode-blog/posts/79-word-search/</link>
      <pubDate>Sat, 14 Mar 2020 03:00:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/79-word-search/</guid>
      <description>leetcode
Problem Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;E&amp;#39;], [&amp;#39;S&amp;#39;,&amp;#39;F&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;S&amp;#39;], [&amp;#39;A&amp;#39;,&amp;#39;D&amp;#39;,&amp;#39;E&amp;#39;,&amp;#39;E&amp;#39;] ] Given word = &amp;#34;ABCCED&amp;#34;, return true. Given word = &amp;#34;SEE&amp;#34;, return true. Given word = &amp;#34;ABCB&amp;#34;, return false.</description>
    </item>
    
    <item>
      <title>78 - Subsets</title>
      <link>//alfmunny.com/leetcode-blog/posts/78-subsets/</link>
      <pubDate>Sat, 07 Mar 2020 23:59:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/78-subsets/</guid>
      <description>Problem leetcode
Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Notes Three strategies to solve a subset problem:
Recursion, Backtracking, Bitmask
Recursion Iterative version:
Start from empty array [[]]. Step 1: Take 1 into consideration, and add 1 to existing array [[], [1]] Step 2: Take 2 into consideration, and add 2 to existing array [[], [1], [2], [1, 2]] Step 3: Take 3 into consideration, and add 3 to existing array [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] DFS version:</description>
    </item>
    
  </channel>
</rss>