<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>easy on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/easy/</link>
    <description>Recent content in easy on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 14 Dec 2020 13:05:00 +0100</lastBuildDate><atom:link href="//alfmunny.com/leetcode-blog/tags/easy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>701 - Insert into a Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/701-insert-into-a-binary-search-tree/</link>
      <pubDate>Mon, 14 Dec 2020 13:05:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/701-insert-into-a-binary-search-tree/</guid>
      <description>leetcode
Problem You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</description>
    </item>
    
    <item>
      <title>235 - Lowest Common Ancestor of a Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/235-lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Mon, 14 Dec 2020 12:50:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/235-lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>leetcode
Problem Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.</description>
    </item>
    
    <item>
      <title>1010 - Pairs of Songs With Total Durations Divisible by 60</title>
      <link>//alfmunny.com/leetcode-blog/posts/1010-paris-of-songs-with-total-durations-divisible-by-60/</link>
      <pubDate>Mon, 14 Dec 2020 00:00:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1010-paris-of-songs-with-total-durations-divisible-by-60/</guid>
      <description>leetcode
Problem You are given a list of songs where the ith song has a duration of time[i] seconds. Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &amp;lt; j with (time[i] + time[j]) % 60 == 0. Example 1: Input: time = [30,20,150,100,40] Output: 3 Explanation: Three pairs have a total duration divisible by 60: (time[0] = 30, time[2] = 150): total duration 180 (time[1] = 20, time[3] = 100): total duration 120 (time[1] = 20, time[4] = 40): total duration 60 Example 2: Input: time = [60,60,60] Output: 3 Explanation: All three pairs have a total duration of 120, which is divisible by 60.</description>
    </item>
    
    <item>
      <title>257 - Binary Tree Paths</title>
      <link>//alfmunny.com/leetcode-blog/posts/257-binary-tree-paths/</link>
      <pubDate>Sun, 22 Nov 2020 16:42:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/257-binary-tree-paths/</guid>
      <description>leetcode
Problem iven a binary tree, return all root-to-leaf paths. Note: A leaf is a node with no children. Example: Input: 1 / \ 2 3 \ 5 Output: [&amp;#34;1-&amp;gt;2-&amp;gt;5&amp;#34;, &amp;#34;1-&amp;gt;3&amp;#34;] Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3 Solution class Solution: def binaryTreePaths(self, root: TreeNode) -&amp;gt; List[str]: if not root: return [] if not root.right and not root.left: return [str(root.val)] paths = [str(root.val) + &amp;#34;-&amp;gt;&amp;#34; + s for s in self.</description>
    </item>
    
    <item>
      <title>412 - Fizz Buzz</title>
      <link>//alfmunny.com/leetcode-blog/posts/412-fizz-buzz/</link>
      <pubDate>Wed, 26 Aug 2020 23:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/412-fizz-buzz/</guid>
      <description>leetcode
Problem Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15, Return: [ &amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;Fizz&amp;#34;, &amp;#34;4&amp;#34;, &amp;#34;Buzz&amp;#34;, &amp;#34;Fizz&amp;#34;, &amp;#34;7&amp;#34;, &amp;#34;8&amp;#34;, &amp;#34;Fizz&amp;#34;, &amp;#34;Buzz&amp;#34;, &amp;#34;11&amp;#34;, &amp;#34;Fizz&amp;#34;, &amp;#34;13&amp;#34;, &amp;#34;14&amp;#34;, &amp;#34;FizzBuzz&amp;#34; ] Solution class Solution: def fizzBuzz(self, n: int) -&amp;gt; List[str]: ans = [] for i in range(1, n+1): if not i % 3 and not i % 5: ans.</description>
    </item>
    
    <item>
      <title>404 - Sum of Left Leaves</title>
      <link>//alfmunny.com/leetcode-blog/posts/404-sum-of-left-leaves/</link>
      <pubDate>Mon, 24 Aug 2020 22:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/404-sum-of-left-leaves/</guid>
      <description>leetcode
Problem Find the sum of all left leaves in a given binary tree. Example: 3 / \ 9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. Solution class Solution: def sumOfLeftLeaves(self, root: TreeNode) -&amp;gt; int: return self.dfs(root, 0, False) def dfs(self, root, presum, isLeft): if not root: return 0 if not root.left and not root.right and isLeft: return presum + root.</description>
    </item>
    
    <item>
      <title>824 - Goat Latin</title>
      <link>//alfmunny.com/leetcode-blog/posts/824-goat-latin/</link>
      <pubDate>Wed, 19 Aug 2020 12:31:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/824-goat-latin/</guid>
      <description>leetcode
Problem A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to &amp;#34;Goat Latin&amp;#34; (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append &amp;#34;ma&amp;#34; to the end of the word. For example, the word &amp;#39;apple&amp;#39; becomes &amp;#39;applema&amp;#39;.</description>
    </item>
    
    <item>
      <title>110 - Balanced Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/110-balanced-binary-tree/</link>
      <pubDate>Wed, 19 Aug 2020 11:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/110-balanced-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \ 9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \ 2 2 / \ 3 3 / \ 4 4 Return false.</description>
    </item>
    
    <item>
      <title>1103 - Distribute Candies to People</title>
      <link>//alfmunny.com/leetcode-blog/posts/1103-distribute-candies-to-people/</link>
      <pubDate>Mon, 17 Aug 2020 15:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1103-distribute-candies-to-people/</guid>
      <description>leetcode
Problem We distribute some number of candies, to a row of n = num_people people in the following way: We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.</description>
    </item>
    
    <item>
      <title>461 - Hamming Distance</title>
      <link>//alfmunny.com/leetcode-blog/posts/461-hamming-distance/</link>
      <pubDate>Sat, 18 Jul 2020 00:30:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/461-hamming-distance/</guid>
      <description>leetcode
Problem The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y &amp;lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different.</description>
    </item>
    
    <item>
      <title>190 - Reverse Bits</title>
      <link>//alfmunny.com/leetcode-blog/posts/190-reverse-bits/</link>
      <pubDate>Mon, 13 Jul 2020 00:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/190-reverse-bits/</guid>
      <description>leetcode
Problem Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Note: Note that in some languages such as Java, there is no unsigned integer type.</description>
    </item>
    
    <item>
      <title>463 - Island Perimeter</title>
      <link>//alfmunny.com/leetcode-blog/posts/463-island-perimeter/</link>
      <pubDate>Tue, 07 Jul 2020 16:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/463-island-perimeter/</guid>
      <description>leetcode
Problem You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn&amp;#39;t have &amp;#34;lakes&amp;#34; (water inside that isn&amp;#39;t connected to the water around the island). One cell is a square with side length 1.</description>
    </item>
    
    <item>
      <title>107 - Binary Tree Level Order Traversal II</title>
      <link>//alfmunny.com/leetcode-blog/posts/107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Fri, 03 Jul 2020 22:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/107-binary-tree-level-order-traversal-ii/</guid>
      <description>leetcode
Problem Given a binary tree, return the bottom-up level order traversal of its nodes&amp;#39; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Solution class Solution: def levelOrderBottom(self, root: TreeNode) -&amp;gt; List[List[int]]: if not root: return [] queue = [root] stack = [] while queue: next_queue = [] tmp = [] while queue: n = queue.</description>
    </item>
    
    <item>
      <title>441 - Arranging Coins</title>
      <link>//alfmunny.com/leetcode-blog/posts/441-arranging-coins/</link>
      <pubDate>Wed, 01 Jul 2020 23:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/441-arranging-coins/</guid>
      <description>leetcode
Problem You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5 The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ Because the 3rd row is incomplete, we return 2.</description>
    </item>
    
    <item>
      <title>303 - Range Sum Query - Immutable</title>
      <link>//alfmunny.com/leetcode-blog/posts/303-range-sum-query-immutable/</link>
      <pubDate>Sat, 27 Jun 2020 15:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/303-range-sum-query-immutable/</guid>
      <description>leetcode
Problem Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. Solution class NumArray: def __init__(self, nums: List[int]): self.dp = list(nums) self.</description>
    </item>
    
    <item>
      <title>83 - Remove Duplicates from Sorted List</title>
      <link>//alfmunny.com/leetcode-blog/posts/83-remove-duplicates-from-sorted-list/</link>
      <pubDate>Sat, 20 Jun 2020 01:42:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/83-remove-duplicates-from-sorted-list/</guid>
      <description>leetcode
Problem Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2 Example 2: Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3 Solution class Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head first = head second = first.next while second: if first.val == second.val: first.next = second.next second = first.next else: first, second = second, second.next return head </description>
    </item>
    
    <item>
      <title>118 - Pascal&#39;s Triangle</title>
      <link>//alfmunny.com/leetcode-blog/posts/118-pascals-triangle/</link>
      <pubDate>Wed, 17 Jun 2020 23:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/118-pascals-triangle/</guid>
      <description>leetcode
Problem Given a non-negative integer numRows, generate the first numRows of Pascal&amp;#39;s triangle. Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] Solution class Solution: def generate(self, numRows: int) -&amp;gt; List[List[int]]: ans = [] for i in range(1, numRows+1): level = [1] * i if ans: for j in range(1, i-1): level[j] = ans[-1][j-1] + ans[-1][j] ans.append(level) return ans </description>
    </item>
    
    <item>
      <title>112 - Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/112-path-sum/</link>
      <pubDate>Wed, 17 Jun 2020 23:50:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/112-path-sum/</guid>
      <description>leetcode
Problem Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>100 - Same Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/100-same-tree/</link>
      <pubDate>Wed, 17 Jun 2020 23:48:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/100-same-tree/</guid>
      <description>leetcode
Problem Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false Solution class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&amp;gt; bool: if p and not q: return False if not p and q: return False if not p and not q: return True if p.</description>
    </item>
    
    <item>
      <title>392 - Is Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/392-is-subsequence/</link>
      <pubDate>Tue, 09 Jun 2020 23:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/392-is-subsequence/</guid>
      <description>leetcode
Problem Given a string s and a string t, check if s is subsequence of t. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &amp;#34;ace&amp;#34; is a subsequence of &amp;#34;abcde&amp;#34; while &amp;#34;aec&amp;#34; is not). Follow up: If there are lots of incoming S, say S1, S2, .</description>
    </item>
    
    <item>
      <title>66 - Plus One</title>
      <link>//alfmunny.com/leetcode-blog/posts/66-plus-one/</link>
      <pubDate>Mon, 08 Jun 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/66-plus-one/</guid>
      <description>leetcode
Problem Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title>38 - Count and Say</title>
      <link>//alfmunny.com/leetcode-blog/posts/38-count-and-say/</link>
      <pubDate>Mon, 08 Jun 2020 23:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/38-count-and-say/</guid>
      <description>leetcode
Problem The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as &amp;#34;one 1&amp;#34; or 11. 11 is read off as &amp;#34;two 1s&amp;#34; or 21. 21 is read off as &amp;#34;one 2, then one 1&amp;#34; or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</description>
    </item>
    
    <item>
      <title>231 - Power of Two</title>
      <link>//alfmunny.com/leetcode-blog/posts/231-power-of-two/</link>
      <pubDate>Mon, 08 Jun 2020 22:35:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/231-power-of-two/</guid>
      <description>leetcode
Problem Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true Explanation: 20 = 1 Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false Solution Solution 1: Straight forward class Solution: def powerOfTwo(self, n): while n != 1: if n % 2: return False n //= 2 return True Solution 2: Bit manipulation power of two: n = 1000000 n - 1 = 111111 n &amp;amp; (n-1) == 0</description>
    </item>
    
    <item>
      <title>1029 - Two City Scheduling</title>
      <link>//alfmunny.com/leetcode-blog/posts/1029-two-city-scheduling/</link>
      <pubDate>Wed, 03 Jun 2020 20:30:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1029-two-city-scheduling/</guid>
      <description>leetcode
Problem There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1]. Return the minimum cost to fly every person to a city such that exactly N people arrive in each city. Example 1: Input: [[10,20],[30,200],[400,50],[30,20]] Output: 110 Explanation: The first person goes to city A for a cost of 10.</description>
    </item>
    
    <item>
      <title>237 - Delete Node in a Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/237-delete-node-in-a-linked-list/</link>
      <pubDate>Wed, 03 Jun 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/237-delete-node-in-a-linked-list/</guid>
      <description>leetcode
Problem Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following: Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&amp;gt; 1 -&amp;gt; 9 after calling your function. Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -&amp;gt; 5 -&amp;gt; 9 after calling your function.</description>
    </item>
    
    <item>
      <title>746 - Min Cost Climbing Stairs</title>
      <link>//alfmunny.com/leetcode-blog/posts/746-min-cost-climbing-stairs/</link>
      <pubDate>Tue, 02 Jun 2020 00:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/746-min-cost-climbing-stairs/</guid>
      <description>leetcode
Problem On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</description>
    </item>
    
    <item>
      <title>226 - Invert Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/226-invert-binary-tree/</link>
      <pubDate>Mon, 01 Jun 2020 23:36:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/226-invert-binary-tree/</guid>
      <description>leetcode
Problem Invert a binary tree. Example: Input: 4 / \ 2 7 / \ / \ 1 3 6 9 Output: 4 / \ 7 2 / \ / \ 9 6 3 1 Solution class Solution: def invertTree(self): if root: tmp = root.left root.left = self.invertTree(root.right) root.right = self.invertTree(tmp) return root </description>
    </item>
    
    <item>
      <title>997 - Find the Town Judge</title>
      <link>//alfmunny.com/leetcode-blog/posts/997-find-the-town-judge/</link>
      <pubDate>Sun, 10 May 2020 21:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/997-find-the-town-judge/</guid>
      <description>leetcode
Problem In a town, there are N people labelled from 1 to N. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: 1. The town judge trusts nobody. 2. Everybody (except for the town judge) trusts the town judge. 3. There is exactly one person that satisfies properties 1 and 2. You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.</description>
    </item>
    
    <item>
      <title>733 - Flood Fill</title>
      <link>//alfmunny.com/leetcode-blog/posts/733-flood-fill/</link>
      <pubDate>Sat, 09 May 2020 15:50:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/733-flood-fill/</guid>
      <description>leetcode
Problem An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535). Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, &amp;#34;flood fill&amp;#34; the image. To perform a &amp;#34;flood fill&amp;#34;, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.</description>
    </item>
    
    <item>
      <title>1232 - Check If It Is a Straight Line</title>
      <link>//alfmunny.com/leetcode-blog/posts/1232-check-if-it-is-a-straight-line/</link>
      <pubDate>Sat, 09 May 2020 01:18:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1232-check-if-it-is-a-straight-line/</guid>
      <description>leetcode
Problem You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane. Solution Important
Notice the divider. It may be zero, when the lines are horizontal.
class Solution: def checkStraightLine(self, coordinates: List[List[int]]) -&amp;gt; bool: p1 = coordinates[0] p2 = coordinates[1] slope = self.slope(p1, p2) for i in range(2, len(coordinates)): if self.</description>
    </item>
    
    <item>
      <title>1009 - Complement of Base 10 Integer</title>
      <link>//alfmunny.com/leetcode-blog/posts/1009-complement-of-base-10-integer/</link>
      <pubDate>Mon, 04 May 2020 17:59:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1009-complement-of-base-10-integer/</guid>
      <description>leetcode
Problem Every non-negative integer N has a binary representation. For example, 5 can be represented as &amp;#34;101&amp;#34; in binary, 11 as &amp;#34;1011&amp;#34; in binary, and so on. Note that except for N = 0, there are no leading zeroes in any binary representation. The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1. For example, the complement of &amp;#34;101&amp;#34; in binary is &amp;#34;010&amp;#34; in binary.</description>
    </item>
    
    <item>
      <title>448 - Find All Numbers Disappeard in an Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/448-find-all-numbers-disappeard-in-an-array/</link>
      <pubDate>Tue, 28 Apr 2020 17:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/448-find-all-numbers-disappeard-in-an-array/</guid>
      <description>leetcode
Problem Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
Example:
Input: [4,3,2,7,8,2,3,1]
Output: [5,6]
Solution Move all the numbers to its position.</description>
    </item>
    
    <item>
      <title>169 - Majority Element</title>
      <link>//alfmunny.com/leetcode-blog/posts/169-majority-element/</link>
      <pubDate>Tue, 28 Apr 2020 16:22:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/169-majority-element/</guid>
      <description>leetcode
Problem Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
Example 1:
Input: [3,2,3] Output: 3
Example 2:
Input: [2,2,1,1,1,2,2] Output: 2
Solution Solution 1: Hash Table from collections import Counter class Solution: def majorityElement(self, nums): c = Counter() l = len(nums) for n in nums: c[n] += 1 if c[n] &amp;gt; l/2: return n print(Solution().</description>
    </item>
    
    <item>
      <title>Perform String Shifts</title>
      <link>//alfmunny.com/leetcode-blog/posts/perform-string-shifts/</link>
      <pubDate>Wed, 15 Apr 2020 00:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/perform-string-shifts/</guid>
      <description>leetcode
Problem You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [direction, amount]: direction can be 0 (for left shift) or 1 (for right shift). amount is the amount by which string s is to be shifted. A left shift by 1 means remove the first character of s and append it to the end. Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.</description>
    </item>
    
    <item>
      <title>1046 - Last Stone Weight</title>
      <link>//alfmunny.com/leetcode-blog/posts/1046-last-stone-weight/</link>
      <pubDate>Mon, 13 Apr 2020 01:46:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1046-last-stone-weight/</guid>
      <description>leetcode
Problem We have a collection of stones, each stone has a positive integer weight. Each turn, we choose the two heaviest stones and smash them together. Suppose the stones have weights x and y with x &amp;lt;= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.</description>
    </item>
    
    <item>
      <title>543 - Diameter of Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/543-diameter-of-binary-tree/</link>
      <pubDate>Sat, 11 Apr 2020 23:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/543-diameter-of-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example: Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    
    <item>
      <title>155 - Min Stack</title>
      <link>//alfmunny.com/leetcode-blog/posts/155-min-stack/</link>
      <pubDate>Fri, 10 Apr 2020 20:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/155-min-stack/</guid>
      <description>leetcode
Problem Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.pop(); minStack.top(); --&amp;gt; Returns 0. minStack.getMin(); --&amp;gt; Returns -2.</description>
    </item>
    
    <item>
      <title>844 - Backspace String Compare</title>
      <link>//alfmunny.com/leetcode-blog/posts/844-backspace-string-compare/</link>
      <pubDate>Thu, 09 Apr 2020 22:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/844-backspace-string-compare/</guid>
      <description>leetcode
Problem Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character. Example 1: Input: S = &amp;#34;ab#c&amp;#34;, T = &amp;#34;ad#c&amp;#34; Output: true Explanation: Both S and T become &amp;#34;ac&amp;#34;. Example 2: Input: S = &amp;#34;ab##&amp;#34;, T = &amp;#34;c#d#&amp;#34; Output: true Explanation: Both S and T become &amp;#34;&amp;#34;. Example 3: Input: S = &amp;#34;a##c&amp;#34;, T = &amp;#34;#a#c&amp;#34; Output: true Explanation: Both S and T become &amp;#34;c&amp;#34;.</description>
    </item>
    
    <item>
      <title>876 - Middle of the Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/876-middle-of-the-linked-list/</link>
      <pubDate>Wed, 08 Apr 2020 11:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/876-middle-of-the-linked-list/</guid>
      <description>leetcode
Problem Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge&amp;#39;s serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.</description>
    </item>
    
    <item>
      <title>283 - Move Zeros</title>
      <link>//alfmunny.com/leetcode-blog/posts/283-move-zeros/</link>
      <pubDate>Sat, 04 Apr 2020 17:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/283-move-zeros/</guid>
      <description>leetcode
Problem Given an array nums, write a function to move all 0&amp;#39;s to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Solution Two pointers.
One pointer is for the start of 0.
One pointer keeps going forward.
class Solution: def moveZeros(self, nums): p1, p2 = 0, 0 for p2 &amp;lt; len(nums): if nums[p1] !</description>
    </item>
    
    <item>
      <title>202 - Happy Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/202-happy-number/</link>
      <pubDate>Thu, 02 Apr 2020 16:03:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/202-happy-number/</guid>
      <description>leetcode
Problem Write an algorithm to determine if a number is &amp;#34;happy&amp;#34;. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>136 - Single Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/136-single-number/</link>
      <pubDate>Wed, 01 Apr 2020 22:36:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/136-single-number/</guid>
      <description>leetcode
Problem Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 Notes Solution 1: Hash Table Solution 2: Bit manipulation Consider XOR all element together. The left number is the single number.
Solution Solution 1: Hash Table class Solution: def singleNumber(self, nums): table = {} for i in nums: table[i] = table.</description>
    </item>
    
    <item>
      <title>198 - House Robber</title>
      <link>//alfmunny.com/leetcode-blog/posts/198-house-robber/</link>
      <pubDate>Fri, 27 Mar 2020 23:58:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/198-house-robber/</guid>
      <description>leetcode
Problem You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>101 - Symmetric Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/101-symmetric-tree/</link>
      <pubDate>Wed, 25 Mar 2020 21:02:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/101-symmetric-tree/</guid>
      <description>leetcode
Problem Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Notes Recursion !
Solution Solution 1: recursive class Solution: def isSymmetric(self, root): if not root: return True return self.</description>
    </item>
    
    <item>
      <title>21 - Merge Two Sorted Lists</title>
      <link>//alfmunny.com/leetcode-blog/posts/21-merge-two-sorted-lists/</link>
      <pubDate>Wed, 25 Mar 2020 19:55:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/21-merge-two-sorted-lists/</guid>
      <description>leetcode
Problem Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 Notes Recursion is your friend!
Solution Solution 1: Recursive class Solution: def mergeTwoLists(self, l1, l2): if not l1: return l2 if not l2: return l1 if l1.val &amp;gt; l2.val: l2.next = self.mergeTwoLists(l1, l2.next) return l2 else: l1.</description>
    </item>
    
    <item>
      <title>104 - Maximum Depth of Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Wed, 25 Mar 2020 17:16:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/104-maximum-depth-of-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 Notes Recursion is your friend!
Solution class Solution: def maxDepth(self, root): return 1 + max(self.maxDepth(root.right), self.</description>
    </item>
    
    <item>
      <title>122 - Best Time to Buy and Sell Stock II</title>
      <link>//alfmunny.com/leetcode-blog/posts/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Tue, 24 Mar 2020 15:26:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</description>
    </item>
    
    <item>
      <title>121 - Best Time to Buy and Sell Stock</title>
      <link>//alfmunny.com/leetcode-blog/posts/121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Tue, 24 Mar 2020 12:13:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/121-best-time-to-buy-and-sell-stock/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>45 - Jump Game II</title>
      <link>//alfmunny.com/leetcode-blog/posts/45-jump-game-ii/</link>
      <pubDate>Sun, 22 Mar 2020 00:55:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/45-jump-game-ii/</guid>
      <description>leetcode
Problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</description>
    </item>
    
    <item>
      <title>509 - Fibonacci Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/509-fibonacci-number/</link>
      <pubDate>Sat, 21 Mar 2020 22:31:20 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/509-fibonacci-number/</guid>
      <description>leetcode
Problem The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N &amp;gt; 1. Given N, calculate F(N). Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description>
    </item>
    
    <item>
      <title>70 - Climbing Stairs</title>
      <link>//alfmunny.com/leetcode-blog/posts/70-climbing-stairs/</link>
      <pubDate>Sat, 21 Mar 2020 22:25:51 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/70-climbing-stairs/</guid>
      <description>leetcode
Problem You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top.</description>
    </item>
    
    <item>
      <title>53 - Maximum Subarray</title>
      <link>//alfmunny.com/leetcode-blog/posts/53-maximum-subarray/</link>
      <pubDate>Sat, 21 Mar 2020 22:16:34 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/53-maximum-subarray/</guid>
      <description>leetcode
Problem Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Notes Dynamic programming problem.
Use nums[i] always store the maximum sum.</description>
    </item>
    
  </channel>
</rss>
