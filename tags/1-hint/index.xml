<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>1-hint on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/1-hint/</link>
    <description>Recent content in 1-hint on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 Aug 2020 16:05:00 +0200</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/1-hint/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>368 - Largest Divisible Subset</title>
      <link>//alfmunny.com/leetcode-blog/posts/368-largest-divisible-subset/</link>
      <pubDate>Wed, 19 Aug 2020 16:05:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/368-largest-divisible-subset/</guid>
      <description>leetcode
Problem Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1: Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok) Example 2: Input: [1,2,4,8] Output: [1,2,4,8] Solution Solution 1: DP class Solution: def largestDivisibleSubset(self, nums: List[int]) -&amp;gt; List[int]: if not nums: return nums dp = [1] * len(nums) pre = [i for i in range(len(nums))] nums.</description>
    </item>
    
    <item>
      <title>97 - Interleaving String</title>
      <link>//alfmunny.com/leetcode-blog/posts/97-interleaving-string/</link>
      <pubDate>Tue, 18 Aug 2020 15:15:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/97-interleaving-string/</guid>
      <description>leetcode
Problem Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2. Example 1: Input: s1 = &amp;#34;aabcc&amp;#34;, s2 = &amp;#34;dbbca&amp;#34;, s3 = &amp;#34;aadbbcbcac&amp;#34; Output: true Example 2: Input: s1 = &amp;#34;aabcc&amp;#34;, s2 = &amp;#34;dbbca&amp;#34;, s3 = &amp;#34;aadbbbaccc&amp;#34; Output: false Solution DP problem.
Imagin you have a matrix with s1 as its row and s2 as its column.
You have to find a path from upper left corner to bottom right corner, which consisits the s3.</description>
    </item>
    
    <item>
      <title>240 - Search a 2D Matrix II</title>
      <link>//alfmunny.com/leetcode-blog/posts/240-search-a-2d-matrix-ii/</link>
      <pubDate>Mon, 17 Aug 2020 03:11:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/240-search-a-2d-matrix-ii/</guid>
      <description>leetcode
Problem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true.</description>
    </item>
    
    <item>
      <title>81 - Search in Rotated Sorted Array II</title>
      <link>//alfmunny.com/leetcode-blog/posts/81-search-in-rotated-sorted-array-ii/</link>
      <pubDate>Thu, 13 Aug 2020 23:48:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/81-search-in-rotated-sorted-array-ii/</guid>
      <description>leetcode
Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.</description>
    </item>
    
    <item>
      <title>80 - Remove Duplicates from Sorted Array II</title>
      <link>//alfmunny.com/leetcode-blog/posts/80-remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Thu, 13 Aug 2020 22:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/80-remove-duplicates-from-sorted-array-ii/</guid>
      <description>leetcode
Problem Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</description>
    </item>
    
    <item>
      <title>73 - Set Matrix Zeroes</title>
      <link>//alfmunny.com/leetcode-blog/posts/73-set-matrix-zeroes/</link>
      <pubDate>Thu, 13 Aug 2020 21:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/73-set-matrix-zeroes/</guid>
      <description>leetcode
Problem Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2: Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] Follow up: A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution.</description>
    </item>
    
    <item>
      <title>190 - Reverse Bits</title>
      <link>//alfmunny.com/leetcode-blog/posts/190-reverse-bits/</link>
      <pubDate>Mon, 13 Jul 2020 00:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/190-reverse-bits/</guid>
      <description>leetcode
Problem Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Note: Note that in some languages such as Java, there is no unsigned integer type.</description>
    </item>
    
    <item>
      <title>441 - Arranging Coins</title>
      <link>//alfmunny.com/leetcode-blog/posts/441-arranging-coins/</link>
      <pubDate>Wed, 01 Jul 2020 23:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/441-arranging-coins/</guid>
      <description>leetcode
Problem You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5 The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ Because the 3rd row is incomplete, we return 2.</description>
    </item>
    
    <item>
      <title>988 - Smallest String Starting From Leaf</title>
      <link>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</link>
      <pubDate>Sat, 27 Jun 2020 15:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</guid>
      <description>leetcode
Problem Given the root of a binary tree, each node has a value from 0 to 25 representing the letters &amp;#39;a&amp;#39; to &amp;#39;z&amp;#39;: a value of 0 represents &amp;#39;a&amp;#39;, a value of 1 represents &amp;#39;b&amp;#39;, and so on. Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root. (As a reminder, any shorter prefix of a string is lexicographically smaller: for example, &amp;#34;ab&amp;#34; is lexicographically smaller than &amp;#34;aba&amp;#34;.</description>
    </item>
    
    <item>
      <title>518 - Coin Change 2</title>
      <link>//alfmunny.com/leetcode-blog/posts/518-coin-change-2/</link>
      <pubDate>Sun, 07 Jun 2020 21:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/518-coin-change-2/</guid>
      <description>leetcode
Problem You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.</description>
    </item>
    
    <item>
      <title>72 - Edit Distance</title>
      <link>//alfmunny.com/leetcode-blog/posts/72-edit-distance/</link>
      <pubDate>Sun, 31 May 2020 17:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/72-edit-distance/</guid>
      <description>leetcode
Problem Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = &amp;#34;horse&amp;#34;, word2 = &amp;#34;ros&amp;#34; Output: 3 Explanation: horse -&amp;gt; rorse (replace &amp;#39;h&amp;#39; with &amp;#39;r&amp;#39;) rorse -&amp;gt; rose (remove &amp;#39;r&amp;#39;) rose -&amp;gt; ros (remove &amp;#39;e&amp;#39;) Example 2: Input: word1 = &amp;#34;intention&amp;#34;, word2 = &amp;#34;execution&amp;#34; Output: 5 Explanation: intention -&amp;gt; inention (remove &amp;#39;t&amp;#39;) inention -&amp;gt; enention (replace &amp;#39;i&amp;#39; with &amp;#39;e&amp;#39;) enention -&amp;gt; exention (replace &amp;#39;n&amp;#39; with &amp;#39;x&amp;#39;) exention -&amp;gt; exection (replace &amp;#39;n&amp;#39; with &amp;#39;c&amp;#39;) exection -&amp;gt; execution (insert &amp;#39;u&amp;#39;) Solution class Solution: def minDistance(self, word1: str, word2: str) -&amp;gt; int: dp = [[0] * (1+len(word2)) for _ in range(1+len(word1))] for i in range(1+len(word1)): dp[i][0] = i for j in range(1+len(word2)): dp[0][j] = j for i in range(1, 1+len(word1)): for j in range(1, 1+len(word2)): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1 return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>438 - Find All Anagrams in a String</title>
      <link>//alfmunny.com/leetcode-blog/posts/438-find-all-anagrams-in-a-string/</link>
      <pubDate>Mon, 18 May 2020 05:08:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/438-find-all-anagrams-in-a-string/</guid>
      <description>leetcode
Problem Given a string s and a non-empty string p, find all the start indices of p&amp;#39;s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: &amp;#34;cbaebabacd&amp;#34; p: &amp;#34;abc&amp;#34; Output: [0, 6] Explanation: The substring with start index = 0 is &amp;#34;cba&amp;#34;, which is an anagram of &amp;#34;abc&amp;#34;.</description>
    </item>
    
    <item>
      <title>208 - Implement Trie (Prefix Tree)</title>
      <link>//alfmunny.com/leetcode-blog/posts/208-implement-trie/</link>
      <pubDate>Thu, 14 May 2020 21:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/208-implement-trie/</guid>
      <description>leetcode
Problem  Implement a trie with insert, search, and startsWith methods.
Example:
Trie trie = new Trie();
trie.insert(&amp;ldquo;apple&amp;rdquo;); trie.search(&amp;ldquo;apple&amp;rdquo;); / returns true trie.search(&amp;ldquo;app&amp;rdquo;); / returns false trie.startsWith(&amp;ldquo;app&amp;rdquo;); // returns true trie.insert(&amp;ldquo;app&amp;rdquo;); trie.search(&amp;ldquo;app&amp;rdquo;); // returns true
 Solution Trie.
Use a &amp;ldquo;END&amp;rdquo; Symbol for word ending.
search method checks for &amp;ldquo;END&amp;rdquo;, startsWith not.
class Trie: def __init__(self): self.root = Node() def search(self, s): node = self.root for c in s: node = node.</description>
    </item>
    
    <item>
      <title>128 - Longest Consecutive Sequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</link>
      <pubDate>Sat, 02 May 2020 16:34:20 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</guid>
      <description>leetcode
Problem Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution Solution 1: Hash Map For each value, we maintain the left bound and right bound of range and also update the bounds for left value and right value.</description>
    </item>
    
    <item>
      <title>124 - Binary Tree Maximum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</link>
      <pubDate>Wed, 29 Apr 2020 16:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</guid>
      <description>leetcode
Problem Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3]
1 / \
2 3
Output: 6 Example 2:
Input: [-10,9,20,null,null,15,7]</description>
    </item>
    
    <item>
      <title>1143 - Longest Common Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/1143-longest-common-subsequence/</link>
      <pubDate>Mon, 27 Apr 2020 14:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1143-longest-common-subsequence/</guid>
      <description>leetcode
Problem Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, &amp;#34;ace&amp;#34; is a subsequence of &amp;#34;abcde&amp;#34; while &amp;#34;aec&amp;#34; is not). A common subsequence of two strings is a subsequence that is common to both strings.</description>
    </item>
    
    <item>
      <title>460 - LFU Cache</title>
      <link>//alfmunny.com/leetcode-blog/posts/460-lfu-cache/</link>
      <pubDate>Sun, 26 Apr 2020 00:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/460-lfu-cache/</guid>
      <description>leetcode
Problem Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>560 Subarray Sum Equals K</title>
      <link>//alfmunny.com/leetcode-blog/posts/560-subarray-sum-equals-k/</link>
      <pubDate>Thu, 23 Apr 2020 01:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/560-subarray-sum-equals-k/</guid>
      <description>leetcode
Problem Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. Solution class Solution: def subArraySum(self, nums, k): h = {0: 1} s = 0 ans = 0 for i in nums: s += i ans += h.</description>
    </item>
    
    <item>
      <title>Leftmost Column with at Least a One</title>
      <link>//alfmunny.com/leetcode-blog/posts/leftmost-column-with-at-least-a-one/</link>
      <pubDate>Wed, 22 Apr 2020 01:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/leftmost-column-with-at-least-a-one/</guid>
      <description>leetcode
Problem A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn&amp;#39;t exist, return -1. You can&amp;#39;t access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface: BinaryMatrix.get(x, y) returns the element of the matrix at index (x, y) (0-indexed).</description>
    </item>
    
    <item>
      <title>47 - Permutations II</title>
      <link>//alfmunny.com/leetcode-blog/posts/47-permutations-ii/</link>
      <pubDate>Sun, 19 Apr 2020 01:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/47-permutations-ii/</guid>
      <description>leetcode
Problem Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] Solution Backtrack problem.
Framework of backtrack problem:
 choose a path selection pool return condition  ans = [] def backtrack(path, pool): if meet condition: ans.add(path) return for selection in pool: path.add(selection) backtrack(path, new_pool) path.remove(selection) Important:
Pay attention, you must add a copy of the path to result, not the path it self.</description>
    </item>
    
    <item>
      <title>215 - Kth Largest Element in an Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/215-kth-largest-element-in-an-array/</link>
      <pubDate>Mon, 06 Apr 2020 01:05:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/215-kth-largest-element-in-an-array/</guid>
      <description>leetcode
Problem 215. Kth Largest Element in an Array Medium 3152 222 Add to List Share Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note: You may assume k is always valid, 1 ≤ k ≤ array&amp;#39;s length.</description>
    </item>
    
    <item>
      <title>416 - Partition Equal Subset Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</link>
      <pubDate>Sun, 05 Apr 2020 21:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</guid>
      <description>leetcode
Problem Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets.</description>
    </item>
    
    <item>
      <title>647 - Palindromic Substrings</title>
      <link>//alfmunny.com/leetcode-blog/posts/647-palindromic-substrings/</link>
      <pubDate>Tue, 31 Mar 2020 23:41:02 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/647-palindromic-substrings/</guid>
      <description>leetcode
Problem Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: Input: &amp;#34;abc&amp;#34; Output: 3 Explanation: Three palindromic strings: &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;. Example 2: Input: &amp;#34;aaa&amp;#34; Output: 6 Explanation: Six palindromic strings: &amp;#34;a&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;aa&amp;#34;, &amp;#34;aa&amp;#34;, &amp;#34;aaa&amp;#34;. Note: The input string length won&amp;#39;t exceed 1000.</description>
    </item>
    
    <item>
      <title>300 - Longest Increasing Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/300-longest-increasing-subsequence/</link>
      <pubDate>Sat, 28 Mar 2020 00:08:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/300-longest-increasing-subsequence/</guid>
      <description>leetcode
Problem Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note: There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? Solution DP problem.</description>
    </item>
    
  </channel>
</rss>