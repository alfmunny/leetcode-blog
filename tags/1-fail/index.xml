<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>1-fail on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/1-fail/</link>
    <description>Recent content in 1-fail on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 May 2020 22:26:00 +0200</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/1-fail/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>402 - Remove K Digits</title>
      <link>//alfmunny.com/leetcode-blog/posts/402-remove-k-digits/</link>
      <pubDate>Wed, 13 May 2020 22:26:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/402-remove-k-digits/</guid>
      <description>leetcode
Problem  Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.
Example 1:
Input: num = &amp;ldquo;1432219&amp;rdquo;, k = 3 Output: &amp;ldquo;1219&amp;rdquo; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description>
    </item>
    
    <item>
      <title>887 - Super Egg Drop</title>
      <link>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</link>
      <pubDate>Sun, 03 May 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</guid>
      <description>leetcode
Problem You are given K eggs, and you have access to a building with N floors from 1 to N. Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.</description>
    </item>
    
    <item>
      <title>105 - Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Sat, 02 May 2020 00:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>leetcode
Problem Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution  The first node of the preorder is always the root. Find the root in the inorder array, split it there.</description>
    </item>
    
    <item>
      <title>437 - Path Sum III</title>
      <link>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</link>
      <pubDate>Sun, 26 Apr 2020 15:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</guid>
      <description>leetcode
Problem You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</description>
    </item>
    
    <item>
      <title>201 - Bitwise AND of Numbers Range</title>
      <link>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</link>
      <pubDate>Fri, 24 Apr 2020 01:35:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</guid>
      <description>leetcode
Problem Given a range [m, n] where 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4 Example 2: Input: [0,1] Output: 0 Solution m = xxx1yyyy n = xxx01zzz
xxx is the parts that two numbers are the same. We can definitly find these two numbers in the range
m&amp;rsquo; = xxx1000 n&amp;rsquo; = xxx0100</description>
    </item>
    
    <item>
      <title>1008 - Construct Binary Search Tree from Preorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/1008-construct-binary-search-tree-from-preorder-traversal/</link>
      <pubDate>Tue, 21 Apr 2020 07:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1008-construct-binary-search-tree-from-preorder-traversal/</guid>
      <description>leetcode
Problem Return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &amp;lt; node.val, and any descendant of node.right has a value &amp;gt; node.val. Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.) Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12] Solution We keep track of a low bound for the function.</description>
    </item>
    
    <item>
      <title>678 - Valid Parenthesis String</title>
      <link>//alfmunny.com/leetcode-blog/posts/678-valid-parenthesis-string/</link>
      <pubDate>Thu, 16 Apr 2020 23:07:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/678-valid-parenthesis-string/</guid>
      <description>leetcode
Problem Given a string containing only three types of characters: &amp;#39;(&amp;#39;, &amp;#39;)&amp;#39; and &amp;#39;*&amp;#39;, write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis &amp;#39;(&amp;#39; must have a corresponding right parenthesis &amp;#39;)&amp;#39;. Any right parenthesis &amp;#39;)&amp;#39; must have a corresponding left parenthesis &amp;#39;(&amp;#39;. Left parenthesis &amp;#39;(&amp;#39; must go before the corresponding right parenthesis &amp;#39;)&amp;#39;. &amp;#39;*&amp;#39; could be treated as a single right parenthesis &amp;#39;)&amp;#39; or a single left parenthesis &amp;#39;(&amp;#39; or an empty string.</description>
    </item>
    
    <item>
      <title>525 - Contiguous Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/525-contiguous-array/</link>
      <pubDate>Mon, 13 Apr 2020 23:06:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/525-contiguous-array/</guid>
      <description>leetcode
Problem Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000.</description>
    </item>
    
    <item>
      <title>494 - Target Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/494-target-sum/</link>
      <pubDate>Sat, 04 Apr 2020 16:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/494-target-sum/</guid>
      <description>leetcode
Problem You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.</description>
    </item>
    
    <item>
      <title>338 - Counting Bits</title>
      <link>//alfmunny.com/leetcode-blog/posts/338-counting-bit/</link>
      <pubDate>Thu, 02 Apr 2020 17:03:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/338-counting-bit/</guid>
      <description>leetcode
Problem Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;#39;s in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Notes DP problem
 States: index Transition:  dp[0] = 0 dp[1] = dp[1-1] + 1 = 1 dp[2] = dp[2-2] + 1 = 1 dp[3] = dp[3-2] + 1 = 2 dp[4] = dp[4-4] + 1 = 1 dp[5] = dp[5-4] + 1 = 2 dp[6] = dp[6-4] + 1 = 2 dp[7] = dp[7-4] + 1 = 3 dp[8] = dp[8-8] + 1 = 1 dp[9] = dp[9-8] + 1 = 2 dp[i] = dp[i - log_2 (i)] + 1 A trick using bit manipulation: 8 -&amp;gt; 1000 9 -&amp;gt; 1001 10 -&amp;gt; 1010 9 &amp;amp; 8 -&amp;gt; 1001 &amp;amp; 1000 -&amp;gt; 1000 dp[8] + 1 = 2 10 &amp;amp; 9 -&amp;gt; 1010 &amp;amp; 1001 -&amp;gt; 1000 dp[8] + 1 = 2 11 &amp;amp; 10 -&amp;gt; 1011 &amp;amp; 1010 -&amp;gt; 1010 dp[10] + 1 = 3 12 &amp;amp; 11 -&amp;gt; 1100 &amp;amp; 1011 -&amp;gt; 1000 dp[8] + 1 = 2 dp[i] = dp[i &amp;amp; (i-1)] + 1 Solution Solution 1: DP class Solution: def countBits(self, num): offset = 1 dp = [0] * (num + 1) for i in range(1, num + 1): if offset * 2 == i: offset *= 2 dp[i] = dp[i - offset] + 1 return dp Solution 2: Bit manipulation on couting bits class Solution: def countBits(self, num): dp = [0] * (num + 1) for i in range(1, num + 1): dp[i] = dp[i &amp;amp; (i - 1)] + 1 return dp Solution 3: class Solution(object): def countBits(self, num): res=[0] while len(res)&amp;lt;=num: res+=[i+1 for i in res] return res[:num+1] </description>
    </item>
    
    <item>
      <title>279 - Perfect Squares</title>
      <link>//alfmunny.com/leetcode-blog/posts/279-perfect-squares/</link>
      <pubDate>Tue, 31 Mar 2020 00:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/279-perfect-squares/</guid>
      <description>leetcode
Problem Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Notes DP problem
  States: n
  Transition:
  dp[i] = min([_dp[i-j*j]+1 if i-j*j &amp;gt;= 0 else break for j in range(1, sqrt(i)+1)])   Base case:</description>
    </item>
    
    <item>
      <title>309 - Best Time to Buy and Sell Stock with Cooldown</title>
      <link>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Tue, 24 Mar 2020 22:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>188 - Best Time to Buy and Sell Stock IV</title>
      <link>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</link>
      <pubDate>Tue, 24 Mar 2020 21:46:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</guid>
      <description>leetcode
Problem Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</description>
    </item>
    
    <item>
      <title>123 - Best Time to Buy and Sell Stock III</title>
      <link>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Tue, 24 Mar 2020 18:25:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</description>
    </item>
    
    <item>
      <title>85 - Maximal Rectangle</title>
      <link>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</link>
      <pubDate>Tue, 24 Mar 2020 00:57:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</guid>
      <description>Problem Notes Solution  leetcode
Problem Given a 2D binary matrix filled with 0&amp;#39;s and 1&amp;#39;s, find the largest rectangle containing only 1&amp;#39;s and return its area. Example: Input: [ [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;] ] Output: 6 Notes Two parts:
 generate a heights histogram for every row. apple &amp;ldquo;largest rectangle in histogram&amp;rdquo; on each row of histogram  Solution class Solution: def maximalRectangle(self, matrix): if not matrix or not matrix[0]: return 0 m = len(matrix) n = len(matrix[0]) histograms = [[0] * n for i in range(m)] res = 0 for i in range(m): for j in range(n): if matrix[i][j] == &amp;#34;1&amp;#34;: histograms[i][j] = histograms[i - 1][j] + 1 if i &amp;gt; 0 else 1 for histogram in histograms: res = max(res, self.</description>
    </item>
    
    <item>
      <title>84 - Largest Rectangle in Histogram</title>
      <link>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</link>
      <pubDate>Mon, 23 Mar 2020 00:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</guid>
      <description>leetcode
Problem Given n non-negative integers representing the histogram&amp;#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Example: Input: [2,1,5,6,2,3] Output: 10 Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
The largest rectangle is shown in the shaded area, which has area = 10 unit.
Notes Main idea is to caculate both left edge and right edge for every entry in the array</description>
    </item>
    
  </channel>
</rss>