<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>1-fail on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/1-fail/</link>
    <description>Recent content in 1-fail on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 21 Nov 2020 02:56:00 +0100</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/1-fail/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>115 - Distinct Subsequences</title>
      <link>//alfmunny.com/leetcode-blog/posts/115-distinct-subsequences/</link>
      <pubDate>Sat, 21 Nov 2020 02:56:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/115-distinct-subsequences/</guid>
      <description>leetcode
Problem Given two strings s and t, return the number of distinct subsequences of s which equals t. A string&amp;#39;s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &amp;#34;ACE&amp;#34; is a subsequence of &amp;#34;ABCDE&amp;#34; while &amp;#34;AEC&amp;#34; is not). It&amp;#39;s guaranteed the answer fits on a 32-bit signed integer. Example 1: Input: s = &amp;#34;rabbbit&amp;#34;, t = &amp;#34;rabbit&amp;#34; Output: 3 Explanation: As shown below, there are 3 ways you can generate &amp;#34;rabbit&amp;#34; from S.</description>
    </item>
    
    <item>
      <title>354 - Russian Doll Envelopes</title>
      <link>//alfmunny.com/leetcode-blog/posts/354-russian-doll-envelopes/</link>
      <pubDate>Sun, 11 Oct 2020 18:39:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/354-russian-doll-envelopes/</guid>
      <description>leetcode
Problem You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other) Note: Rotation is not allowed. Example: Input: [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&amp;gt; [5,4] =&amp;gt; [6,7]).</description>
    </item>
    
    <item>
      <title>983 - Minimum Cost For Tickets</title>
      <link>//alfmunny.com/leetcode-blog/posts/983-minimum-cost-for-tickets/</link>
      <pubDate>Wed, 26 Aug 2020 22:50:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/983-minimum-cost-for-tickets/</guid>
      <description>leetcode
Problem In a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365. Train tickets are sold in 3 different ways: a 1-day pass is sold for costs[0] dollars; a 7-day pass is sold for costs[1] dollars; a 30-day pass is sold for costs[2] dollars.</description>
    </item>
    
    <item>
      <title>1032 - Stream of Characters</title>
      <link>//alfmunny.com/leetcode-blog/posts/1032-stream-of-characters/</link>
      <pubDate>Sun, 23 Aug 2020 16:34:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1032-stream-of-characters/</guid>
      <description>leetcode
Problem Implement the StreamChecker class as follows: StreamChecker(words): Constructor, init the data structure with the given words. query(letter): returns true if and only if for some k &amp;gt;= 1, the last k characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list. Example: StreamChecker streamChecker = new StreamChecker([&amp;#34;cd&amp;#34;,&amp;#34;f&amp;#34;,&amp;#34;kl&amp;#34;]); // init the dictionary. streamChecker.query(&amp;#39;a&amp;#39;); // return false streamChecker.query(&amp;#39;b&amp;#39;); // return false streamChecker.</description>
    </item>
    
    <item>
      <title>516 - Longest Palindromic Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/516-longest-palindromic-subsequence/</link>
      <pubDate>Sat, 22 Aug 2020 12:25:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/516-longest-palindromic-subsequence/</guid>
      <description>leetcode
Problem Given a string s, find the longest palindromic subsequence&amp;#39;s length in s. You may assume that the maximum length of s is 1000. Example 1: Input: &amp;#34;bbbab&amp;#34; Output: 4 One possible longest palindromic subsequence is &amp;#34;bbbb&amp;#34;. Example 2: Input: &amp;#34;cbbd&amp;#34; Output: 2 One possible longest palindromic subsequence is &amp;#34;bb&amp;#34;. Constraints: 1 &amp;lt;= s.length &amp;lt;= 1000 s consists only of lowercase English letters. Solution DP problem.
dp[i][j] represents the max value for substring from j to i.</description>
    </item>
    
    <item>
      <title>114 - Flatten Binary Tree to Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/114-flatten-binary-tree-to-linked-list/</link>
      <pubDate>Wed, 19 Aug 2020 14:55:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/114-flatten-binary-tree-to-linked-list/</guid>
      <description>leetcode
Problem Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 Solution  Traverse the tree in reverse preorder, the opposite of root-left-right. Save the root, and use it in the upper level.  class Solution: def flatten(self, root: TreeNode) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34;Do not return anything, modify root in-place instead.</description>
    </item>
    
    <item>
      <title>109 - Convert Sorted List to Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/109-convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Tue, 18 Aug 2020 16:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/109-convert-sorted-list-to-binary-search-tree/</guid>
      <description>leetcode
Problem Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Solution class Solution: def sortedListToBST(self, head: ListNode) -&amp;gt; TreeNode: if not head: return None if not head.</description>
    </item>
    
    <item>
      <title>82 - Remove Duplicates from Sorted List II</title>
      <link>//alfmunny.com/leetcode-blog/posts/82-remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Mon, 17 Aug 2020 03:08:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/82-remove-duplicates-from-sorted-list-ii/</guid>
      <description>leetcode
Problem Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 Output: 1-&amp;gt;2-&amp;gt;5 Example 2: Input: 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3 Output: 2-&amp;gt;3 Solution class Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head extra = ListNode(None) extra.next = head pre = extra while head and head.</description>
    </item>
    
    <item>
      <title>71 - Simplify Path</title>
      <link>//alfmunny.com/leetcode-blog/posts/71-simplify-path/</link>
      <pubDate>Thu, 13 Aug 2020 18:18:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/71-simplify-path/</guid>
      <description>leetcode
Problem Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names.</description>
    </item>
    
    <item>
      <title>32 - Longest Valid Parentheses</title>
      <link>//alfmunny.com/leetcode-blog/posts/32-longest-valid-parentheses/</link>
      <pubDate>Thu, 13 Aug 2020 17:14:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/32-longest-valid-parentheses/</guid>
      <description>leetcode
Problem Given a string containing just the characters &amp;#39;(&amp;#39; and &amp;#39;)&amp;#39;, find the length of the longest valid (well-formed) parentheses substring. Example 1: Input: &amp;#34;(()&amp;#34; Output: 2 Explanation: The longest valid parentheses substring is &amp;#34;()&amp;#34; Example 2: Input: &amp;#34;)()())&amp;#34; Output: 4 Explanation: The longest valid parentheses substring is &amp;#34;()()&amp;#34; Solution class Solution: def longestValidParentheses(self, s: str) -&amp;gt; int: stack = [-1] ans = 0 for i in range(len(s)): if s[i] == &amp;#39;(&amp;#39;: stack.</description>
    </item>
    
    <item>
      <title>10 - Regular Expression Matching</title>
      <link>//alfmunny.com/leetcode-blog/posts/10-regular-expression-matching/</link>
      <pubDate>Fri, 10 Jul 2020 02:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/10-regular-expression-matching/</guid>
      <description>leetcode
Problem Given an input string (s) and a pattern (p), implement regular expression matching with support for &amp;#39;.&amp;#39; and &amp;#39;*&amp;#39;. &amp;#39;.&amp;#39; Matches any single character. &amp;#39;*&amp;#39; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.</description>
    </item>
    
    <item>
      <title>212 - Word Search II</title>
      <link>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</link>
      <pubDate>Wed, 01 Jul 2020 00:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</guid>
      <description>leetcode
Problem Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input: board = [ [&amp;#39;o&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;n&amp;#39;], [&amp;#39;e&amp;#39;,&amp;#39;t&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;e&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;h&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;r&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;v&amp;#39;] ] words = [&amp;#34;oath&amp;#34;,&amp;#34;pea&amp;#34;,&amp;#34;eat&amp;#34;,&amp;#34;rain&amp;#34;] Output: [&amp;#34;eat&amp;#34;,&amp;#34;oath&amp;#34;] Note: All inputs are consist of lowercase letters a-z.</description>
    </item>
    
    <item>
      <title>332 - Reconstruct Itinerary</title>
      <link>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinerary/</link>
      <pubDate>Mon, 29 Jun 2020 23:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinerary/</guid>
      <description>leetcode
Problem Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&amp;#34;JFK&amp;#34;, &amp;#34;LGA&amp;#34;] has a smaller lexical order than [&amp;#34;JFK&amp;#34;, &amp;#34;LGB&amp;#34;].</description>
    </item>
    
    <item>
      <title>332 - Reconstruct Itinrary</title>
      <link>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinrary/</link>
      <pubDate>Mon, 29 Jun 2020 23:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinrary/</guid>
      <description>leetcode
Problem Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&amp;#34;JFK&amp;#34;, &amp;#34;LGA&amp;#34;] has a smaller lexical order than [&amp;#34;JFK&amp;#34;, &amp;#34;LGB&amp;#34;].</description>
    </item>
    
    <item>
      <title>264 - Ugly Number II</title>
      <link>//alfmunny.com/leetcode-blog/posts/264-ugly-number-ii/</link>
      <pubDate>Sat, 27 Jun 2020 23:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/264-ugly-number-ii/</guid>
      <description>leetcode
Problem Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note: 1 is typically treated as an ugly number. n does not exceed 1690. Solution class Solution: ugly = sorted(2**a * 3**b * 5**c for a in range(32) for b in range(32) for c in range(32)) def nthUglyNumber(self, n: int) -&amp;gt; int: return self.</description>
    </item>
    
    <item>
      <title>95 - Unique Binary Search Trees II</title>
      <link>//alfmunny.com/leetcode-blog/posts/95-unique-binary-search-treea-ii/</link>
      <pubDate>Sat, 20 Jun 2020 02:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/95-unique-binary-search-treea-ii/</guid>
      <description>leetcode
Problem Given an integer n, generate all structurally unique BST&amp;#39;s (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST&amp;#39;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 Solution class Solution: def generateTrees(self, n: int) -&amp;gt; List[TreeNode]: if n == 0: return [] return self.</description>
    </item>
    
    <item>
      <title>377 - Combination Sum IV</title>
      <link>//alfmunny.com/leetcode-blog/posts/337-combination-sum-iv/</link>
      <pubDate>Thu, 11 Jun 2020 15:12:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/337-combination-sum-iv/</guid>
      <description>leetcode
Problem Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4 The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Note that different sequences are counted as different combinations. Therefore the output is 7.</description>
    </item>
    
    <item>
      <title>406 - Queue Reconstruction by Height</title>
      <link>//alfmunny.com/leetcode-blog/posts/406-queue-reconstruction-by-height/</link>
      <pubDate>Mon, 08 Jun 2020 22:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/406-queue-reconstruction-by-height/</guid>
      <description>leetcode
Problem Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of people is less than 1,100.</description>
    </item>
    
    <item>
      <title>528 - Random Pick with Weight</title>
      <link>//alfmunny.com/leetcode-blog/posts/528-random-pick-with-weight/</link>
      <pubDate>Fri, 05 Jun 2020 22:00:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/528-random-pick-with-weight/</guid>
      <description>leetcode
Problem Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note: 1 &amp;lt;= w.length &amp;lt;= 10000 1 &amp;lt;= w[i] &amp;lt;= 10^5 pickIndex will be called at most 10000 times. Example 1: Input: [&amp;#34;Solution&amp;#34;,&amp;#34;pickIndex&amp;#34;] [[[1]],[]] Output: [null,0] Example 2: Input: [&amp;#34;Solution&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0] Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments.</description>
    </item>
    
    <item>
      <title>207 - Course Schedule</title>
      <link>//alfmunny.com/leetcode-blog/posts/207-course-schedule/</link>
      <pubDate>Fri, 29 May 2020 19:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/207-course-schedule/</guid>
      <description>leetcode
Problem There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take.</description>
    </item>
    
    <item>
      <title>886 - Possible Bipartition</title>
      <link>//alfmunny.com/leetcode-blog/posts/886-possible-bipartition/</link>
      <pubDate>Wed, 27 May 2020 16:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/886-possible-bipartition/</guid>
      <description>leetcode
Problem Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.</description>
    </item>
    
    <item>
      <title>986 - Interval List Intersections</title>
      <link>//alfmunny.com/leetcode-blog/posts/996-interval-list-intersections/</link>
      <pubDate>Sun, 24 May 2020 01:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/996-interval-list-intersections/</guid>
      <description>leetcode
Problem Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a &amp;lt;= b) denotes the set of real numbers x with a &amp;lt;= x &amp;lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.</description>
    </item>
    
    <item>
      <title>230 - Kth Smallest Element in a BST</title>
      <link>//alfmunny.com/leetcode-blog/posts/230-kth-smallest-element-in-a-bst/</link>
      <pubDate>Wed, 20 May 2020 22:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/230-kth-smallest-element-in-a-bst/</guid>
      <description>leetcode
Problem 230. Kth Smallest Element in a BST Medium 2239 57 Add to List Share Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 ≤ k ≤ BST&amp;#39;s total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 Output: 3 Solution class Solution: def kthSmallest(self, root): self.</description>
    </item>
    
    <item>
      <title>901 - Onine Stock Span</title>
      <link>//alfmunny.com/leetcode-blog/posts/901-online-stock-span/</link>
      <pubDate>Tue, 19 May 2020 21:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/901-online-stock-span/</guid>
      <description>leetcode
Problem Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock&amp;#39;s price for the current day. The span of the stock&amp;#39;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today&amp;#39;s price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].</description>
    </item>
    
    <item>
      <title>438 - Find All Anagrams in a String</title>
      <link>//alfmunny.com/leetcode-blog/posts/438-find-all-anagrams-in-a-string/</link>
      <pubDate>Mon, 18 May 2020 05:08:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/438-find-all-anagrams-in-a-string/</guid>
      <description>leetcode
Problem Given a string s and a non-empty string p, find all the start indices of p&amp;#39;s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: &amp;#34;cbaebabacd&amp;#34; p: &amp;#34;abc&amp;#34; Output: [0, 6] Explanation: The substring with start index = 0 is &amp;#34;cba&amp;#34;, which is an anagram of &amp;#34;abc&amp;#34;.</description>
    </item>
    
    <item>
      <title>918 - Maximum Sum Circular Subarray</title>
      <link>//alfmunny.com/leetcode-blog/posts/918-maximum-sum-circular-subarray/</link>
      <pubDate>Fri, 15 May 2020 22:27:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/918-maximum-sum-circular-subarray/</guid>
      <description>leetcode
Problem  Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.
Here, a circular array means the end of the array connects to the beginning of the array. (Formally, C[i] = A[i] when 0 &amp;lt;= i &amp;lt; A.length, and C[i+A.length] = C[i] when i &amp;gt;= 0.)
Also, a subarray may only include each element of the fixed buffer A at most once.</description>
    </item>
    
    <item>
      <title>402 - Remove K Digits</title>
      <link>//alfmunny.com/leetcode-blog/posts/402-remove-k-digits/</link>
      <pubDate>Wed, 13 May 2020 22:26:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/402-remove-k-digits/</guid>
      <description>leetcode
Problem  Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.
Example 1:
Input: num = &amp;ldquo;1432219&amp;rdquo;, k = 3 Output: &amp;ldquo;1219&amp;rdquo; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description>
    </item>
    
    <item>
      <title>887 - Super Egg Drop</title>
      <link>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</link>
      <pubDate>Sun, 03 May 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</guid>
      <description>leetcode
Problem You are given K eggs, and you have access to a building with N floors from 1 to N. Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.</description>
    </item>
    
    <item>
      <title>105 - Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Sat, 02 May 2020 00:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>leetcode
Problem Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution  The first node of the preorder is always the root. Find the root in the inorder array, split it there.</description>
    </item>
    
    <item>
      <title>437 - Path Sum III</title>
      <link>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</link>
      <pubDate>Sun, 26 Apr 2020 15:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</guid>
      <description>leetcode
Problem You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</description>
    </item>
    
    <item>
      <title>201 - Bitwise AND of Numbers Range</title>
      <link>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</link>
      <pubDate>Fri, 24 Apr 2020 01:35:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</guid>
      <description>leetcode
Problem Given a range [m, n] where 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4 Example 2: Input: [0,1] Output: 0 Solution m = xxx1yyyy n = xxx01zzz
xxx is the parts that two numbers are the same. We can definitly find these two numbers in the range
m&amp;rsquo; = xxx1000 n&amp;rsquo; = xxx0100</description>
    </item>
    
    <item>
      <title>1008 - Construct Binary Search Tree from Preorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/1008-construct-binary-search-tree-from-preorder-traversal/</link>
      <pubDate>Tue, 21 Apr 2020 07:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1008-construct-binary-search-tree-from-preorder-traversal/</guid>
      <description>leetcode
Problem Return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &amp;lt; node.val, and any descendant of node.right has a value &amp;gt; node.val. Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.) Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12] Solution We keep track of a low bound for the function.</description>
    </item>
    
    <item>
      <title>678 - Valid Parenthesis String</title>
      <link>//alfmunny.com/leetcode-blog/posts/678-valid-parenthesis-string/</link>
      <pubDate>Thu, 16 Apr 2020 23:07:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/678-valid-parenthesis-string/</guid>
      <description>leetcode
Problem Given a string containing only three types of characters: &amp;#39;(&amp;#39;, &amp;#39;)&amp;#39; and &amp;#39;*&amp;#39;, write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis &amp;#39;(&amp;#39; must have a corresponding right parenthesis &amp;#39;)&amp;#39;. Any right parenthesis &amp;#39;)&amp;#39; must have a corresponding left parenthesis &amp;#39;(&amp;#39;. Left parenthesis &amp;#39;(&amp;#39; must go before the corresponding right parenthesis &amp;#39;)&amp;#39;. &amp;#39;*&amp;#39; could be treated as a single right parenthesis &amp;#39;)&amp;#39; or a single left parenthesis &amp;#39;(&amp;#39; or an empty string.</description>
    </item>
    
    <item>
      <title>525 - Contiguous Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/525-contiguous-array/</link>
      <pubDate>Mon, 13 Apr 2020 23:06:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/525-contiguous-array/</guid>
      <description>leetcode
Problem Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000.</description>
    </item>
    
    <item>
      <title>494 - Target Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/494-target-sum/</link>
      <pubDate>Sat, 04 Apr 2020 16:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/494-target-sum/</guid>
      <description>leetcode
Problem You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.</description>
    </item>
    
    <item>
      <title>338 - Counting Bits</title>
      <link>//alfmunny.com/leetcode-blog/posts/338-counting-bit/</link>
      <pubDate>Thu, 02 Apr 2020 17:03:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/338-counting-bit/</guid>
      <description>leetcode
Problem Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;#39;s in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Notes DP problem
 States: index Transition:  dp[0] = 0 dp[1] = dp[1-1] + 1 = 1 dp[2] = dp[2-2] + 1 = 1 dp[3] = dp[3-2] + 1 = 2 dp[4] = dp[4-4] + 1 = 1 dp[5] = dp[5-4] + 1 = 2 dp[6] = dp[6-4] + 1 = 2 dp[7] = dp[7-4] + 1 = 3 dp[8] = dp[8-8] + 1 = 1 dp[9] = dp[9-8] + 1 = 2 dp[i] = dp[i - log_2 (i)] + 1 A trick using bit manipulation: 8 -&amp;gt; 1000 9 -&amp;gt; 1001 10 -&amp;gt; 1010 9 &amp;amp; 8 -&amp;gt; 1001 &amp;amp; 1000 -&amp;gt; 1000 dp[8] + 1 = 2 10 &amp;amp; 9 -&amp;gt; 1010 &amp;amp; 1001 -&amp;gt; 1000 dp[8] + 1 = 2 11 &amp;amp; 10 -&amp;gt; 1011 &amp;amp; 1010 -&amp;gt; 1010 dp[10] + 1 = 3 12 &amp;amp; 11 -&amp;gt; 1100 &amp;amp; 1011 -&amp;gt; 1000 dp[8] + 1 = 2 dp[i] = dp[i &amp;amp; (i-1)] + 1 Solution Solution 1: DP class Solution: def countBits(self, num): offset = 1 dp = [0] * (num + 1) for i in range(1, num + 1): if offset * 2 == i: offset *= 2 dp[i] = dp[i - offset] + 1 return dp Solution 2: Bit manipulation on couting bits class Solution: def countBits(self, num): dp = [0] * (num + 1) for i in range(1, num + 1): dp[i] = dp[i &amp;amp; (i - 1)] + 1 return dp Solution 3: class Solution(object): def countBits(self, num): res=[0] while len(res)&amp;lt;=num: res+=[i+1 for i in res] return res[:num+1] Solution 4: class Solution: def countBits(self, num): dp = [0] * (num + 1) for i in range(1, num+1): if not i % 2: dp[i] = dp[i &amp;gt;&amp;gt; 1] else: dp[i] = dp[i &amp;gt;&amp;gt; 1] + 1 return dp[num] </description>
    </item>
    
    <item>
      <title>279 - Perfect Squares</title>
      <link>//alfmunny.com/leetcode-blog/posts/279-perfect-squares/</link>
      <pubDate>Tue, 31 Mar 2020 00:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/279-perfect-squares/</guid>
      <description>leetcode
Problem Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Notes DP problem
  States: n
  Transition:
  dp[i] = min([_dp[i-j*j]+1 if i-j*j &amp;gt;= 0 else break for j in range(1, sqrt(i)+1)])   Base case:</description>
    </item>
    
    <item>
      <title>309 - Best Time to Buy and Sell Stock with Cooldown</title>
      <link>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Tue, 24 Mar 2020 22:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>188 - Best Time to Buy and Sell Stock IV</title>
      <link>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</link>
      <pubDate>Tue, 24 Mar 2020 21:46:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</guid>
      <description>leetcode
Problem Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</description>
    </item>
    
    <item>
      <title>123 - Best Time to Buy and Sell Stock III</title>
      <link>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Tue, 24 Mar 2020 18:25:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</description>
    </item>
    
    <item>
      <title>85 - Maximal Rectangle</title>
      <link>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</link>
      <pubDate>Tue, 24 Mar 2020 00:57:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</guid>
      <description>Problem Notes Solution  leetcode
Problem Given a 2D binary matrix filled with 0&amp;#39;s and 1&amp;#39;s, find the largest rectangle containing only 1&amp;#39;s and return its area. Example: Input: [ [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;] ] Output: 6 Notes Two parts:
 generate a heights histogram for every row. apple &amp;ldquo;largest rectangle in histogram&amp;rdquo; on each row of histogram  Solution class Solution: def maximalRectangle(self, matrix): if not matrix or not matrix[0]: return 0 m = len(matrix) n = len(matrix[0]) histograms = [[0] * n for i in range(m)] res = 0 for i in range(m): for j in range(n): if matrix[i][j] == &amp;#34;1&amp;#34;: histograms[i][j] = histograms[i - 1][j] + 1 if i &amp;gt; 0 else 1 for histogram in histograms: res = max(res, self.</description>
    </item>
    
    <item>
      <title>84 - Largest Rectangle in Histogram</title>
      <link>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</link>
      <pubDate>Mon, 23 Mar 2020 00:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</guid>
      <description>leetcode
Problem Given n non-negative integers representing the histogram&amp;#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Example: Input: [2,1,5,6,2,3] Output: 10 Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
The largest rectangle is shown in the shaded area, which has area = 10 unit.
Notes Main idea is to caculate both left edge and right edge for every entry in the array</description>
    </item>
    
  </channel>
</rss>