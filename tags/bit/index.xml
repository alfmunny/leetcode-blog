<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bit on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/bit/</link>
    <description>Recent content in bit on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 18 Jul 2020 00:30:00 +0200</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/bit/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>461 - Hamming Distance</title>
      <link>//alfmunny.com/leetcode-blog/posts/461-hamming-distance/</link>
      <pubDate>Sat, 18 Jul 2020 00:30:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/461-hamming-distance/</guid>
      <description>leetcode
Problem The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y &amp;lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different.</description>
    </item>
    
    <item>
      <title>231 - Power of Two</title>
      <link>//alfmunny.com/leetcode-blog/posts/231-power-of-two/</link>
      <pubDate>Mon, 08 Jun 2020 22:35:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/231-power-of-two/</guid>
      <description>leetcode
Problem Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true Explanation: 20 = 1 Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false Solution Solution 1: Straight forward class Solution: def powerOfTwo(self, n): while n != 1: if n % 2: return False n //= 2 return True Solution 2: Bit manipulation power of two: n = 1000000 n - 1 = 111111 n &amp;amp; (n-1) == 0</description>
    </item>
    
    <item>
      <title>1009 - Complement of Base 10 Integer</title>
      <link>//alfmunny.com/leetcode-blog/posts/1009-complement-of-base-10-integer/</link>
      <pubDate>Mon, 04 May 2020 17:59:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1009-complement-of-base-10-integer/</guid>
      <description>leetcode
Problem Every non-negative integer N has a binary representation. For example, 5 can be represented as &amp;#34;101&amp;#34; in binary, 11 as &amp;#34;1011&amp;#34; in binary, and so on. Note that except for N = 0, there are no leading zeroes in any binary representation. The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1. For example, the complement of &amp;#34;101&amp;#34; in binary is &amp;#34;010&amp;#34; in binary.</description>
    </item>
    
    <item>
      <title>201 - Bitwise AND of Numbers Range</title>
      <link>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</link>
      <pubDate>Fri, 24 Apr 2020 01:35:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</guid>
      <description>leetcode
Problem Given a range [m, n] where 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4 Example 2: Input: [0,1] Output: 0 Solution m = xxx1yyyy n = xxx01zzz
xxx is the parts that two numbers are the same. We can definitly find these two numbers in the range
m&amp;rsquo; = xxx1000 n&amp;rsquo; = xxx0100</description>
    </item>
    
    <item>
      <title>416 - Partition Equal Subset Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</link>
      <pubDate>Sun, 05 Apr 2020 21:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</guid>
      <description>leetcode
Problem Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets.</description>
    </item>
    
  </channel>
</rss>