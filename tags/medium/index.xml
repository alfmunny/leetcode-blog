<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>medium on LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/tags/medium/</link>
    <description>Recent content in medium on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 26 Aug 2020 00:00:00 +0200</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/tags/medium/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>131 - Palindrome Partitioning</title>
      <link>//alfmunny.com/leetcode-blog/posts/131-palindrome-partitioning/</link>
      <pubDate>Wed, 26 Aug 2020 00:00:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/131-palindrome-partitioning/</guid>
      <description>leetcode
Problem Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example: Input: &amp;#34;aab&amp;#34; Output: [ [&amp;#34;aa&amp;#34;,&amp;#34;b&amp;#34;], [&amp;#34;a&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;] ] Solution class Solution: def partition(self, s: str) -&amp;gt; List[List[str]]: ans = [] self.dfs(s, 0, ans, []) return ans def dfs(self, s, start, ans, path): if start == len(s): ans.append(path.copy()) return for i in range(start, len(s)): w = s[start:i+1] if w == w[::-1]: path.</description>
    </item>
    
    <item>
      <title>1219 - Path with Maximum Gold</title>
      <link>//alfmunny.com/leetcode-blog/posts/1219-path-with-maximum-gold/</link>
      <pubDate>Sun, 23 Aug 2020 19:07:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1219-path-with-maximum-gold/</guid>
      <description>leetcode
Problem In a gold mine grid of size m * n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty. Return the maximum amount of gold you can collect under the conditions: Every time you are located in a cell you will collect all the gold in that cell. From your position you can walk one step to the left, right, up or down.</description>
    </item>
    
    <item>
      <title>199 - Binary Tree Right Side View</title>
      <link>//alfmunny.com/leetcode-blog/posts/199-binary-tree-right-side-view/</link>
      <pubDate>Sun, 23 Aug 2020 17:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/199-binary-tree-right-side-view/</guid>
      <description>leetcode
Problem Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- Solution Comprare the depth. DFS.
Keep track of the current depth. And the length of current answer is the previous depth.</description>
    </item>
    
    <item>
      <title>516 - Longest Palindromic Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/516-longest-palindromic-subsequence/</link>
      <pubDate>Sat, 22 Aug 2020 12:25:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/516-longest-palindromic-subsequence/</guid>
      <description>leetcode
Problem Given a string s, find the longest palindromic subsequence&amp;#39;s length in s. You may assume that the maximum length of s is 1000. Example 1: Input: &amp;#34;bbbab&amp;#34; Output: 4 One possible longest palindromic subsequence is &amp;#34;bbbb&amp;#34;. Example 2: Input: &amp;#34;cbbd&amp;#34; Output: 2 One possible longest palindromic subsequence is &amp;#34;bb&amp;#34;. Constraints: 1 &amp;lt;= s.length &amp;lt;= 1000 s consists only of lowercase English letters. Solution DP problem.
dp[i][j] represents the max value for substring from j to i.</description>
    </item>
    
    <item>
      <title>1079 - Letter Tile Possibilities</title>
      <link>//alfmunny.com/leetcode-blog/posts/1079-letter-tile-possibilities/</link>
      <pubDate>Wed, 19 Aug 2020 20:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1079-letter-tile-possibilities/</guid>
      <description>leetcode
Problem You have n tiles, where each tile has one letter tiles[i] printed on it. Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles. Example 1: Input: tiles = &amp;#34;AAB&amp;#34; Output: 8 Explanation: The possible sequences are &amp;#34;A&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;AA&amp;#34;, &amp;#34;AB&amp;#34;, &amp;#34;BA&amp;#34;, &amp;#34;AAB&amp;#34;, &amp;#34;ABA&amp;#34;, &amp;#34;BAA&amp;#34;. Example 2: Input: tiles = &amp;#34;AAABBC&amp;#34; Output: 188 Example 3: Input: tiles = &amp;#34;V&amp;#34; Output: 1 Constraints: 1 &amp;lt;= tiles.</description>
    </item>
    
    <item>
      <title>784 - Letter Case Permutation</title>
      <link>//alfmunny.com/leetcode-blog/posts/784-letter-case-permutation/</link>
      <pubDate>Wed, 19 Aug 2020 19:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/784-letter-case-permutation/</guid>
      <description>leetcode
Problem Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create. You can return the output in any order. Example 1: Input: S = &amp;#34;a1b2&amp;#34; Output: [&amp;#34;a1b2&amp;#34;,&amp;#34;a1B2&amp;#34;,&amp;#34;A1b2&amp;#34;,&amp;#34;A1B2&amp;#34;] Example 2: Input: S = &amp;#34;3z4&amp;#34; Output: [&amp;#34;3z4&amp;#34;,&amp;#34;3Z4&amp;#34;] Example 3: Input: S = &amp;#34;12345&amp;#34; Output: [&amp;#34;12345&amp;#34;] Example 4: Input: S = &amp;#34;0&amp;#34; Output: [&amp;#34;0&amp;#34;] Constraints: S will be a string with length between 1 and 12.</description>
    </item>
    
    <item>
      <title>368 - Largest Divisible Subset</title>
      <link>//alfmunny.com/leetcode-blog/posts/368-largest-divisible-subset/</link>
      <pubDate>Wed, 19 Aug 2020 16:05:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/368-largest-divisible-subset/</guid>
      <description>leetcode
Problem Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1: Input: [1,2,3] Output: [1,2] (of course, [1,3] will also be ok) Example 2: Input: [1,2,4,8] Output: [1,2,4,8] Solution Solution 1: DP class Solution: def largestDivisibleSubset(self, nums: List[int]) -&amp;gt; List[int]: if not nums: return nums dp = [1] * len(nums) pre = [i for i in range(len(nums))] nums.</description>
    </item>
    
    <item>
      <title>114 - Flatten Binary Tree to Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/114-flatten-binary-tree-to-linked-list/</link>
      <pubDate>Wed, 19 Aug 2020 14:55:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/114-flatten-binary-tree-to-linked-list/</guid>
      <description>leetcode
Problem Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like: 1 \ 2 \ 3 \ 4 \ 5 \ 6 Solution  Traverse the tree in reverse preorder, the opposite of root-left-right. Save the root, and use it in the upper level.  class Solution: def flatten(self, root: TreeNode) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34;Do not return anything, modify root in-place instead.</description>
    </item>
    
    <item>
      <title>109 - Convert Sorted List to Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/109-convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Tue, 18 Aug 2020 16:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/109-convert-sorted-list-to-binary-search-tree/</guid>
      <description>leetcode
Problem Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Solution class Solution: def sortedListToBST(self, head: ListNode) -&amp;gt; TreeNode: if not head: return None if not head.</description>
    </item>
    
    <item>
      <title>967 - Numbers With Same Consecutive Differences</title>
      <link>//alfmunny.com/leetcode-blog/posts/967-numbers-with-same-consecutive-differences/</link>
      <pubDate>Tue, 18 Aug 2020 14:27:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/967-numbers-with-same-consecutive-differences/</guid>
      <description>leetcode
Problem Return all non-negative integers of length N such that the absolute difference between every two consecutive digits is K. Note that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid. You may return the answer in any order. Example 1: Input: N = 3, K = 7 Output: [181,292,707,818,929] Explanation: Note that 070 is not a valid number, because it has leading zeroes.</description>
    </item>
    
    <item>
      <title>142 - Reorder List</title>
      <link>//alfmunny.com/leetcode-blog/posts/142-reorder-list/</link>
      <pubDate>Tue, 18 Aug 2020 01:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/142-reorder-list/</guid>
      <description>leetcode
Problem Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list&amp;#39;s nodes, only nodes itself may be changed. Example 1: Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, reorder it to 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. Example 2: Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, reorder it to 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3. Solution class Solution: def reorderList(self, head: ListNode) -&amp;gt; None: if not head or not head.next: return fast = slow = head while fast.next and fast.next.next: fast = fast.</description>
    </item>
    
    <item>
      <title>148 - Sort List</title>
      <link>//alfmunny.com/leetcode-blog/posts/148-sort-list/</link>
      <pubDate>Mon, 17 Aug 2020 16:41:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/148-sort-list/</guid>
      <description>leetcode
Problem Sort a linked list in O(n log n) time using constant space complexity. Example 1: Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4 Example 2: Input: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0 Output: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5 Solution Merge Sort
 Slow-Fast-Pointer to split the list into half. Do not forget slow.next = None Sort two part recursively and merge together  class Solution: def sortList(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head # split in half fast = slow = head while fast.</description>
    </item>
    
    <item>
      <title>240 - Search a 2D Matrix II</title>
      <link>//alfmunny.com/leetcode-blog/posts/240-search-a-2d-matrix-ii/</link>
      <pubDate>Mon, 17 Aug 2020 03:11:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/240-search-a-2d-matrix-ii/</guid>
      <description>leetcode
Problem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example: Consider the following matrix: [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true.</description>
    </item>
    
    <item>
      <title>82 - Remove Duplicates from Sorted List II</title>
      <link>//alfmunny.com/leetcode-blog/posts/82-remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Mon, 17 Aug 2020 03:08:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/82-remove-duplicates-from-sorted-list-ii/</guid>
      <description>leetcode
Problem Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 Output: 1-&amp;gt;2-&amp;gt;5 Example 2: Input: 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3 Output: 2-&amp;gt;3 Solution class Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head extra = ListNode(None) extra.next = head pre = extra while head and head.</description>
    </item>
    
    <item>
      <title>191 - Number of 1 Bits</title>
      <link>//alfmunny.com/leetcode-blog/posts/191-number-of-1-bits/</link>
      <pubDate>Fri, 14 Aug 2020 00:01:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/191-number-of-1-bits/</guid>
      <description>leetcode
Problem Write a function that takes an unsigned integer and return the number of &amp;#39;1&amp;#39; bits it has (also known as the Hamming weight). Example 1: Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three &amp;#39;1&amp;#39; bits. Example 2: Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one &amp;#39;1&amp;#39; bit. Example 3: Input: 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &amp;#39;1&amp;#39; bits.</description>
    </item>
    
    <item>
      <title>81 - Search in Rotated Sorted Array II</title>
      <link>//alfmunny.com/leetcode-blog/posts/81-search-in-rotated-sorted-array-ii/</link>
      <pubDate>Thu, 13 Aug 2020 23:48:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/81-search-in-rotated-sorted-array-ii/</guid>
      <description>leetcode
Problem Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1: Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2: Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.</description>
    </item>
    
    <item>
      <title>80 - Remove Duplicates from Sorted Array II</title>
      <link>//alfmunny.com/leetcode-blog/posts/80-remove-duplicates-from-sorted-array-ii/</link>
      <pubDate>Thu, 13 Aug 2020 22:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/80-remove-duplicates-from-sorted-array-ii/</guid>
      <description>leetcode
Problem Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</description>
    </item>
    
    <item>
      <title>73 - Set Matrix Zeroes</title>
      <link>//alfmunny.com/leetcode-blog/posts/73-set-matrix-zeroes/</link>
      <pubDate>Thu, 13 Aug 2020 21:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/73-set-matrix-zeroes/</guid>
      <description>leetcode
Problem Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place. Example 1: Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2: Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] Follow up: A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution.</description>
    </item>
    
    <item>
      <title>71 - Simplify Path</title>
      <link>//alfmunny.com/leetcode-blog/posts/71-simplify-path/</link>
      <pubDate>Thu, 13 Aug 2020 18:18:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/71-simplify-path/</guid>
      <description>leetcode
Problem Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path. In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names.</description>
    </item>
    
    <item>
      <title>36 - Valid Sudoku</title>
      <link>//alfmunny.com/leetcode-blog/posts/36-valid-sudoku/</link>
      <pubDate>Sun, 12 Jul 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/36-valid-sudoku/</guid>
      <description>leetcode
Problem Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solution class Solution: def isValidSudoku(self, board: List[List[str]]) -&amp;gt; bool: for row in board: nums = [x for x in row if x !</description>
    </item>
    
    <item>
      <title>695 - Max Area of Island</title>
      <link>//alfmunny.com/leetcode-blog/posts/695-max-area-of-island/</link>
      <pubDate>Tue, 07 Jul 2020 16:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/695-max-area-of-island/</guid>
      <description>leetcode
Problem Given a non-empty 2D array grid of 0&amp;#39;s and 1&amp;#39;s, an island is a group of 1&amp;#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6.</description>
    </item>
    
    <item>
      <title>332 - Reconstruct Itinerary</title>
      <link>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinerary/</link>
      <pubDate>Mon, 29 Jun 2020 23:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinerary/</guid>
      <description>leetcode
Problem Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&amp;#34;JFK&amp;#34;, &amp;#34;LGA&amp;#34;] has a smaller lexical order than [&amp;#34;JFK&amp;#34;, &amp;#34;LGB&amp;#34;].</description>
    </item>
    
    <item>
      <title>332 - Reconstruct Itinrary</title>
      <link>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinrary/</link>
      <pubDate>Mon, 29 Jun 2020 23:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinrary/</guid>
      <description>leetcode
Problem Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&amp;#34;JFK&amp;#34;, &amp;#34;LGA&amp;#34;] has a smaller lexical order than [&amp;#34;JFK&amp;#34;, &amp;#34;LGB&amp;#34;].</description>
    </item>
    
    <item>
      <title>263 - Ugly Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/263-ugly-number/</link>
      <pubDate>Sat, 27 Jun 2020 23:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/263-ugly-number/</guid>
      <description>leetcode
Problem Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2 Example 3: Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7.</description>
    </item>
    
    <item>
      <title>264 - Ugly Number II</title>
      <link>//alfmunny.com/leetcode-blog/posts/264-ugly-number-ii/</link>
      <pubDate>Sat, 27 Jun 2020 23:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/264-ugly-number-ii/</guid>
      <description>leetcode
Problem Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note: 1 is typically treated as an ugly number. n does not exceed 1690. Solution class Solution: ugly = sorted(2**a * 3**b * 5**c for a in range(32) for b in range(32) for c in range(32)) def nthUglyNumber(self, n: int) -&amp;gt; int: return self.</description>
    </item>
    
    <item>
      <title>988 - Smallest String Starting From Leaf</title>
      <link>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</link>
      <pubDate>Sat, 27 Jun 2020 15:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</guid>
      <description>leetcode
Problem Given the root of a binary tree, each node has a value from 0 to 25 representing the letters &amp;#39;a&amp;#39; to &amp;#39;z&amp;#39;: a value of 0 represents &amp;#39;a&amp;#39;, a value of 1 represents &amp;#39;b&amp;#39;, and so on. Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root. (As a reminder, any shorter prefix of a string is lexicographically smaller: for example, &amp;#34;ab&amp;#34; is lexicographically smaller than &amp;#34;aba&amp;#34;.</description>
    </item>
    
    <item>
      <title>130 - Surrounded Regions</title>
      <link>//alfmunny.com/leetcode-blog/posts/130-surrounded-regions/</link>
      <pubDate>Fri, 26 Jun 2020 01:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/130-surrounded-regions/</guid>
      <description>leetcode
Problem Given a 2D board containing &amp;#39;X&amp;#39; and &amp;#39;O&amp;#39; (the letter O), capture all regions surrounded by &amp;#39;X&amp;#39;. A region is captured by flipping all &amp;#39;O&amp;#39;s into &amp;#39;X&amp;#39;s in that surrounded region. Example: X X X X X O O X X X O X X O X X After running your function, the board should be: X X X X X X X X X X X X X O X X Explanation: Surrounded regions shouldn’t be on the border, which means that any &amp;#39;O&amp;#39; on the border of the board are not flipped to &amp;#39;X&amp;#39;.</description>
    </item>
    
    <item>
      <title>95 - Unique Binary Search Trees II</title>
      <link>//alfmunny.com/leetcode-blog/posts/95-unique-binary-search-treea-ii/</link>
      <pubDate>Sat, 20 Jun 2020 02:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/95-unique-binary-search-treea-ii/</guid>
      <description>leetcode
Problem Given an integer n, generate all structurally unique BST&amp;#39;s (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST&amp;#39;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 Solution class Solution: def generateTrees(self, n: int) -&amp;gt; List[TreeNode]: if n == 0: return [] return self.</description>
    </item>
    
    <item>
      <title>162 - Find Peak Element</title>
      <link>//alfmunny.com/leetcode-blog/posts/162-find-peak-element/</link>
      <pubDate>Thu, 18 Jun 2020 16:09:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/162-find-peak-element/</guid>
      <description>leetcode
Problem A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
    
    <item>
      <title>74 - Search a 2D Matrix</title>
      <link>//alfmunny.com/leetcode-blog/posts/74-search-a-2d-matrix/</link>
      <pubDate>Thu, 18 Jun 2020 14:46:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/74-search-a-2d-matrix/</guid>
      <description>leetcode
Problem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false Solution class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: if not matrix or not matrix[0]: return False rl, rr = 0, len(matrix) - 1 cl, cr = 0, len(matrix[0]) - 1 while rl &amp;lt;= rr: mid = (rl + rr) // 2 if target &amp;lt; matrix[mid][0]: rr = mid - 1 elif target &amp;gt; matrix[mid][-1]: rl = mid + 1 else: rl = mid break if rl &amp;gt; rr: return False while cl &amp;lt;= cr: mid = (cl + cr) // 2 if target &amp;lt; matrix[rl][mid]: cr = mid - 1 elif target &amp;gt; matrix[rl][mid]: cl = mid + 1 else: return True return False </description>
    </item>
    
    <item>
      <title>63 - Unique Paths II</title>
      <link>//alfmunny.com/leetcode-blog/posts/63-unique-paths-ii/</link>
      <pubDate>Thu, 18 Jun 2020 14:25:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/63-unique-paths-ii/</guid>
      <description>leetcode
Problem A robot is located at the top-left corner of a m x n grid (marked &amp;#39;Start&amp;#39; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;#39;Finish&amp;#39; in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?</description>
    </item>
    
    <item>
      <title>61 - Rotate List</title>
      <link>//alfmunny.com/leetcode-blog/posts/61-rotate-list/</link>
      <pubDate>Thu, 18 Jun 2020 14:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/61-rotate-list/</guid>
      <description>leetcode
Problem Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 Output: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Explanation: rotate 1 steps to the right: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL rotate 2 steps to the right: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Example 2: Input: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL, k = 4 Output: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Explanation: rotate 1 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL rotate 2 steps to the right: 1-&amp;gt;2-&amp;gt;0-&amp;gt;NULL rotate 3 steps to the right: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL rotate 4 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Solution Note: k may be larger than the total count of nodes.</description>
    </item>
    
    <item>
      <title>59 - Spiral Matrix II</title>
      <link>//alfmunny.com/leetcode-blog/posts/59-spiral-matrix-ii/</link>
      <pubDate>Thu, 18 Jun 2020 13:59:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/59-spiral-matrix-ii/</guid>
      <description>leetcode
Problem Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] Solution class Solution: def generateMatrix(self, n: int) -&amp;gt; List[List[int]]: matrix = [[0] * n for _ in range(n)] step = [[0,1], [1, 0], [0, -1], [-1, 0]] i = j = di = 0 for x in range(1, n * n+1): matrix[i][j] = x ni = i + step[di][0] nj = j + step[di][1] if 0 &amp;lt;= ni &amp;lt; n and 0 &amp;lt;= nj &amp;lt; n and not matrix[ni][nj]: i, j = ni, nj else: di = (di + 1) % 4 i, j = i + step[di][0], j + step[di][1] return matrix </description>
    </item>
    
    <item>
      <title>113 - Path Sum II</title>
      <link>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</link>
      <pubDate>Wed, 17 Jun 2020 23:51:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</guid>
      <description>leetcode
Problem Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;#39;s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] Solution class Solution: def pathSum(self, root: TreeNode, sum: int) -&amp;gt; List[List[int]]: ans = [] self.</description>
    </item>
    
    <item>
      <title>90 - Subsets II</title>
      <link>//alfmunny.com/leetcode-blog/posts/90-subsets-ii/</link>
      <pubDate>Wed, 17 Jun 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/90-subsets-ii/</guid>
      <description>leetcode
Problem Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] Solution class Solution: def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]: ans = [] marked = [False] * len(nums) self.dfs(sorted(nums), 0, [], ans, marked) return ans def dfs(self, nums, index, path, ans, marked): ans.</description>
    </item>
    
    <item>
      <title>77 - Combinations</title>
      <link>//alfmunny.com/leetcode-blog/posts/77-combinations/</link>
      <pubDate>Fri, 12 Jun 2020 17:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/77-combinations/</guid>
      <description>leetcode
Problem Share Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] Solution class Solution: def combine(self, n: int, k: int) -&amp;gt; List[List[int]]: ans = [] self.dfs(1, n, k, [], ans) return ans def dfs(self, index, n, k, path, ans): if k == 0: ans.</description>
    </item>
    
    <item>
      <title>17 - Letter Combinations of a Phone Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/17-letter-combinations-of-a-phone-number/</link>
      <pubDate>Thu, 11 Jun 2020 16:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/17-letter-combinations-of-a-phone-number/</guid>
      <description>leetcode
Problem Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: &amp;#34;23&amp;#34; Output: [&amp;#34;ad&amp;#34;, &amp;#34;ae&amp;#34;, &amp;#34;af&amp;#34;, &amp;#34;bd&amp;#34;, &amp;#34;be&amp;#34;, &amp;#34;bf&amp;#34;, &amp;#34;cd&amp;#34;, &amp;#34;ce&amp;#34;, &amp;#34;cf&amp;#34;]. Solution Solution 1: DFS class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: m = { 2: &amp;#34;abc&amp;#34;, 3: &amp;#34;def&amp;#34;, 4: &amp;#34;ghi&amp;#34;, 5: &amp;#34;jkl&amp;#34;, 6: &amp;#34;mno&amp;#34;, 7: &amp;#34;pqrs&amp;#34;, 8: &amp;#34;tuv&amp;#34;, 9: &amp;#34;wxyz&amp;#34; } ans = [] self.</description>
    </item>
    
    <item>
      <title>216 - Combination Sum III</title>
      <link>//alfmunny.com/leetcode-blog/posts/216-combination-sum-iii/</link>
      <pubDate>Thu, 11 Jun 2020 15:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/216-combination-sum-iii/</guid>
      <description>leetcode
Problem Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] Solution class Solution: def combinationSum3(self, k: int, n: int) -&amp;gt; List[List[int]]: ans = [] self.</description>
    </item>
    
    <item>
      <title>377 - Combination Sum IV</title>
      <link>//alfmunny.com/leetcode-blog/posts/337-combination-sum-iv/</link>
      <pubDate>Thu, 11 Jun 2020 15:12:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/337-combination-sum-iv/</guid>
      <description>leetcode
Problem Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4 The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Note that different sequences are counted as different combinations. Therefore the output is 7.</description>
    </item>
    
    <item>
      <title>39 - Combination Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/39-combination-sum/</link>
      <pubDate>Wed, 10 Jun 2020 23:55:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/39-combination-sum/</guid>
      <description>leetcode
Problem Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] Solution Backtracking problem.</description>
    </item>
    
    <item>
      <title>40 - Combination Sum II</title>
      <link>//alfmunny.com/leetcode-blog/posts/40-combination-sum-ii/</link>
      <pubDate>Wed, 10 Jun 2020 23:33:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/40-combination-sum-ii/</guid>
      <description>leetcode
Problem Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ] Solution Backtracking problem.</description>
    </item>
    
    <item>
      <title>392 - Is Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/392-is-subsequence/</link>
      <pubDate>Tue, 09 Jun 2020 23:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/392-is-subsequence/</guid>
      <description>leetcode
Problem Given a string s and a string t, check if s is subsequence of t. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &amp;#34;ace&amp;#34; is a subsequence of &amp;#34;abcde&amp;#34; while &amp;#34;aec&amp;#34; is not). Follow up: If there are lots of incoming S, say S1, S2, .</description>
    </item>
    
    <item>
      <title>213 - House Robber II</title>
      <link>//alfmunny.com/leetcode-blog/posts/213-house-robber-ii/</link>
      <pubDate>Mon, 08 Jun 2020 23:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/213-house-robber-ii/</guid>
      <description>leetcode
Problem You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>406 - Queue Reconstruction by Height</title>
      <link>//alfmunny.com/leetcode-blog/posts/406-queue-reconstruction-by-height/</link>
      <pubDate>Mon, 08 Jun 2020 22:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/406-queue-reconstruction-by-height/</guid>
      <description>leetcode
Problem Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of people is less than 1,100.</description>
    </item>
    
    <item>
      <title>518 - Coin Change 2</title>
      <link>//alfmunny.com/leetcode-blog/posts/518-coin-change-2/</link>
      <pubDate>Sun, 07 Jun 2020 21:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/518-coin-change-2/</guid>
      <description>leetcode
Problem You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.</description>
    </item>
    
    <item>
      <title>528 - Random Pick with Weight</title>
      <link>//alfmunny.com/leetcode-blog/posts/528-random-pick-with-weight/</link>
      <pubDate>Fri, 05 Jun 2020 22:00:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/528-random-pick-with-weight/</guid>
      <description>leetcode
Problem Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note: 1 &amp;lt;= w.length &amp;lt;= 10000 1 &amp;lt;= w[i] &amp;lt;= 10^5 pickIndex will be called at most 10000 times. Example 1: Input: [&amp;#34;Solution&amp;#34;,&amp;#34;pickIndex&amp;#34;] [[[1]],[]] Output: [null,0] Example 2: Input: [&amp;#34;Solution&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0] Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments.</description>
    </item>
    
    <item>
      <title>973 - K Closest Points to Origin</title>
      <link>//alfmunny.com/leetcode-blog/posts/973-k-closest-points-to-origin/</link>
      <pubDate>Sat, 30 May 2020 23:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/973-k-closest-points-to-origin/</guid>
      <description>leetcode
Problem We have a list of points on the plane. Find the K closest points to the origin (0, 0). (Here, the distance between two points on a plane is the Euclidean distance.) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.) Example 1: Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10).</description>
    </item>
    
    <item>
      <title>210 - Course Schedule II</title>
      <link>//alfmunny.com/leetcode-blog/posts/210-course-schedule-ii/</link>
      <pubDate>Fri, 29 May 2020 20:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/210-course-schedule-ii/</guid>
      <description>leetcode
Problem There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them.</description>
    </item>
    
    <item>
      <title>207 - Course Schedule</title>
      <link>//alfmunny.com/leetcode-blog/posts/207-course-schedule/</link>
      <pubDate>Fri, 29 May 2020 19:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/207-course-schedule/</guid>
      <description>leetcode
Problem There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take.</description>
    </item>
    
    <item>
      <title>886 - Possible Bipartition</title>
      <link>//alfmunny.com/leetcode-blog/posts/886-possible-bipartition/</link>
      <pubDate>Wed, 27 May 2020 16:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/886-possible-bipartition/</guid>
      <description>leetcode
Problem Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.</description>
    </item>
    
    <item>
      <title>1035 - Uncrossed Lines</title>
      <link>//alfmunny.com/leetcode-blog/posts/1035-uncrossed-lines/</link>
      <pubDate>Mon, 25 May 2020 16:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1035-uncrossed-lines/</guid>
      <description>leetcode
Problem We write the integers of A and B (in the order they are given) on two separate horizontal lines. Now, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j] such that: A[i] == B[j]; The line we draw does not intersect any other connecting (non-horizontal) line. Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</description>
    </item>
    
    <item>
      <title>986 - Interval List Intersections</title>
      <link>//alfmunny.com/leetcode-blog/posts/996-interval-list-intersections/</link>
      <pubDate>Sun, 24 May 2020 01:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/996-interval-list-intersections/</guid>
      <description>leetcode
Problem Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a &amp;lt;= b) denotes the set of real numbers x with a &amp;lt;= x &amp;lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.</description>
    </item>
    
    <item>
      <title>451 - Sort Characters By Frequency</title>
      <link>//alfmunny.com/leetcode-blog/posts/451-sort-characters-by-frequency/</link>
      <pubDate>Fri, 22 May 2020 14:19:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/451-sort-characters-by-frequency/</guid>
      <description>leetcode
Problem Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: &amp;#34;tree&amp;#34; Output: &amp;#34;eert&amp;#34; Explanation: &amp;#39;e&amp;#39; appears twice while &amp;#39;r&amp;#39; and &amp;#39;t&amp;#39; both appear once. So &amp;#39;e&amp;#39; must appear before both &amp;#39;r&amp;#39; and &amp;#39;t&amp;#39;. Therefore &amp;#34;eetr&amp;#34; is also a valid answer. Example 2: Input: &amp;#34;cccaaa&amp;#34; Output: &amp;#34;cccaaa&amp;#34; Explanation: Both &amp;#39;c&amp;#39; and &amp;#39;a&amp;#39; appear three times, so &amp;#34;aaaccc&amp;#34; is also a valid answer. Note that &amp;#34;cacaca&amp;#34; is incorrect, as the same characters must be together.</description>
    </item>
    
    <item>
      <title>1277 - Count Square Submatrices with All Ones</title>
      <link>//alfmunny.com/leetcode-blog/posts/1227-count-square-submatrices-with-all-ones/</link>
      <pubDate>Fri, 22 May 2020 00:01:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1227-count-square-submatrices-with-all-ones/</guid>
      <description>leetcode
Problem Given a m * n matrix of ones and zeros, return how many square submatrices have all ones. Example 1: Input: matrix = [ [0,1,1,1], [1,1,1,1], [0,1,1,1] ] Output: 15 Explanation: There are 10 squares of side 1. There are 4 squares of side 2. There is 1 square of side 3. Total number of squares = 10 + 4 + 1 = 15. Example 2: Input: matrix = [ [1,0,1], [1,1,0], [1,1,0] ] Output: 7 Explanation: There are 6 squares of side 1.</description>
    </item>
    
    <item>
      <title>230 - Kth Smallest Element in a BST</title>
      <link>//alfmunny.com/leetcode-blog/posts/230-kth-smallest-element-in-a-bst/</link>
      <pubDate>Wed, 20 May 2020 22:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/230-kth-smallest-element-in-a-bst/</guid>
      <description>leetcode
Problem 230. Kth Smallest Element in a BST Medium 2239 57 Add to List Share Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 ≤ k ≤ BST&amp;#39;s total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 Output: 3 Solution class Solution: def kthSmallest(self, root): self.</description>
    </item>
    
    <item>
      <title>901 - Onine Stock Span</title>
      <link>//alfmunny.com/leetcode-blog/posts/901-online-stock-span/</link>
      <pubDate>Tue, 19 May 2020 21:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/901-online-stock-span/</guid>
      <description>leetcode
Problem Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock&amp;#39;s price for the current day. The span of the stock&amp;#39;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today&amp;#39;s price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].</description>
    </item>
    
    <item>
      <title>567 - Permutation in String</title>
      <link>//alfmunny.com/leetcode-blog/posts/567-permutation-in-string/</link>
      <pubDate>Mon, 18 May 2020 18:14:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/567-permutation-in-string/</guid>
      <description>leetcode
Problem Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string&amp;#39;s permutations is the substring of the second string. Example 1: Input: s1 = &amp;#34;ab&amp;#34; s2 = &amp;#34;eidbaooo&amp;#34; Output: True Explanation: s2 contains one permutation of s1 (&amp;#34;ba&amp;#34;). Example 2: Input:s1= &amp;#34;ab&amp;#34; s2 = &amp;#34;eidboaoo&amp;#34; Output: False Note: The input strings only contain lower case letters.</description>
    </item>
    
    <item>
      <title>438 - Find All Anagrams in a String</title>
      <link>//alfmunny.com/leetcode-blog/posts/438-find-all-anagrams-in-a-string/</link>
      <pubDate>Mon, 18 May 2020 05:08:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/438-find-all-anagrams-in-a-string/</guid>
      <description>leetcode
Problem Given a string s and a non-empty string p, find all the start indices of p&amp;#39;s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: &amp;#34;cbaebabacd&amp;#34; p: &amp;#34;abc&amp;#34; Output: [0, 6] Explanation: The substring with start index = 0 is &amp;#34;cba&amp;#34;, which is an anagram of &amp;#34;abc&amp;#34;.</description>
    </item>
    
    <item>
      <title>328 - Odd Even Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/328-odd-even-linked-list/</link>
      <pubDate>Sat, 16 May 2020 17:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/328-odd-even-linked-list/</guid>
      <description>leetcode
Problem Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL Example 2: Input: 2-&amp;gt;1-&amp;gt;3-&amp;gt;5-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;NULL Output: 2-&amp;gt;3-&amp;gt;6-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;4-&amp;gt;NULL Note: The relative order inside both the even and odd groups should remain as it was in the input.</description>
    </item>
    
    <item>
      <title>918 - Maximum Sum Circular Subarray</title>
      <link>//alfmunny.com/leetcode-blog/posts/918-maximum-sum-circular-subarray/</link>
      <pubDate>Fri, 15 May 2020 22:27:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/918-maximum-sum-circular-subarray/</guid>
      <description>leetcode
Problem  Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.
Here, a circular array means the end of the array connects to the beginning of the array. (Formally, C[i] = A[i] when 0 &amp;lt;= i &amp;lt; A.length, and C[i+A.length] = C[i] when i &amp;gt;= 0.)
Also, a subarray may only include each element of the fixed buffer A at most once.</description>
    </item>
    
    <item>
      <title>208 - Implement Trie (Prefix Tree)</title>
      <link>//alfmunny.com/leetcode-blog/posts/208-implement-trie/</link>
      <pubDate>Thu, 14 May 2020 21:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/208-implement-trie/</guid>
      <description>leetcode
Problem  Implement a trie with insert, search, and startsWith methods.
Example:
Trie trie = new Trie();
trie.insert(&amp;ldquo;apple&amp;rdquo;); trie.search(&amp;ldquo;apple&amp;rdquo;); / returns true trie.search(&amp;ldquo;app&amp;rdquo;); / returns false trie.startsWith(&amp;ldquo;app&amp;rdquo;); // returns true trie.insert(&amp;ldquo;app&amp;rdquo;); trie.search(&amp;ldquo;app&amp;rdquo;); // returns true
 Solution Trie.
Use a &amp;ldquo;END&amp;rdquo; Symbol for word ending.
search method checks for &amp;ldquo;END&amp;rdquo;, startsWith not.
class Trie: def __init__(self): self.root = Node() def search(self, s): node = self.root for c in s: node = node.</description>
    </item>
    
    <item>
      <title>402 - Remove K Digits</title>
      <link>//alfmunny.com/leetcode-blog/posts/402-remove-k-digits/</link>
      <pubDate>Wed, 13 May 2020 22:26:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/402-remove-k-digits/</guid>
      <description>leetcode
Problem  Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.
Example 1:
Input: num = &amp;ldquo;1432219&amp;rdquo;, k = 3 Output: &amp;ldquo;1219&amp;rdquo; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description>
    </item>
    
    <item>
      <title>540 - Single Element in a Sorted Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/540-single-element-in-a-sorted-array/</link>
      <pubDate>Tue, 12 May 2020 18:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/540-single-element-in-a-sorted-array/</guid>
      <description>leetcode
Problem  You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.
Example 1:
Input: [1,1,2,3,3,4,4,8,8] Output: 2
Example 2:
Input: [3,3,7,7,10,11,11] Output: 10
 Solution class Solution: def singleNonDuplicate(self, nums): lo = 0 hi = len(nums) - 1 while lo &amp;lt; hi: mid = (lo + hi) // 2 if mid == 0: return mid if (mid - lo + 1) % 2 == 0: if nums[mid] == nums[mid - 1]: lo = mid + 1 else: hi = mid - 1 else: if nums[mid] == nums[mid - 1]: hi = mid - 2 else: lo = mid return nums[lo] print(Solution().</description>
    </item>
    
    <item>
      <title>Cousins in Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/counsins-in-binary-tree/</link>
      <pubDate>Thu, 07 May 2020 21:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/counsins-in-binary-tree/</guid>
      <description>leetcode
Problem In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins.</description>
    </item>
    
    <item>
      <title>337 - House Robber III</title>
      <link>//alfmunny.com/leetcode-blog/posts/337-house-robber-ii/</link>
      <pubDate>Wed, 06 May 2020 17:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/337-house-robber-ii/</guid>
      <description>leetcode
Problem The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;#34;root.&amp;#34; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;#34;all houses in this place forms a binary tree&amp;#34;. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description>
    </item>
    
    <item>
      <title>98 - Validate Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/98-validate-binary-search-tree/</link>
      <pubDate>Sat, 02 May 2020 17:19:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/98-validate-binary-search-tree/</guid>
      <description>leetcode
Problem Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: - The left subtree of a node contains only nodes with keys less than the node&amp;#39;s key. - The right subtree of a node contains only nodes with keys greater than the node&amp;#39;s key. - Both the left and right subtrees must also be binary search trees. Example 1: 2 / \ 1 3 Input: [2,1,3] Output: true Example 2: 5 / \ 1 4 / \ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node&amp;#39;s value is 5 but its right child&amp;#39;s value is 4.</description>
    </item>
    
    <item>
      <title>106 - Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Sat, 02 May 2020 00:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>leetcode
Problem Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution The problem is almost the same as 105 Construct BT from Preorder and Inorder. Notes can be found there.
class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&amp;gt; TreeNode: if inorder: node = TreeNode(postorder.</description>
    </item>
    
    <item>
      <title>105 - Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Sat, 02 May 2020 00:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>leetcode
Problem Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution  The first node of the preorder is always the root. Find the root in the inorder array, split it there.</description>
    </item>
    
    <item>
      <title>1143 - Longest Common Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/1143-longest-common-subsequence/</link>
      <pubDate>Mon, 27 Apr 2020 14:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1143-longest-common-subsequence/</guid>
      <description>leetcode
Problem Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, &amp;#34;ace&amp;#34; is a subsequence of &amp;#34;abcde&amp;#34; while &amp;#34;aec&amp;#34; is not). A common subsequence of two strings is a subsequence that is common to both strings.</description>
    </item>
    
    <item>
      <title>437 - Path Sum III</title>
      <link>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</link>
      <pubDate>Sun, 26 Apr 2020 15:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</guid>
      <description>leetcode
Problem You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</description>
    </item>
    
    <item>
      <title>146 - LRU Cache</title>
      <link>//alfmunny.com/leetcode-blog/posts/146-lru-cache/</link>
      <pubDate>Sat, 25 Apr 2020 00:17:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/146-lru-cache/</guid>
      <description>leetcode
Problem Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>201 - Bitwise AND of Numbers Range</title>
      <link>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</link>
      <pubDate>Fri, 24 Apr 2020 01:35:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</guid>
      <description>leetcode
Problem Given a range [m, n] where 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4 Example 2: Input: [0,1] Output: 0 Solution m = xxx1yyyy n = xxx01zzz
xxx is the parts that two numbers are the same. We can definitly find these two numbers in the range
m&amp;rsquo; = xxx1000 n&amp;rsquo; = xxx0100</description>
    </item>
    
    <item>
      <title>560 Subarray Sum Equals K</title>
      <link>//alfmunny.com/leetcode-blog/posts/560-subarray-sum-equals-k/</link>
      <pubDate>Thu, 23 Apr 2020 01:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/560-subarray-sum-equals-k/</guid>
      <description>leetcode
Problem Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. Solution class Solution: def subArraySum(self, nums, k): h = {0: 1} s = 0 ans = 0 for i in nums: s += i ans += h.</description>
    </item>
    
    <item>
      <title>Leftmost Column with at Least a One</title>
      <link>//alfmunny.com/leetcode-blog/posts/leftmost-column-with-at-least-a-one/</link>
      <pubDate>Wed, 22 Apr 2020 01:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/leftmost-column-with-at-least-a-one/</guid>
      <description>leetcode
Problem A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn&amp;#39;t exist, return -1. You can&amp;#39;t access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface: BinaryMatrix.get(x, y) returns the element of the matrix at index (x, y) (0-indexed).</description>
    </item>
    
    <item>
      <title>1008 - Construct Binary Search Tree from Preorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/1008-construct-binary-search-tree-from-preorder-traversal/</link>
      <pubDate>Tue, 21 Apr 2020 07:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1008-construct-binary-search-tree-from-preorder-traversal/</guid>
      <description>leetcode
Problem Return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &amp;lt; node.val, and any descendant of node.right has a value &amp;gt; node.val. Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.) Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12] Solution We keep track of a low bound for the function.</description>
    </item>
    
    <item>
      <title>46 - Permutations</title>
      <link>//alfmunny.com/leetcode-blog/posts/46-permutations/</link>
      <pubDate>Sun, 19 Apr 2020 02:11:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/46-permutations/</guid>
      <description>leetcode
Problem Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] Solution Solution 1 class Solution: def permute(self, nums): ans = [] self.backtrack([], nums, ans) return ans def backtrack(self, path, nums, ans): if not nums: ans.append(path[:]) return for i, v in enumerate(nums): self.backtrack(path+[v], nums[:i]+nums[i+1:], ans) Solution 2 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: ans = [] marked = [False] * len(nums) self.</description>
    </item>
    
    <item>
      <title>47 - Permutations II</title>
      <link>//alfmunny.com/leetcode-blog/posts/47-permutations-ii/</link>
      <pubDate>Sun, 19 Apr 2020 01:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/47-permutations-ii/</guid>
      <description>leetcode
Problem Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] Solution Backtrack problem.
Framework of backtrack problem:
 choose a path selection pool return condition  ans = [] def backtrack(path, pool): if meet condition: ans.add(path) return for selection in pool: path.add(selection) backtrack(path, new_pool) path.remove(selection) Important:
Pay attention, you must add a copy of the path to result, not the path it self.</description>
    </item>
    
    <item>
      <title>200 - Number of Islands</title>
      <link>//alfmunny.com/leetcode-blog/posts/200-numebr-of-islands/</link>
      <pubDate>Fri, 17 Apr 2020 17:01:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/200-numebr-of-islands/</guid>
      <description>leetcode
Problem Given a 2d grid map of &amp;#39;1&amp;#39;s (land) and &amp;#39;0&amp;#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3 Solution DFS problem. Straight forward.</description>
    </item>
    
    <item>
      <title>678 - Valid Parenthesis String</title>
      <link>//alfmunny.com/leetcode-blog/posts/678-valid-parenthesis-string/</link>
      <pubDate>Thu, 16 Apr 2020 23:07:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/678-valid-parenthesis-string/</guid>
      <description>leetcode
Problem Given a string containing only three types of characters: &amp;#39;(&amp;#39;, &amp;#39;)&amp;#39; and &amp;#39;*&amp;#39;, write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis &amp;#39;(&amp;#39; must have a corresponding right parenthesis &amp;#39;)&amp;#39;. Any right parenthesis &amp;#39;)&amp;#39; must have a corresponding left parenthesis &amp;#39;(&amp;#39;. Left parenthesis &amp;#39;(&amp;#39; must go before the corresponding right parenthesis &amp;#39;)&amp;#39;. &amp;#39;*&amp;#39; could be treated as a single right parenthesis &amp;#39;)&amp;#39; or a single left parenthesis &amp;#39;(&amp;#39; or an empty string.</description>
    </item>
    
    <item>
      <title>525 - Contiguous Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/525-contiguous-array/</link>
      <pubDate>Mon, 13 Apr 2020 23:06:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/525-contiguous-array/</guid>
      <description>leetcode
Problem Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000.</description>
    </item>
    
    <item>
      <title>215 - Kth Largest Element in an Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/215-kth-largest-element-in-an-array/</link>
      <pubDate>Mon, 06 Apr 2020 01:05:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/215-kth-largest-element-in-an-array/</guid>
      <description>leetcode
Problem 215. Kth Largest Element in an Array Medium 3152 222 Add to List Share Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note: You may assume k is always valid, 1 ≤ k ≤ array&amp;#39;s length.</description>
    </item>
    
    <item>
      <title>416 - Partition Equal Subset Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</link>
      <pubDate>Sun, 05 Apr 2020 21:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</guid>
      <description>leetcode
Problem Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets.</description>
    </item>
    
    <item>
      <title>494 - Target Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/494-target-sum/</link>
      <pubDate>Sat, 04 Apr 2020 16:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/494-target-sum/</guid>
      <description>leetcode
Problem You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.</description>
    </item>
    
    <item>
      <title>338 - Counting Bits</title>
      <link>//alfmunny.com/leetcode-blog/posts/338-counting-bit/</link>
      <pubDate>Thu, 02 Apr 2020 17:03:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/338-counting-bit/</guid>
      <description>leetcode
Problem Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;#39;s in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Notes DP problem
 States: index Transition:  dp[0] = 0 dp[1] = dp[1-1] + 1 = 1 dp[2] = dp[2-2] + 1 = 1 dp[3] = dp[3-2] + 1 = 2 dp[4] = dp[4-4] + 1 = 1 dp[5] = dp[5-4] + 1 = 2 dp[6] = dp[6-4] + 1 = 2 dp[7] = dp[7-4] + 1 = 3 dp[8] = dp[8-8] + 1 = 1 dp[9] = dp[9-8] + 1 = 2 dp[i] = dp[i - log_2 (i)] + 1 A trick using bit manipulation: 8 -&amp;gt; 1000 9 -&amp;gt; 1001 10 -&amp;gt; 1010 9 &amp;amp; 8 -&amp;gt; 1001 &amp;amp; 1000 -&amp;gt; 1000 dp[8] + 1 = 2 10 &amp;amp; 9 -&amp;gt; 1010 &amp;amp; 1001 -&amp;gt; 1000 dp[8] + 1 = 2 11 &amp;amp; 10 -&amp;gt; 1011 &amp;amp; 1010 -&amp;gt; 1010 dp[10] + 1 = 3 12 &amp;amp; 11 -&amp;gt; 1100 &amp;amp; 1011 -&amp;gt; 1000 dp[8] + 1 = 2 dp[i] = dp[i &amp;amp; (i-1)] + 1 Solution Solution 1: DP class Solution: def countBits(self, num): offset = 1 dp = [0] * (num + 1) for i in range(1, num + 1): if offset * 2 == i: offset *= 2 dp[i] = dp[i - offset] + 1 return dp Solution 2: Bit manipulation on couting bits class Solution: def countBits(self, num): dp = [0] * (num + 1) for i in range(1, num + 1): dp[i] = dp[i &amp;amp; (i - 1)] + 1 return dp Solution 3: class Solution(object): def countBits(self, num): res=[0] while len(res)&amp;lt;=num: res+=[i+1 for i in res] return res[:num+1] Solution 4: class Solution: def countBits(self, num): dp = [0] * (num + 1) for i in range(1, num+1): if not i % 2: dp[i] = dp[i &amp;gt;&amp;gt; 1] else: dp[i] = dp[i &amp;gt;&amp;gt; 1] + 1 return dp[num] </description>
    </item>
    
    <item>
      <title>5 - Longest Palindromic Substring</title>
      <link>//alfmunny.com/leetcode-blog/posts/5-longest-palindromic-substring/</link>
      <pubDate>Tue, 31 Mar 2020 23:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/5-longest-palindromic-substring/</guid>
      <description>leetcode
Problem Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: &amp;#34;babad&amp;#34; Output: &amp;#34;bab&amp;#34; Note: &amp;#34;aba&amp;#34; is also a valid answer. Example 2: Input: &amp;#34;cbbd&amp;#34; Output: &amp;#34;bb&amp;#34; Notes DP problem
  States:
left_index, right_index, mark if s[left_index, right_index+1] is palindromic
  Transition:
if s[l] == s[r]: # mark it only when both ends are same values dp[l][r] = 1 if r == l # if only one element dp[l][r] = 1 if r+1 == l # if only two elements dp[l][r] = 1 if dp[l+1][r+1] = 1 # if the string in between is palindromic results = s[l:r+1] if r-l+1&amp;gt;len(results) # comparing the length, record the maximum   Base case:</description>
    </item>
    
    <item>
      <title>647 - Palindromic Substrings</title>
      <link>//alfmunny.com/leetcode-blog/posts/647-palindromic-substrings/</link>
      <pubDate>Tue, 31 Mar 2020 23:41:02 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/647-palindromic-substrings/</guid>
      <description>leetcode
Problem Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: Input: &amp;#34;abc&amp;#34; Output: 3 Explanation: Three palindromic strings: &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;. Example 2: Input: &amp;#34;aaa&amp;#34; Output: 6 Explanation: Six palindromic strings: &amp;#34;a&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;aa&amp;#34;, &amp;#34;aa&amp;#34;, &amp;#34;aaa&amp;#34;. Note: The input string length won&amp;#39;t exceed 1000.</description>
    </item>
    
    <item>
      <title>279 - Perfect Squares</title>
      <link>//alfmunny.com/leetcode-blog/posts/279-perfect-squares/</link>
      <pubDate>Tue, 31 Mar 2020 00:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/279-perfect-squares/</guid>
      <description>leetcode
Problem Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Notes DP problem
  States: n
  Transition:
  dp[i] = min([_dp[i-j*j]+1 if i-j*j &amp;gt;= 0 else break for j in range(1, sqrt(i)+1)])   Base case:</description>
    </item>
    
    <item>
      <title>221 - Maximal Square</title>
      <link>//alfmunny.com/leetcode-blog/posts/221-maximal-square/</link>
      <pubDate>Mon, 30 Mar 2020 20:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/221-maximal-square/</guid>
      <description>leetcode
Problem Given a 2D binary matrix filled with 0&amp;#39;s and 1&amp;#39;s, find the largest square containing only 1&amp;#39;s and return its area. Example: Input: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4 Notes DP Problem:
  States:
 position -&amp;gt; [i][j] how many continues 1 in vertical direction -&amp;gt; [i][j][0] how many continues 1 in horizontal direction -&amp;gt; [i][j][1] square value(or the length of the square) -&amp;gt; [i][j][2]  dp[i][j][0 or 1 or 2]</description>
    </item>
    
    <item>
      <title>96 - Unique Binary Search Trees</title>
      <link>//alfmunny.com/leetcode-blog/posts/96-unique-binary-search-trees/</link>
      <pubDate>Mon, 30 Mar 2020 15:17:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/96-unique-binary-search-trees/</guid>
      <description>leetcode
Problem Given n, how many structurally unique BST&amp;#39;s (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST&amp;#39;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 Notes Solution 1: DP In this dp problem, the hard part is to figure out the transition.</description>
    </item>
    
    <item>
      <title>152 - Maximum Product Subarray</title>
      <link>//alfmunny.com/leetcode-blog/posts/152-maximum-product-subarray/</link>
      <pubDate>Sun, 29 Mar 2020 17:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/152-maximum-product-subarray/</guid>
      <description>leetcode
Problem Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Notes DP problem:
  States: We have to know two previous states to deduct the current max product:</description>
    </item>
    
    <item>
      <title>322 - Coin Change</title>
      <link>//alfmunny.com/leetcode-blog/posts/322-coin-change/</link>
      <pubDate>Sat, 28 Mar 2020 02:17:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/322-coin-change/</guid>
      <description>leetcode
Problem You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Note: You may assume that you have an infinite number of each kind of coin.</description>
    </item>
    
    <item>
      <title>300 - Longest Increasing Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/300-longest-increasing-subsequence/</link>
      <pubDate>Sat, 28 Mar 2020 00:08:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/300-longest-increasing-subsequence/</guid>
      <description>leetcode
Problem Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note: There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? Solution DP problem.</description>
    </item>
    
    <item>
      <title>91 - Decode Ways</title>
      <link>//alfmunny.com/leetcode-blog/posts/91-decode-ways/</link>
      <pubDate>Wed, 25 Mar 2020 23:44:20 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/91-decode-ways/</guid>
      <description>leetcode
Problem A message containing letters from A-Z is being encoded to numbers using the following mapping: &amp;#39;A&amp;#39; -&amp;gt; 1 &amp;#39;B&amp;#39; -&amp;gt; 2 ... &amp;#39;Z&amp;#39; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: &amp;#34;12&amp;#34; Output: 2 Explanation: It could be decoded as &amp;#34;AB&amp;#34; (1 2) or &amp;#34;L&amp;#34; (12). Example 2: Input: &amp;#34;226&amp;#34; Output: 3 Explanation: It could be decoded as &amp;#34;BZ&amp;#34; (2 26), &amp;#34;VF&amp;#34; (22 6), or &amp;#34;BBF&amp;#34; (2 2 6).</description>
    </item>
    
    <item>
      <title>1306 - Jump Game III</title>
      <link>//alfmunny.com/leetcode-blog/posts/1306-jump-game-iii/</link>
      <pubDate>Sun, 22 Mar 2020 20:42:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1306-jump-game-iii/</guid>
      <description>leetcode
Problem Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0. Notice that you can not jump outside of the array at any time. Example 1: Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 index 5 -&amp;gt; index 6 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 2: Input: arr = [4,2,3,0,3,1,2], start = 0 Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 3: Input: arr = [3,0,2,1,2], start = 2 Output: false Explanation: There is no way to reach at index 1 with value 0.</description>
    </item>
    
    <item>
      <title>62 - Unique Paths</title>
      <link>//alfmunny.com/leetcode-blog/posts/62-unique-paths/</link>
      <pubDate>Sat, 21 Mar 2020 22:34:22 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/62-unique-paths/</guid>
      <description>leetcode
Problem A robot is located at the top-left corner of a m x n grid (marked &amp;#39;Start&amp;#39; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;#39;Finish&amp;#39; in the diagram below). How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1.</description>
    </item>
    
    <item>
      <title>91 - Decode Ways</title>
      <link>//alfmunny.com/leetcode-blog/posts/90-decode-ways/</link>
      <pubDate>Sat, 21 Mar 2020 22:28:56 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/90-decode-ways/</guid>
      <description>leetcode
Problem A message containing letters from A-Z is being encoded to numbers using the following mapping: &amp;#39;A&amp;#39; -&amp;gt; 1 &amp;#39;B&amp;#39; -&amp;gt; 2 ... &amp;#39;Z&amp;#39; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: &amp;#34;12&amp;#34; Output: 2 Explanation: It could be decoded as &amp;#34;AB&amp;#34; (1 2) or &amp;#34;L&amp;#34; (12). Example 2: Input: &amp;#34;226&amp;#34; Output: 3 Explanation: It could be decoded as &amp;#34;BZ&amp;#34; (2 26), &amp;#34;VF&amp;#34; (22 6), or &amp;#34;BBF&amp;#34; (2 2 6).</description>
    </item>
    
    <item>
      <title>55 - Jump Game</title>
      <link>//alfmunny.com/leetcode-blog/posts/55-jump-game/</link>
      <pubDate>Sat, 21 Mar 2020 22:19:29 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/55-jump-game/</guid>
      <description>leetcode
Problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description>
    </item>
    
    <item>
      <title>48 - Rotate Image</title>
      <link>//alfmunny.com/leetcode-blog/posts/48-rotate-image/</link>
      <pubDate>Sat, 21 Mar 2020 22:16:23 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/48-rotate-image/</guid>
      <description>leetcode
Problem You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2: Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] Notes Naive solution, to do it one by one.</description>
    </item>
    
    <item>
      <title>79 - Word Search</title>
      <link>//alfmunny.com/leetcode-blog/posts/79-word-search/</link>
      <pubDate>Sat, 14 Mar 2020 03:00:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/79-word-search/</guid>
      <description>leetcode
Problem Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;E&amp;#39;], [&amp;#39;S&amp;#39;,&amp;#39;F&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;S&amp;#39;], [&amp;#39;A&amp;#39;,&amp;#39;D&amp;#39;,&amp;#39;E&amp;#39;,&amp;#39;E&amp;#39;] ] Given word = &amp;#34;ABCCED&amp;#34;, return true. Given word = &amp;#34;SEE&amp;#34;, return true. Given word = &amp;#34;ABCB&amp;#34;, return false.</description>
    </item>
    
    <item>
      <title>78 - Subsets</title>
      <link>//alfmunny.com/leetcode-blog/posts/78-subsets/</link>
      <pubDate>Sat, 07 Mar 2020 23:59:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/78-subsets/</guid>
      <description>Problem leetcode
Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Notes Three strategies to solve a subset problem:
Recursion, Backtracking, Bitmask
Recursion Iterative version:
Start from empty array [[]]. Step 1: Take 1 into consideration, and add 1 to existing array [[], [1]] Step 2: Take 2 into consideration, and add 2 to existing array [[], [1], [2], [1, 2]] Step 3: Take 3 into consideration, and add 3 to existing array [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] DFS version:</description>
    </item>
    
    <item>
      <title>75 - Sort Colors</title>
      <link>//alfmunny.com/leetcode-blog/posts/75-sort-colors/</link>
      <pubDate>Fri, 06 Mar 2020 17:26:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/75-sort-colors/</guid>
      <description>leetcode
Problem Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library&amp;#39;s sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.</description>
    </item>
    
    <item>
      <title>64 - Minimum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/64-mnimum-path-sum/</link>
      <pubDate>Wed, 04 Mar 2020 18:47:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/64-mnimum-path-sum/</guid>
      <description>leetcode
Problem Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. Notes Thinking: It seems to be a greedy algorithm problem.</description>
    </item>
    
  </channel>
</rss>