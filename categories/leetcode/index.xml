<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on LeetCode In The Shell</title>
    <link>/leetcode-blog/categories/leetcode/</link>
    <description>Recent content in leetcode on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Mar 2020 01:14:52 +0100</lastBuildDate>
    
	<atom:link href="/leetcode-blog/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LeetCode</title>
      <link>/leetcode-blog/posts/leetcode/</link>
      <pubDate>Mon, 16 Mar 2020 01:14:52 +0100</pubDate>
      
      <guid>/leetcode-blog/posts/leetcode/</guid>
      <description>41 - First Missing Positive 48. Rotate Image 53. Maximum Subarray 55. Jump Game 62. Unique Paths 64. Minimum Path Sum 70. Climbing Stairs 91. Decode Ways 509. Fibonacci Number 75. Sort Colors 78 - Subsets 79 - Word Search  41 - First Missing Positive Problem Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space.</description>
    </item>
    
    <item>
      <title>41 - First Missing Positive</title>
      <link>/leetcode-blog/posts/41-first-missing-positive/</link>
      <pubDate>Sat, 14 Mar 2020 10:18:55 +0100</pubDate>
      
      <guid>/leetcode-blog/posts/41-first-missing-positive/</guid>
      <description>Problem Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Notes Run in O(n) time and uses constant extra space
  Say the length of the array is l, the number must be in 1&amp;hellip;l+1 (also l possible numbers)</description>
    </item>
    
    <item>
      <title>79 - Word Search</title>
      <link>/leetcode-blog/posts/79-word-search/</link>
      <pubDate>Sat, 14 Mar 2020 03:00:00 +0100</pubDate>
      
      <guid>/leetcode-blog/posts/79-word-search/</guid>
      <description>Problem leetcode
Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;E&amp;#39;], [&amp;#39;S&amp;#39;,&amp;#39;F&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;S&amp;#39;], [&amp;#39;A&amp;#39;,&amp;#39;D&amp;#39;,&amp;#39;E&amp;#39;,&amp;#39;E&amp;#39;] ] Given word = &amp;#34;ABCCED&amp;#34;, return true. Given word = &amp;#34;SEE&amp;#34;, return true. Given word = &amp;#34;ABCB&amp;#34;, return false.</description>
    </item>
    
    <item>
      <title>78 - Subsets</title>
      <link>/leetcode-blog/posts/78-subsets/</link>
      <pubDate>Sat, 07 Mar 2020 23:59:00 +0100</pubDate>
      
      <guid>/leetcode-blog/posts/78-subsets/</guid>
      <description>Problem leetcode
Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Notes Three strategies to solve a subset problem:
Recursion, Backtracking, Bitmask
Recursion Iterative version:
Start from empty array [[]]. Step 1: Take 1 into consideration, and add 1 to existing array [[], [1]] Step 2: Take 2 into consideration, and add 2 to existing array [[], [1], [2], [1, 2]] Step 3: Take 3 into consideration, and add 3 to existing array [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] DFS version:</description>
    </item>
    
  </channel>
</rss>