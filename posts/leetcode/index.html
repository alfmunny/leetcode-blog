<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>LeetCode [220/221] | LeetCode In The Shell</title>
    <link rel="stylesheet" href="../../css/style.css" />
    <link rel="stylesheet" href="../../css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="../../">Home</a></li>
      
      <li><a href="../../about/">About</a></li>
      
      <li><a href="../../categories/">Categories</a></li>
      
      <li><a href="../../tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">LeetCode [220/221]</span></h1>

<h2 class="date">2020/12/29</h2>
</div>

<main>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ul>
<li><a href="#41-first-missing-positive">41 - First Missing Positive</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#48-rotate-image">48 - Rotate Image</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#53-maximum-subarray">53 - Maximum Subarray</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#55-jump-game">55 - Jump Game</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solition">Solition</a></li>
</ul>
</li>
<li><a href="#62-unique-paths">62 - Unique Paths</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#64-minimum-path-sum">64 - Minimum Path Sum</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#70-climbing-stairs">70 - Climbing Stairs</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#91-decode-ways">91 - Decode Ways</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#509-fibonacci-number">509 - Fibonacci Number</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#75-sort-colors">75 - Sort Colors</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
</ul>
</li>
<li><a href="#78-subsets">78 - Subsets</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#79-word-search">79 - Word Search</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#45-jump-game-ii">45 - Jump Game II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1306-jump-game-iii">1306 - Jump Game III</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#84-largest-rectangle-in-histogram">84 - Largest Rectangle in Histogram</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#85-maximal-rectangle">85 - Maximal Rectangle</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#121-best-time-to-buy-and-sell-stock">121 - Best Time to Buy and Sell Stock</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#122-best-time-to-buy-and-sell-stock-ii">122 - Best Time to Buy and Sell Stock II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#123-best-time-to-buy-and-sell-stock-iii">123 - Best Time to Buy and Sell Stock III</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#188-best-time-to-buy-and-sell-stock-iv">188 - Best Time to Buy and Sell Stock IV</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#309-best-time-to-buy-and-sell-stock-with-cooldown">309 - Best Time to Buy and Sell Stock with Cooldown</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#104-maximum-depth-of-binary-tree">104 - Maximum Depth of Binary Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#21-merge-two-sorted-lists">21 - Merge Two Sorted Lists</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#101-symmetric-tree">101 - Symmetric Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#198-house-robber">198 - House Robber</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#300-longest-increasing-subsequence">300 - Longest Increasing Subsequence</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#322-coin-change">322 - Coin Change</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#152-maximum-product-subarray">152 - Maximum Product Subarray</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#96-unique-binary-search-trees">96 - Unique Binary Search Trees</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#221-maximal-square">221 - Maximal Square</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#279-perfect-squares">279 - Perfect Squares</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#647-palindromic-substrings">647 - Palindromic Substrings</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#5-longest-palindromic-substring">5 - Longest Palindromic Substring</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#136-single-number">136 - Single Number</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#202-happy-number">202 - Happy Number</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#338-counting-bits">338 - Counting Bits</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#notes">Notes</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#494-target-sum">494 - Target Sum</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#283-move-zeros">283 - Move Zeros</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#416-partition-equal-subset-sum">416 - Partition Equal Subset Sum</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#698-partition-to-k-equal-sum-subsets">698 - Partition to K Equal Sum Subsets</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#215-kth-largest-element-in-an-array">215 - Kth Largest Element in an Array</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#49-group-anagrams">49 - Group Anagrams</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#876-middle-of-the-linked-list">876 - Middle of the Linked List</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#844-backspace-string-compare">844 - Backspace String Compare</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#155-min-stack">155 - Min Stack</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#543-diameter-of-binary-tree">543 - Diameter of Binary Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1046-last-stone-weight">1046 - Last Stone Weight</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#525-contiguous-array">525 - Contiguous Array</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#perform-string-shifts">Perform String Shifts</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#238-product-of-array-except-self">238 - Product of Array Except Self</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#678-valid-parenthesis-string">678 - Valid Parenthesis String</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#200-number-of-islands">200 - Number of Islands</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#46-permutations">46 - Permutations</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#47-permutations-ii">47 - Permutations II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1008-construct-binary-search-tree-from-preorder-traversal">1008 - Construct Binary Search Tree from Preorder Traversal</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#105-construct-binary-tree-from-preorder-and-inorder-traversal">105 - Construct Binary Tree from Preorder and Inorder Traversal</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#leftmost-column-with-at-least-a-one">Leftmost Column with at Least a One</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#560-subarray-sum-equals-k">560 Subarray Sum Equals K</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#201-bitwise-and-of-numbers-range">201 - Bitwise AND of Numbers Range</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#146-lru-cache">146 - LRU Cache</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#460-lfu-cache">460 - LFU Cache</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#437-path-sum-iii">437 - Path Sum III</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1143-longest-common-subsequence">1143 - Longest Common Subsequence</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#887-super-egg-drop">887 - Super Egg Drop</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#28-implement-strstr--kmp-algorithm">28 - Implement strStr() (KMP Algorithm)</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#169-majority-element">169 - Majority Element</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#448-find-all-numbers-disappeard-in-an-array">448 - Find All Numbers Disappeard in an Array</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#124-binary-tree-maximum-path-sum">124 - Binary Tree Maximum Path Sum</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#278-first-bad-version">278 - First Bad Version</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal">106 - Construct Binary Tree from Inorder and Postorder Traversal</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#128-longest-consecutive-sequence">128 - Longest Consecutive Sequence</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#98-validate-binary-search-tree">98 - Validate Binary Search Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1009-complement-of-base-10-integer">1009 - Complement of Base 10 Integer</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#337-house-robber-iii">337 - House Robber III</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#cousins-in-binary-tree">Cousins in Binary Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1232-check-if-it-is-a-straight-line">1232 - Check If It Is a Straight Line</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#733-flood-fill">733 - Flood Fill</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#997-find-the-town-judge">997 - Find the Town Judge</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#540-single-element-in-a-sorted-array">540 - Single Element in a Sorted Array</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#402-remove-k-digits">402 - Remove K Digits</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#208-implement-trie--prefix-tree">208 - Implement Trie (Prefix Tree)</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#918-maximum-sum-circular-subarray">918 - Maximum Sum Circular Subarray</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#328-odd-even-linked-list">328 - Odd Even Linked List</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#438-find-all-anagrams-in-a-string">438 - Find All Anagrams in a String</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#567-permutation-in-string">567 - Permutation in String</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#901-onine-stock-span">901 - Onine Stock Span</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#230-kth-smallest-element-in-a-bst">230 - Kth Smallest Element in a BST</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1277-count-square-submatrices-with-all-ones">1277 - Count Square Submatrices with All Ones</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#76-minimum-window-substring">76 - Minimum Window Substring</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#451-sort-characters-by-frequency">451 - Sort Characters By Frequency</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
<li><a href="#similar-problems">Similar Problems</a></li>
</ul>
</li>
<li><a href="#986-interval-list-intersections">986 - Interval List Intersections</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1035-uncrossed-lines">1035 - Uncrossed Lines</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#886-possible-bipartition">886 - Possible Bipartition</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#207-course-schedule">207 - Course Schedule</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#210-course-schedule-ii">210 - Course Schedule II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#973-k-closest-points-to-origin">973 - K Closest Points to Origin</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#72-edit-distance">72 - Edit Distance</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#226-invert-binary-tree">226 - Invert Binary Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#746-min-cost-climbing-stairs">746 - Min Cost Climbing Stairs</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#237-delete-node-in-a-linked-list">237 - Delete Node in a Linked List</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1029-two-city-scheduling">1029 - Two City Scheduling</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#528-random-pick-with-weight">528 - Random Pick with Weight</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#518-coin-change-2">518 - Coin Change 2</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#231-power-of-two">231 - Power of Two</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#406-queue-reconstruction-by-height">406 - Queue Reconstruction by Height</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#213-house-robber-ii">213 - House Robber II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#38-count-and-say">38 - Count and Say</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#66-plus-one">66 - Plus One</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#392-is-subsequence">392 - Is Subsequence</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#40-combination-sum-ii">40 - Combination Sum II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#39-combination-sum">39 - Combination Sum</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#377-combination-sum-iv">377 - Combination Sum IV</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#216-combination-sum-iii">216 - Combination Sum III</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#47-permutations-ii">47 - Permutations II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#51-n-queens">51 - N-Queens</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#52-n-queens-ii">52 - N-Queens II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#77-combinations">77 - Combinations</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#90-subsets-ii">90 - Subsets II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#100-same-tree">100 - Same Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#112-path-sum">112 - Path Sum</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#113-path-sum-ii">113 - Path Sum II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#118-pascal-s-triangle">118 - Pascal&rsquo;s Triangle</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#54-spiral-matrix">54 - Spiral Matrix</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#58-length-of-last-word">58 - Length of Last Word</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#59-spiral-matrix-ii">59 - Spiral Matrix II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#61-rotate-list">61 - Rotate List</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#63-unique-paths-ii">63 - Unique Paths II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#74-search-a-2d-matrix">74 - Search a 2D Matrix</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#162-find-peak-element">162 - Find Peak Element</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#83-remove-duplicates-from-sorted-list">83 - Remove Duplicates from Sorted List</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#95-unique-binary-search-trees-ii">95 - Unique Binary Search Trees II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#222-count-complete-tree-nodes">222 - Count Complete Tree Nodes</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#130-surrounded-regions">130 - Surrounded Regions</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#129-sum-root-to-leaf-numbers">129 - Sum Root to Leaf Numbers</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#988-smallest-string-starting-from-leaf">988 - Smallest String Starting From Leaf</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#303-range-sum-query-immutable">303 - Range Sum Query - Immutable</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#264-ugly-number-ii">264 - Ugly Number II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#263-ugly-number">263 - Ugly Number</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#332-reconstruct-itinerary">332 - Reconstruct Itinerary</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#212-word-search-ii">212 - Word Search II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#441-arranging-coins">441 - Arranging Coins</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#107-binary-tree-level-order-traversal-ii">107 - Binary Tree Level Order Traversal II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#463-island-perimeter">463 - Island Perimeter</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#695-max-area-of-island">695 - Max Area of Island</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#15-3sum">15 - 3SUM</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#10-regular-expression-matching">10 - Regular Expression Matching</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#37-sudoku-solver">37 - Sudoku Solver</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#36-valid-sudoku">36 - Valid Sudoku</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#190-reverse-bits">190 - Reverse Bits</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#461-hamming-distance">461 - Hamming Distance</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#32-longest-valid-parentheses">32 - Longest Valid Parentheses</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#71-simplify-path">71 - Simplify Path</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#73-set-matrix-zeroes">73 - Set Matrix Zeroes</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#80-remove-duplicates-from-sorted-array-ii">80 - Remove Duplicates from Sorted Array II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#81-search-in-rotated-sorted-array-ii">81 - Search in Rotated Sorted Array II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#191-number-of-1-bits">191 - Number of 1 Bits</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#82-remove-duplicates-from-sorted-list-ii">82 - Remove Duplicates from Sorted List II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#240-search-a-2d-matrix-ii">240 - Search a 2D Matrix II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1103-distribute-candies-to-people">1103 - Distribute Candies to People</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#148-sort-list">148 - Sort List</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#142-reorder-list">142 - Reorder List</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#967-numbers-with-same-consecutive-differences">967 - Numbers With Same Consecutive Differences</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#97-interleaving-string">97 - Interleaving String</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#108-convert-sorted-array-to-binary-search-tree">108 - Convert Sorted Array to Binary Search Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#109-convert-sorted-list-to-binary-search-tree">109 - Convert Sorted List to Binary Search Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#110-balanced-binary-tree">110 - Balanced Binary Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#111-minimum-depth-of-binary-tree">111 - Minimum Depth of Binary Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#824-goat-latin">824 - Goat Latin</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#114-flatten-binary-tree-to-linked-list">114 - Flatten Binary Tree to Linked List</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#368-largest-divisible-subset">368 - Largest Divisible Subset</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#784-letter-case-permutation">784 - Letter Case Permutation</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1079-letter-tile-possibilities">1079 - Letter Tile Possibilities</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#516-longest-palindromic-subsequence">516 - Longest Palindromic Subsequence</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1032-stream-of-characters">1032 - Stream of Characters</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#199-binary-tree-right-side-view">199 - Binary Tree Right Side View</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1219-path-with-maximum-gold">1219 - Path with Maximum Gold</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#404-sum-of-left-leaves">404 - Sum of Left Leaves</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#131-palindrome-partitioning">131 - Palindrome Partitioning</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#132-palindrome-partitioning-ii">132 - Palindrome Partitioning II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#983-minimum-cost-for-tickets">983 - Minimum Cost For Tickets</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#412-fizz-buzz">412 - Fizz Buzz</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1286-iterator-for-combination">1286 - Iterator for Combination</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#93-restore-ip-addresses">93 - Restore IP Addresses</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#436-find-right-interval">436 - Find Right Interval</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#980-unique-paths-iii">980 - Unique Paths III</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#450-delete-node-in-a-bst">450 - Delete Node in a BST</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#526-beautiful-arrangement">526 - Beautiful Arrangement</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#354-russian-doll-envelopes">354 - Russian Doll Envelopes</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#403-frog-jump">403 - Frog Jump</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#376-wiggle-subsequence">376 - Wiggle Subsequence</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#86-partition-list">86 - Partition List</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#378-kth-smallest-element-in-a-sorted-matrix">378 - Kth Smallest Element in a Sorted Matrix</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#115-distinct-subsequences">115 - Distinct Subsequences</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1392-longest-happy-prefix">1392 - Longest Happy Prefix</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#395-longest-substring-with-at-least-k-repeating-characters">395 - Longest Substring with At Least K Repeating Characters</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#127-word-ladder">127 - Word Ladder</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#126-word-ladder-ii">126 - Word Ladder II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#257-binary-tree-paths">257 - Binary Tree Paths</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#691-stickers-to-spell-word">691 - Stickers to Spell Word</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#797-all-paths-from-source-to-target">797 - All Paths From Source to Target</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#464-can-i-win">464 - Can I Win</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#116-populating-next-right-pointers-in-each-node">116 - Populating Next Right Pointers in Each Node</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#295-find-median-from-data-stream">295 - Find Median from Data Stream</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#996-number-of-squareful-arrays">996 - Number of Squareful Arrays</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#842-split-array-into-fibonacci-sequence">842 - Split Array into Fibonacci Sequence</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#486-predict-the-winner">486 - Predict the Winner</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#556-next-greater-element-iii">556 - Next Greater Element III</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#381-insert-delete-getrandom-o--1--duplicates-allowed">381 - Insert Delete GetRandom O(1) - Duplicates allowed</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#134-gas-station">134 - Gas Station</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#135-candy">135 - Candy</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#140-word-break-ii">140 - Word Break II</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#139-word-break">139 - Word Break</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#443-string-compression">443 - String Compression</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#30-substring-with-concatenation-of-all-words">30 - Substring with Concatenation of All Words</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#1010-pairs-of-songs-with-total-durations-divisible-by-60">1010 - Pairs of Songs With Total Durations Divisible by 60</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#235-lowest-common-ancestor-of-a-binary-search-tree">235 - Lowest Common Ancestor of a Binary Search Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#701-insert-into-a-binary-search-tree">701 - Insert into a Binary Search Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#323-number-of-connected-components-in-an-undirected-graph">323 - Number of Connected Components in an Undirected Graph</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#863-all-nodes-distance-k-in-binary-tree">863 - All Nodes Distance K in Binary Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#515-find-largest-value-in-each-tree-row">515 - Find Largest Value in Each Tree Row</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#42-trapping-rain-water">42 - Trapping Rain Water</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
<li><a href="#236-lowest-common-ancestor-of-a-binary-tree">236 - Lowest Common Ancestor of a Binary Tree</a>
<ul>
<li><a href="#problem">Problem</a></li>
<li><a href="#solution">Solution</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="41-first-missing-positive">41 - First Missing Positive</h2>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an unsorted integer array, find the smallest missing positive integer.

Example 1:

Input: [1,2,0]
Output: 3

Example 2:

Input: [3,4,-1,1]
Output: 2

Example 3:

Input: [7,8,9,11,12]
Output: 1

Note:

Your algorithm should run in O(n) time and uses constant extra space.
</code></pre></div><h3 id="notes">Notes</h3>
<p>Run in O(n) time and uses constant extra space</p>
<ol>
<li>
<p>Say the length of the array is l, the number must be in 1&hellip;l+1 (also l possible numbers)</p>
<p>For example</p>
<p>[1, 2, 3, 4], the first missing positive is 5.</p>
<p>[7, 8, 9, 10], the first missing positive is 1</p>
<p>It means you can use the array as a constant space. The result must be (one of the indexes + 1).</p>
</li>
<li>
<p>We put the number in the right place. When it is 10, we swap it with A[9].</p>
</li>
</ol>
<p>After all the numbers are in the right place, the first one, whose index + 1 != number, it is the missing one</p>
<h4 id="how-to-put-the-numer-in-the-right-place">How to put the numer in the right place</h4>
<p>Use the `while` to swap the numbers. Only `if` can not do the same job.</p>
<p>Consider nums = [3, 4, -1, 1].</p>
<p>Only with if:</p>
<p>First Loop: swap 3 and -1</p>
<p>nums = [-1, 4, 3, 1]</p>
<p>Second Loop: swap 4 and 1</p>
<p>nums = [-1, 1, 3, 4]</p>
<p>And the process stops. Because 4 is already in the right place. You miss to put the 1 in the right place.</p>
<p>So you have to do it recursively, with `while`.</p>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">firstMissingPositive</span>(self, nums):
        l <span style="color:#f92672">=</span> len(nums)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(l):
            <span style="color:#75715e"># Note!: here has to be using while</span>
            <span style="color:#66d9ef">while</span> (nums[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> nums[i] <span style="color:#f92672">&lt;=</span> l <span style="color:#f92672">and</span> nums[nums[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> nums[i]):
                nums[nums[i]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], nums[i] <span style="color:#f92672">=</span> nums[i], nums[nums[i]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

        <span style="color:#66d9ef">for</span> i, n <span style="color:#f92672">in</span> enumerate(nums):
            <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">!=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">return</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="48-rotate-image">48 - Rotate Image</h2>
<p><a href="https://leetcode.com/problems/rotate-image/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given an n x n 2D matrix representing an image.

Rotate the image by 90 degrees (clockwise).

Note:

You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:

Given input matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</code></pre></div><h3 id="notes">Notes</h3>
<h4 id="naive-solution-to-do-it-one-by-one-dot">Naive solution, to do it one by one.</h4>
<p><strong>Important</strong>:</p>
<p>You go from the outside into the middle. So the main loop is half of the dimension.</p>
<p>The inner loop should also shrink its size everytime. Begins at i and ends and n-2-i, <strong>not n-1-i</strong>.</p>
<p>Because you don&rsquo;t want to swap the last one. The last one n-1-i has already been swapped with the i.</p>
<h4 id="another-solution-how-to-rotate-a-matrix-faster">Another solution: how to rotate a matrix faster</h4>
<p>Swap the diagnoal elements and reverse each line in the matrix.</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>swap</th>
<th>1</th>
<th>4</th>
<th>7</th>
<th>reverse</th>
<th>7</th>
<th>4</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>5</td>
<td>6</td>
<td>&mdash;&gt;</td>
<td>2</td>
<td>5</td>
<td>8</td>
<td>&mdash;&mdash;&gt;</td>
<td>8</td>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
<td></td>
<td>3</td>
<td>6</td>
<td>9</td>
<td></td>
<td>9</td>
<td>6</td>
<td>3</td>
</tr>
</tbody>
</table>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-straightforward">Solution 1: Straightforward</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rotate</span>(self, matrix):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type matrix: List[List[int]]
</span><span style="color:#e6db74">        :rtype: None Do not return anything, modify matrix in-place instead.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        n <span style="color:#f92672">=</span> len(matrix)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>):
            <span style="color:#75715e"># Shrink the dimension</span>
            <span style="color:#75715e"># Do not include the last element</span>
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i, n<span style="color:#f92672">-</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
                tmp <span style="color:#f92672">=</span> matrix[i][j]
                matrix[i][j] <span style="color:#f92672">=</span> matrix[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>j][i]
                matrix[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>j][i] <span style="color:#f92672">=</span> matrix[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>i][n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>j]
                matrix[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>i][n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>j] <span style="color:#f92672">=</span> matrix[j][n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>i]
                matrix[j][n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>i] <span style="color:#f92672">=</span> tmp

matrix <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>]]
Solution()<span style="color:#f92672">.</span>rotate(matrix)
[<span style="color:#66d9ef">print</span>(<span style="color:#f92672">*</span>line) <span style="color:#66d9ef">for</span> line <span style="color:#f92672">in</span> matrix]
</code></pre></div><h4 id="solution-2">Solution 2:</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rotate</span>(self, matrix):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type matrix: List[List[int]]
</span><span style="color:#e6db74">        :rtype: None Do not return anything, modify matrix in-place instead.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        n <span style="color:#f92672">=</span> len(matrix)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i, n):
                matrix[i][j], matrix[j][i] <span style="color:#f92672">=</span> matrix[j][i], matrix[i][j]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            matrix[i]<span style="color:#f92672">.</span>reverse()

matrix <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>], [<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>]]
Solution()<span style="color:#f92672">.</span>rotate(matrix)
[<span style="color:#66d9ef">print</span>(<span style="color:#f92672">*</span>line) <span style="color:#66d9ef">for</span> line <span style="color:#f92672">in</span> matrix]
</code></pre></div><h2 id="53-maximum-subarray">53 - Maximum Subarray</h2>
<p><a href="https://leetcode.com/problems/maximum-subarray/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
</code></pre></div><h3 id="notes">Notes</h3>
<p>Dynamic programming problem.</p>
<p>Use nums[i] always store the maximum sum.</p>
<p>maxSum(i) = maxSum(i-1) + nums[i] only if maxSum(i-1) &gt; 0</p>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-use-a-extra-dp-array">Solution 1: use a extra dp array</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxSubArray</span>(self, nums):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type nums: List[int]
</span><span style="color:#e6db74">        :rtype: int
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        curSum <span style="color:#f92672">=</span> maxSum <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]

        <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums[<span style="color:#ae81ff">1</span>:]:
          curSum <span style="color:#f92672">=</span> max(num, curSum<span style="color:#f92672">+</span>num)
          maxSum <span style="color:#f92672">=</span> max(curSum, maxSum)

        <span style="color:#66d9ef">return</span> maxSum

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>maxSubArray([<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">4</span>]))
</code></pre></div><h4 id="solution-2-no-extra-space-in-place-modify">Solution 2: no extra space, in place modify</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxSubArray</span>(self, nums):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type nums: List[int]
</span><span style="color:#e6db74">        :rtype: int
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>

        <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        ret <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)):
            <span style="color:#66d9ef">if</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                nums[i] <span style="color:#f92672">+=</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]

            ret <span style="color:#f92672">=</span> max(ret, nums[i])

        <span style="color:#66d9ef">return</span> ret
<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>maxSubArray([<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">4</span>]))
</code></pre></div><h2 id="55-jump-game">55 - Jump Game</h2>
<p><a href="https://leetcode.com/problems/jump-game/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:

Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

Example 2:

Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.
</code></pre></div><h3 id="notes">Notes</h3>
<p>Greedy algorithm. There are 2 approaches, from head or from tail.</p>
<h4 id="start-from-head">Start from head</h4>
<p>always remember the furthest reachable index.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">reach <span style="color:#f92672">=</span> max(i <span style="color:#f92672">+</span> nums[i], reach) <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;=</span> reach
</code></pre></div><h4 id="start-from-tail">Start from tail</h4>
<p>always remember the last position it can reach.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">lastPos <span style="color:#f92672">=</span> i <span style="color:#66d9ef">if</span> i <span style="color:#f92672">+</span> nums[i] <span style="color:#f92672">&gt;=</span> lastPos
</code></pre></div><h3 id="solition">Solition</h3>
<h4 id="solution-1-start-from-head">Solution 1: start from head</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>():
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canJump</span>(self, nums):
        reach <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums)):
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;=</span> reach:
                reach <span style="color:#f92672">=</span> max(i <span style="color:#f92672">+</span> nums[i], reach)
            <span style="color:#66d9ef">else</span>:
              <span style="color:#66d9ef">break</span>

        <span style="color:#66d9ef">return</span> reach <span style="color:#f92672">&gt;=</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>canJump([ <span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">4</span> ]))
<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>canJump([ <span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">4</span> ] ))
</code></pre></div><h4 id="solution-2-start-from-tail">Solution 2: start from tail</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>():
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canJump</span>(self, nums):
        lastPos <span style="color:#f92672">=</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> reversed(range(len(nums))):
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">+</span> nums[i] <span style="color:#f92672">&gt;=</span> lastPos:
                lastPos <span style="color:#f92672">=</span> i

        <span style="color:#66d9ef">return</span> lastPos <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>canJump([ <span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">4</span> ]))
<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>canJump([ <span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">4</span> ] ))
</code></pre></div><h2 id="62-unique-paths">62 - Unique Paths</h2>
<p><a href="https://leetcode.com/problems/unique-paths/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).

How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -&gt; Right -&gt; Down
2. Right -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Right
Example 2:

Input: m = 7, n = 3
Output: 28
</code></pre></div><h3 id="notes">Notes</h3>
<p>It is a DP problem.</p>
<ol>
<li>
<p>There are only two possibilities to arrive at the finish point</p>
<ol>
<li>arrive at that point from above</li>
<li>arrive at that point from left</li>
</ol>
</li>
<li>
<p>So the ways to arrive at current point is equal to the ways from above plus the ways from left. dp[i][j] = dp[i][j-1] + dp[i - 1][j]</p>
</li>
<li>
<p>Dynamic programming. Maintain a two dimensional matrix.</p>
</li>
<li>
<p>Optimize it to one dimension.</p>
</li>
<li>
<p>Complexity O(m * n)</p>
</li>
</ol>
<h4 id="uniquepath-with-2-d-dp">UniquePath with 2-D DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><p>After you have the edge, you go levelly to the bottom.</p>
<h4 id="uniquepath-with-1-d-dp">UniquePath with 1-D DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">dp[j] <span style="color:#f92672">=</span> dp[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[j]
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-2-d-dp">Solution 1: 2-D DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>():
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">uniquePath</span>(self, m, n):
        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n)] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(m)]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, m):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
                dp[i][j] <span style="color:#f92672">=</span> dp[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> m <span style="color:#f92672">and</span> n <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h4 id="solution-2-1-d-dp">Solution 2: 1-D DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>():
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">uniquePath</span>(self, m, n):
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> n

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, m):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
                dp[j] <span style="color:#f92672">=</span> dp[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[j]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> m <span style="color:#f92672">and</span> n <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h2 id="64-minimum-path-sum">64 - Minimum Path Sum</h2>
<p><a href="https://leetcode.com/problems/minimum-path-sum/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
</code></pre></div><h3 id="notes">Notes</h3>
<p>Thinking: <del>It seems to be a greedy algorithm problem.</del></p>
<p>It is a dp problem.</p>
<p>dp equation:</p>
<p>dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j]</p>
<p>Remember to handle the edge cases.</p>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-2d-dp">Solution 1: 2D DP</h4>
<ul>
<li>Inplace DP</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minPathSum</span>(self, grid):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type grid: List[List[int]]
</span><span style="color:#e6db74">        :rtype: int
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        m <span style="color:#f92672">=</span> len(grid)
        n <span style="color:#f92672">=</span> len(grid[<span style="color:#ae81ff">0</span>])

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(m):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                    <span style="color:#66d9ef">if</span> j <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                        <span style="color:#66d9ef">continue</span>
                    <span style="color:#66d9ef">else</span>:
                        grid[i][j] <span style="color:#f92672">+=</span> grid[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#66d9ef">else</span>:
                    <span style="color:#66d9ef">if</span> j <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                        grid[i][j] <span style="color:#f92672">+=</span> grid[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]
                    <span style="color:#66d9ef">else</span>:
                        grid[i][j] <span style="color:#f92672">+=</span> min(grid[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], grid[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
        <span style="color:#66d9ef">return</span> grid[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> m <span style="color:#f92672">and</span> n <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>


grid <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>]]

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>minPathSum(grid))
</code></pre></div><ul>
<li>Additional DP with auxiliary columns</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> sys
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minPathSum</span>(self, grid):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type grid: List[List[int]]
</span><span style="color:#e6db74">        :rtype: int
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        m <span style="color:#f92672">=</span> len(grid)
        n <span style="color:#f92672">=</span> len(grid[<span style="color:#ae81ff">0</span>])

        dp <span style="color:#f92672">=</span> [[ <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)] <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(dp)):
          dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>maxsize

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(dp[<span style="color:#ae81ff">0</span>])):
            dp[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>maxsize

        dp[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> grid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> j <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
                    <span style="color:#66d9ef">continue</span>
                <span style="color:#66d9ef">else</span>:
                    dp[i][j] <span style="color:#f92672">=</span> min(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> grid[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]


        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> m <span style="color:#f92672">and</span> n <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>


grid <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>]]

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>minPathSum(grid))
</code></pre></div><h4 id="solution-2-1d-dp">Solution 2: 1D DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> sys


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minPathSum</span>(self, grid):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type grid: List[List[int]]
</span><span style="color:#e6db74">        :rtype: int
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        m <span style="color:#f92672">=</span> len(grid)
        n <span style="color:#f92672">=</span> len(grid[<span style="color:#ae81ff">0</span>])

        dp <span style="color:#f92672">=</span> [sys<span style="color:#f92672">.</span>maxsize <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]
        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> grid[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(m):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> j <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                    <span style="color:#66d9ef">continue</span>
                <span style="color:#66d9ef">else</span>:
                    dp[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> min(dp[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>], dp[j]) <span style="color:#f92672">+</span> grid[i][j]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> m <span style="color:#f92672">and</span> n <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>


grid <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>]]

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>minPathSum(grid))
</code></pre></div><h2 id="70-climbing-stairs">70 - Climbing Stairs</h2>
<p><a href="https://leetcode.com/problems/climbing-stairs/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

Example 1:

Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
Example 2:

Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</code></pre></div><h3 id="notes">Notes</h3>
<p>The distinct ways to take n stair cases:</p>
<ol>
<li>take one step at last, the distinct ways to take n-1 stair cases  -&gt; f(n-1) ways</li>
<li>take two steps at last, the distinct ways to take n-2 stair cases -&gt; f(n-2) ways</li>
</ol>
<p>So f(n) = f(n-1) + f(n-2)</p>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>():
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">climbStairs</span>(self, n):
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>:
            <span style="color:#66d9ef">return</span> n

        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n

        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, n):
            dp[i] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="91-decode-ways">91 - Decode Ways</h2>
<p><a href="https://leetcode.com/problems/decode-ways">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A message containing letters from A-Z is being encoded to numbers using the following mapping:

&#39;A&#39; -&gt; 1
&#39;B&#39; -&gt; 2
...
&#39;Z&#39; -&gt; 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: &#34;12&#34;
Output: 2
Explanation: It could be decoded as &#34;AB&#34; (1 2) or &#34;L&#34; (12).
Example 2:

Input: &#34;226&#34;
Output: 3
Explanation: It could be decoded as &#34;BZ&#34; (2 26), &#34;VF&#34; (22 6), or &#34;BBF&#34; (2 2 6).
</code></pre></div><h3 id="notes">Notes</h3>
<p>DP problem.</p>
<ol>
<li>Initialize dp array with dp[0] = 1 as padding, the rest of them are 0.</li>
<li>Start from the first index of the string.
<ol>
<li>If dp[i] is in range 1 to 9, dp[i] = dp[i-1]. The ways of decode will not increase, if it is 0, it remains 0.</li>
<li>If dp[i] is in range 10 to 26, dp[i] += dp[i-1]. The ways of decode increase by one, if it is 00, it remains 0.</li>
</ol>
</li>
</ol>
<p><strong>Important</strong>:</p>
<ol>
<li>Corner cases: &ldquo;0&rdquo; -&gt; 0, &ldquo;1002&rdquo; -&gt; 0</li>
<li>Notice the padding</li>
</ol>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>():
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numsDecodings</span>(self, s):

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> s:
          <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        n <span style="color:#f92672">=</span> len(s)

        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)

        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):

            <span style="color:#66d9ef">if</span> s[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>: i] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;0&#39;</span>:
                dp[i] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> <span style="color:#e6db74">&#39;10&#39;</span> <span style="color:#f92672">&lt;=</span> s[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>:i] <span style="color:#f92672">&lt;=</span> <span style="color:#e6db74">&#39;26&#39;</span>:
                dp[i] <span style="color:#f92672">+=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="509-fibonacci-number">509 - Fibonacci Number</h2>
<p><a href="https://leetcode.com/problems/fibonacci-number/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), for N &gt; 1.
Given N, calculate F(N).



Example 1:

Input: 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.
Example 2:

Input: 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.
Example 3:

Input: 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.
</code></pre></div><h3 id="notes">Notes</h3>
<p>DP Problem.</p>
<p><strong>Important</strong>:</p>
<p>Note how long is the dp array. It shoud be N+1, since we start with the number 0.</p>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib</span>(self, N):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type N: int
</span><span style="color:#e6db74">        :rtype: int
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> N <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>:
            <span style="color:#66d9ef">return</span> N

        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)

        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
            dp[i] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="75-sort-colors">75 - Sort Colors</h2>
<p><a href="https://leetcode.com/problems/sort-colors/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note: You are not suppose to use the library&#39;s sort function for this problem.

Example:

Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Follow up:

A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0&#39;s, 1&#39;s, and 2&#39;s, then overwrite array with total number of 0&#39;s, then 1&#39;s and followed by 2&#39;s.
Could you come up with a one-pass algorithm using only constant space?
</code></pre></div><h3 id="notes">Notes</h3>
<h4 id="first-attempt-is-to-use-two-pointer-dot">First attempt is to use two pointer.</h4>
<p>There is a but a corner case: when two point</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">subsets</span>(self, nums):
        res <span style="color:#f92672">=</span> [[]]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> sorted(nums):
            res <span style="color:#f92672">+=</span> [item<span style="color:#f92672">+</span>[i] <span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> res]

        <span style="color:#66d9ef">return</span> res

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>subsets([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]))
</code></pre></div><h2 id="78-subsets">78 - Subsets</h2>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-dfs">Solution 1: DFS</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">subsets</span>(self, nums):
        res <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(sorted(nums), <span style="color:#ae81ff">0</span>, [], res)
        <span style="color:#66d9ef">return</span> res

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, nums, index, path, res):
        res<span style="color:#f92672">.</span>append(path)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index, len(nums)):
            self<span style="color:#f92672">.</span>dfs(nums, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, path <span style="color:#f92672">+</span> [nums[i]], res)
</code></pre></div><h4 id="solution-2-iterative">Solution 2: Iterative</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">subsets</span>(self, nums):
        res <span style="color:#f92672">=</span> [[]]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> sorted(nums):
            res <span style="color:#f92672">+=</span> [item<span style="color:#f92672">+</span>[i] <span style="color:#66d9ef">for</span> item <span style="color:#f92672">in</span> res]
        <span style="color:#66d9ef">return</span> res
</code></pre></div><h4 id="solution-3-backtrack">Solution 3: backtrack</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">subsets</span>(self, nums):
        output <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(nums)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            temp <span style="color:#f92672">=</span> []
            self<span style="color:#f92672">.</span>backtrack(<span style="color:#ae81ff">0</span>, k, nums, temp, output)

        <span style="color:#66d9ef">return</span> output

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">backtrack</span>(self, begin, length, nums, temp, output):

        <span style="color:#66d9ef">if</span> length <span style="color:#f92672">==</span> len(temp):
            output<span style="color:#f92672">.</span>append(temp[:])

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(begin, len(nums)):
            temp<span style="color:#f92672">.</span>append(nums[i])
            self<span style="color:#f92672">.</span>backtrack(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, length, nums, temp, output)
            temp<span style="color:#f92672">.</span>pop()


<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>subsets([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]))
</code></pre></div><h4 id="solution-4-bitmask">Solution 4: bitmask</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>():
  <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">subsets</span>(self, nums):
    n <span style="color:#f92672">=</span> len(nums)
    output <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>n, <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)):
      bitmask <span style="color:#f92672">=</span> bin(i)[<span style="color:#ae81ff">3</span>:]
      output<span style="color:#f92672">.</span>append([nums[i] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n) <span style="color:#66d9ef">if</span> bitmask[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> ])

    <span style="color:#66d9ef">return</span> output
</code></pre></div><h2 id="79-word-search">79 - Word Search</h2>
<p><a href="https://leetcode.com/problems/word-search/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where &#34;adjacent&#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],
  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],
  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]
]

Given word = &#34;ABCCED&#34;, return true.
Given word = &#34;SEE&#34;, return true.
Given word = &#34;ABCB&#34;, return false.
</code></pre></div><h3 id="notes">Notes</h3>
<p>Backtrack problem.</p>
<ol>
<li>when found, mark the point to one.</li>
<li>Use dfs to go down from this point.</li>
<li>Can&rsquo;t go down anymore, mark the point back to zero (backtrack step).</li>
</ol>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-backtrack-dfs">Solution 1: Backtrack, dfs</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">exist</span>(self, board: List[List[str]], word: str) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(board)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(board[<span style="color:#ae81ff">0</span>])):
                <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>dfs(board, word, <span style="color:#ae81ff">0</span>, i, j):
                    <span style="color:#66d9ef">return</span> True
        <span style="color:#66d9ef">return</span> False

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, board, word, w, i, j):
        <span style="color:#66d9ef">if</span> w <span style="color:#f92672">==</span> len(word):
            <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">&gt;=</span> len(board) <span style="color:#f92672">or</span> j <span style="color:#f92672">&gt;=</span> len(board[<span style="color:#ae81ff">0</span>]):
            <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">==</span> word[w]:
            board[i][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;-&#39;</span>

            <span style="color:#66d9ef">for</span> next_i, next_j <span style="color:#f92672">in</span> [[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j], [i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j], [i, j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>],
                                   [i, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]]:
                <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>dfs(board, word, w <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, next_i, next_j):
                    <span style="color:#66d9ef">return</span> True

            board[i][j] <span style="color:#f92672">=</span> word[w]

        <span style="color:#66d9ef">return</span> False
</code></pre></div><h2 id="45-jump-game-ii">45 - Jump Game II</h2>
<p><a href="https://leetcode.com/problems/jump-game-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

Example:

Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
Note:

You can assume that you can always reach the last index.
</code></pre></div><h3 id="notes">Notes</h3>
<p>Greedy problem.</p>
<ol>
<li>[begin, end], go through values in between, have one furthest reach.</li>
<li>current index reach to end, jump once.</li>
<li>next interval is [end, reach]</li>
</ol>
<h3 id="solution">Solution</h3>
<p>#+begin_src python
class Solution:
def jump(self, nums):</p>
<p>jumps = 0
curFurthest = 0
curEnd = 0</p>
<p>for i in range(len(nums) - 1):</p>
<p>curFurthest = max(curFurthest, i + nums[i])</p>
<p>if (i <code>= curEnd): jumps +</code> 1
cur</p>
<h2 id="1306-jump-game-iii">1306 - Jump Game III</h2>
<p><a href="https://leetcode.com/problems/jump-game-iii/submissions/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.

Notice that you can not jump outside of the array at any time.

Example 1:

Input: arr = [4,2,3,0,3,1,2], start = 5
Output: true
Explanation:
All possible ways to reach at index 3 with value 0 are:
index 5 -&gt; index 4 -&gt; index 1 -&gt; index 3
index 5 -&gt; index 6 -&gt; index 4 -&gt; index 1 -&gt; index 3

Example 2:

Input: arr = [4,2,3,0,3,1,2], start = 0
Output: true
Explanation:
One possible way to reach at index 3 with value 0 is:
index 0 -&gt; index 4 -&gt; index 1 -&gt; index 3

Example 3:

Input: arr = [3,0,2,1,2], start = 2
Output: false
Explanation: There is no way to reach at index 1 with value 0.

Constraints:

1 &lt;= arr.length &lt;= 5 * 10^4
0 &lt;= arr[i] &lt; arr.length
0 &lt;= start &lt; arr.length
</code></pre></div><h3 id="notes">Notes</h3>
<p>Use dfs to search for 0. Mark the visited place to trigger stop.</p>
<p><strong>Important</strong>:</p>
<p>Remember to reset the mark if can not find along the path, so that it can search into another path.</p>
<h3 id="solution">Solution</h3>
<p>#+begin_src python
class Solution:
def canReach(self, arr, start):
if start &gt;= len(arr) or start &lt; 0:
return False</p>
<p>if arr[start] == 0:
return True</p>
<p>if arr[start] == -1:
return False</p>
<p>step = arr[start]
arr[start] = -1</p>
<p>if self.canReach(arr, start - step) or self.canReach(arr, start + step):
return True
else:</p>
<h2 id="84-largest-rectangle-in-histogram">84 - Largest Rectangle in Histogram</h2>
<p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given n non-negative integers representing the histogram&#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

Example:

Input: [2,1,5,6,2,3]
Output: 10
</code></pre></div><p><img src="../../ox-hugo/2020-03-23_00-34-37_histogram.png" alt="">
Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].</p>
<p><img src="../../ox-hugo/2020-03-23_00-35-27_histogram_area.png" alt="">
The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<h3 id="notes">Notes</h3>
<p>Main idea is to caculate both left edge and right edge for every entry in the array</p>
<p>Two ways of solution.</p>
<h4 id="brute-force">Brute Force</h4>
<p>Generate two arrays left[] and right[] to keep the two edges of every entry.</p>
<ol>
<li>one loop to caculate left[].</li>
<li>one loop to caculate right[].</li>
<li>one loop to go through all the edges to caculate the square.</li>
</ol>
<h4 id="improvement-of-the-brute-force">Improvement of the brute force</h4>
<p>We can:</p>
<p>store the number of the left bars, which are &gt;= current bar, in left[]</p>
<p>store the number of the right bars, which are &gt;= current bar, in right[]</p>
<p>How to avoid duplicating searching.</p>
<ol>
<li>left[current] = left[current - 1]</li>
<li>jump left[current - 1] steps to check the next interval of the array</li>
</ol>
<h4 id="stack">Stack</h4>
<p>Create a stack to store the index of the entry.</p>
<ol>
<li>if current entry is smaller than the top, we find the right edge of the top entry. pop it out and caculate the the max square of the top entry</li>
<li>if current entry is not smaller than the top, push it into stack</li>
<li>go through the left entries in the stack. The lefts ones are all have the longest bar at the top.</li>
</ol>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-brute-force">Solution 1: brute-force</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">largestRectangleArea</span>(self, heights):

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> heights:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        n <span style="color:#f92672">=</span> len(heights)
        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        left <span style="color:#f92672">=</span> [ i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n) ]
        right <span style="color:#f92672">=</span> [ i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n) ]

        <span style="color:#75715e"># caculate for the left edge</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            p <span style="color:#f92672">=</span> i
            <span style="color:#66d9ef">while</span> p <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">if</span> heights[p] <span style="color:#f92672">&lt;</span> heights[i]:
                    <span style="color:#66d9ef">break</span>
                p <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
            left[i] <span style="color:#f92672">=</span> p

        <span style="color:#75715e"># caculate for the right edge</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            p <span style="color:#f92672">=</span> i
            <span style="color:#66d9ef">while</span> p <span style="color:#f92672">&lt;</span> n:
                <span style="color:#66d9ef">if</span> heights[p] <span style="color:#f92672">&lt;</span> heights[i]:
                    <span style="color:#66d9ef">break</span>
                p <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            right[i] <span style="color:#f92672">=</span> p

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            res <span style="color:#f92672">=</span> max(res, heights[i] <span style="color:#f92672">*</span> (right[i] <span style="color:#f92672">-</span> left[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))

        <span style="color:#66d9ef">return</span> res

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>largestRectangleArea([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]))
</code></pre></div><p>O(n^2)</p>
<p>It will execeed time limit on leetcode.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">10
</code></pre></div><h4 id="solution-2-improved-version">Solution 2: improved version</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">largestRectangleArea</span>(self, heights):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> heights:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        n <span style="color:#f92672">=</span> len(heights)
        left <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> n
        right <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> n

        <span style="color:#75715e"># caculate left[]</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            p <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">while</span> p <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">if</span> heights[p] <span style="color:#f92672">&gt;=</span> heights[i]:
                    left[i] <span style="color:#f92672">+=</span> left[p]
                    <span style="color:#75715e"># jump backward</span>
                    p <span style="color:#f92672">-=</span> left[p]
                <span style="color:#66d9ef">else</span>:
                    <span style="color:#66d9ef">break</span>

        <span style="color:#75715e"># caculate right[]</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            p <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">while</span> p <span style="color:#f92672">&lt;</span> n:
                <span style="color:#66d9ef">if</span> heights[p] <span style="color:#f92672">&gt;=</span> heights[i]:
                    right[i] <span style="color:#f92672">+=</span> right[p]
                    <span style="color:#75715e"># jump forward</span>
                    p <span style="color:#f92672">+=</span> right[p]
                <span style="color:#66d9ef">else</span>:
                    <span style="color:#66d9ef">break</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            res <span style="color:#f92672">=</span> max(res, heights[i] <span style="color:#f92672">*</span> (left[i] <span style="color:#f92672">+</span> right[i] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))

        <span style="color:#66d9ef">return</span> res

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>largestRectangleArea([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>]))
</code></pre></div><p>Generale Case: O(n), because it uses the jump
Worst Case: O(n^2)</p>
<h4 id="solution-3-stack">Solution 3: stack</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">largestRectangleArea</span>(self, heights):

        stack <span style="color:#f92672">=</span> []
        n <span style="color:#f92672">=</span> len(heights)
        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        index <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">while</span> index <span style="color:#f92672">&lt;</span> n:

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> stack <span style="color:#f92672">or</span> heights[stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">&lt;=</span> heights[index]:
                stack<span style="color:#f92672">.</span>append(index)
                index <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                top <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>pop()
                area <span style="color:#f92672">=</span> (heights[top] <span style="color:#f92672">*</span>
                        ((index <span style="color:#f92672">-</span> stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">if</span> stack <span style="color:#66d9ef">else</span> index))

                res <span style="color:#f92672">=</span> max(res, area)

        <span style="color:#66d9ef">while</span> stack:
            h <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>pop()
            res <span style="color:#f92672">=</span> max(
                r
</code></pre></div><h2 id="85-maximal-rectangle">85 - Maximal Rectangle</h2>
<p><a href="https://leetcode.com/problems/maximal-rectangle/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest rectangle containing only 1&#39;s and return its area.

Example:

Input:
[
  [&#34;1&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;,&#34;0&#34;],
  [&#34;1&#34;,&#34;0&#34;,&#34;1&#34;,&#34;1&#34;,&#34;1&#34;],
  [&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;1&#34;,&#34;1&#34;],
  [&#34;1&#34;,&#34;0&#34;,&#34;0&#34;,&#34;1&#34;,&#34;0&#34;]
]
Output: 6
</code></pre></div><h3 id="notes">Notes</h3>
<p>Two parts:</p>
<ol>
<li>generate a heights histogram for every row.</li>
<li>apple &ldquo;largest rectangle in histogram&rdquo; on each row of histogram</li>
</ol>
<h3 id="solution">Solution</h3>
<p>#+begin_src python :results output
class Solution:
def maximalRectangle(self, matrix):
if not matrix or not matrix[0]:
return 0</p>
<p>m = len(matrix)
n = len(matrix[0])</p>
<p>histograms = [[0] * n for i in range(m)]</p>
<p>res = 0</p>
<p>for i in range(m):
for j in range(n):
if matrix[i][j] == &ldquo;1&rdquo;:
histograms[i][j] = histograms[i - 1][j] + 1 if i &gt; 0 else 1</p>
<p>for histogram in histograms:
res = max(res, self.largestRectangleHistogram(histogram))</p>
<p>return res</p>
<p>def largestRectangleHistogram(self, histogram):</p>
<p>if not histogram:
return 0</p>
<p>stack = []
res = 0
index = 0
n = len(histogram)</p>
<p>while index &lt; n:
if not stack or histogram[index] &gt;= histogram[stack[-1]]:
stack.append(index)
index += 1
else:
res = max(
res, histogram[stack.pop()] *
((index - stack[-1] - 1) if stack else index))</p>
<p>while stack:
height = histogram[stack.pop()]
res = max(res, height * ((n - stack[-1] - 1) if stack else n))</p>
<p>return res</p>
<p>maxtrix = [[&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;0&rdquo;],[&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;],[&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;,&ldquo;1&rdquo;],[&ldquo;1&rdquo;,&ldquo;0&rdquo;,&ldquo;0&rdquo;,</p>
<h2 id="121-best-time-to-buy-and-sell-stock">121 - Best Time to Buy and Sell Stock</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:

Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.

Example 2:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</code></pre></div><h3 id="notes">Notes</h3>
<p>Mark the minPrice and the minProfit</p>
<h3 id="solution">Solution</h3>
<p>#+begin_src python
class Solution:
def maxProfit(self, prices):
if not prices:
return 0</p>
<p>minPrice = prices[0]
maxProfit = 0</p>
<p>for price in prices:
if price &lt; minPrice:
minPrice = price
if price - minPrice &gt; maxProfit:
maxProfit = price</p>
<h2 id="122-best-time-to-buy-and-sell-stock-ii">122 - Best Time to Buy and Sell Stock II</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</code></pre></div><h3 id="notes">Notes</h3>
<h4 id="solution-1">Solution 1</h4>
<p>Find the valley and peak, save the local maxProfit, add it up when new valley is found.</p>
<h4 id="solution-2">Solution 2</h4>
<p>Simplify the solution 1:
we can sum up the profit when we go up step by step.</p>
<h3 id="solution">Solution</h3>
<h4 id="solution-1">Solution 1:</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxProfit</span>(self, prices):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> prices:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        valley <span style="color:#f92672">=</span> prices[<span style="color:#ae81ff">0</span>]
        maxProfit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> price <span style="color:#f92672">in</span> prices:
            <span style="color:#66d9ef">if</span> price <span style="color:#f92672">-</span> valley <span style="color:#f92672">&lt;</span> maxProfit:
                valley <span style="color:#f92672">=</span> price <span style="color:#75715e"># new valley</span>
                res <span style="color:#f92672">+=</span> maxProfit <span style="color:#75715e"># add the current maxProfit</span>
                maxProfit <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e"># reset current maxProfit</span>
            <span style="color:#66d9ef">else</span>:
                maxProfit <span style="color:#f92672">=</span> price <span style="color:#f92672">-</span> valley <span style="color:#75715e"># update the maxProfit when we still go up</span>

        <span style="color:#75715e"># remember to add the last maxProfit.</span>
        <span style="color:#75715e"># 1. When we are on the peak. maxProfit &gt; 0, it should be added</span>
        <span style="color:#75715e"># 2. When we are in the vally, maxProfit = 0, would not affect the value</span>
        res <span style="color:#f92672">+=</span> maxProfit

        <span style="color:#66d9ef">return</span> res
</code></pre></div><h4 id="solution-2">Solution 2:</h4>
<p>#+begin_src python
class Solution:
def maxProfit(self, prices):
res = 0
for i in range(1, len(prices)):
if (prices[i-1] &lt; prices[i]):</p>
<h2 id="123-best-time-to-buy-and-sell-stock-iii">123 - Best Time to Buy and Sell Stock III</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most two transactions.

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</code></pre></div><h3 id="notes">Notes</h3>
<p>A very good article about how to solve this kind of problem generally. <a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/tuan-mie-gu-piao-wen-ti">[Reference]​</a></p>
<p>DP problem have three main sub problems:</p>
<ol>
<li>states =&gt; DP-Table</li>
<li>states transition =&gt; Transition</li>
<li>base cases =&gt; Padding or initializtion</li>
</ol>
<p>DP is also a form of brute force method. We have to find all the states of the problem.
And we try to use the sub-states to apply the state transitions to simplify the calculation.</p>
<p>How many states do we have in all:</p>
<ol>
<li>number of days, n</li>
<li>numebr of transactions, k = 2</li>
<li>have the stock or not, 0 or 1</li>
</ol>
<p>state[n][k][0 or 1] means:</p>
<p>the state at the n-th day, already k times transactions, have or have not the stock in hand.</p>
<p>State Transition:</p>
<ol>
<li>
<p>state[n][k][0] = max(state[n-1][k][0], state[n-1][k][1] + prices)</p>
<p>state: I have no stock in hand</p>
<p>It can transit from two states:</p>
<ul>
<li>
<p>I do not have stock yesterday               =&gt; state[n-1][k][0]</p>
</li>
<li>
<p>I do have stock yesterday, and I sell it    =&gt; state[n-1][k][1] + price</p>
</li>
</ul>
</li>
<li>
<p>state[n][k][1] = max(state[n-1][k][1], state[n-1][k-1][0] - prices)</p>
<p>state: I have stock in hand</p>
<p>It can transit from two states:</p>
<ul>
<li>
<p>I do have stock yesterday                   =&gt; state[n-1][k][1]</p>
</li>
<li>
<p>I don&rsquo;t have stock yesterday, and I buy it  =&gt; state[n-1][k-1][1] - price</p>
</li>
</ul>
</li>
</ol>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxProfit</span>(self, prices):
        max_k <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
        dp <span style="color:#f92672">=</span> [ [ [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(max_k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) ] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(prices))]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(prices)):
            <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, max_k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                    dp[i][k][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
                    dp[i][k][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>prices[i]
                <span style="color:#66d9ef">else</span>:
                    dp[i][k][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][k][<span style="color:#ae81ff">0</span>], dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][k][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> prices[i])
                    dp[i][k][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][k][<span style="color:#ae81ff">1</span>], dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> prices[i])

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][max_k][<span style="color:#ae81ff">0</span>]
</code></pre></div><p>Simple Version: reduce the DP-Table</p>
<p>We only have to maintain two 1-dimentional states.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> sys
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxProfit</span>(self, prices):
        buy <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span>sys<span style="color:#f92672">.</span>maxsize] <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>
        sell <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>
        <span style="color:#66d9ef">for</span> price <span style="color:#f92672">in</span> prices:
            buy[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(buy[<span style="color:#ae81ff">1</span>], sell[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span>price)
            buy[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> max(buy[<span style="color:#ae81ff">2</span>], sell[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span>price)
            sell[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(sell[<span style="color:#ae81ff">1</span>], buy[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>price)
            sell[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> max(sell[<span style="color:#ae81ff">2</span>], buy[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span>price)
            <span style="color:#66d9ef">print</span>(buy)
            <span style="color:#66d9ef">print</span>(sell)
        <span style="color:#66d9ef">return</span> sell[<span style="color:#ae81ff">2</span>]

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>maxProfit([<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">4</span>]))
</code></pre></div><p>#+begin_example
[-9223372036854775807, -3, -3]
[0, 0, 0]
[-9223372036854775807, -3, -3]
[0, 0, 0]
[-9223372036854775807, -3, -3]
[0, 2, 2]
[-9223372036854775807, 0, 2]
[0, 2, 2]
[-9223372036854775807, 0, 2]
[0, 2, 2]
[-</p>
<h2 id="188-best-time-to-buy-and-sell-stock-iv">188 - Best Time to Buy and Sell Stock IV</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Say you have an array for which the i-th element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

Example 1:

Input: [2,4,1], k = 2
Output: 2
Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.

Example 2:

Input: [3,2,6,5,0,3], k = 2
Output: 7
Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.
             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
</code></pre></div><h3 id="notes">Notes</h3>
<p>See problem 121, 122 and 123.</p>
<p>Note the k.
If it is too large(&gt;= n/2), treat it as if with infinitive transactions. We don&rsquo;t want to loop through a too large k.</p>
<h3 id="solution">Solution</h3>
<p>#+begin_src python
class Solution:
def maxProfit(self, k, prices):
if not prices:
return 0</p>
<p>n = len(prices)
if k &gt;= n//2: # treat it as infinitive transactions
res = 0
for i in range(1, n):
if prices[i] &gt; prices[i-1]:
res += prices[i] - prices[i-1]
return res</p>
<p>buy = [-sys.maxsize] * (k+1)
sell = [0] * (k+1)</p>
<p>for price in prices:
for i in range(1, k+1):
buy[i] = max(buy[i], sell[i-1]-price)
sell[i] = max(sel</p>
<h2 id="309-best-time-to-buy-and-sell-stock-with-cooldown">309 - Best Time to Buy and Sell Stock with Cooldown</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:

You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
Example:

Input: [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
</code></pre></div><h3 id="notes">Notes</h3>
<h3 id="solution">Solution</h3>
<p>#+begin_src python
import sys
class Solution:
def maxProfit(self, prices):
dp_buy = -sys.maxsize
dp_sell = 0
dp_pre_0 = 0</p>
<p>for price in prices:
tmp = dp_sell
dp_sell = max(dp_sell, dp_buy + price)
dp_buy = max(dp_buy, dp_pre_0 - price)
dp_pre_0 = tmp</p>
<h2 id="104-maximum-depth-of-binary-tree">104 - Maximum Depth of Binary Tree</h2>
<p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
</code></pre></div><h3 id="notes">Notes</h3>
<p>Recursion is your friend!</p>
<h3 id="solution">Solution</h3>
<p>#+begin_src python
class Solution:
def maxDepth(self, root):
return 1 + max(self.maxDepth(root.right), self.maxDepth(</p>
<h2 id="21-merge-two-sorted-lists">21 - Merge Two Sorted Lists</h2>
<p><a href="https://leetcode.com/problems/merge-two-sorted-lists/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4
</code></pre></div><h3 id="notes">Notes</h3>
<p>Recursion is your friend!</p>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-recursive">Solution 1: Recursive</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mergeTwoLists</span>(self, l1, l2):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> l1:
            <span style="color:#66d9ef">return</span> l2
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> l2:
            <span style="color:#66d9ef">return</span> l1

        <span style="color:#66d9ef">if</span> l1<span style="color:#f92672">.</span>val <span style="color:#f92672">&gt;</span> l2<span style="color:#f92672">.</span>val:
            l2<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>mergeTwoLists(l1, l2<span style="color:#f92672">.</span>next)
            <span style="color:#66d9ef">return</span> l2
        <span style="color:#66d9ef">else</span>:
            l1<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>mergeTwoLists(l1<span style="color:#f92672">.</span>next, l2)
            <span style="color:#66d9ef">return</span> l1
</code></pre></div><h2 id="101-symmetric-tree">101 - Symmetric Tree</h2>
<p><a href="https://leetcode.com/problems/symmetric-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3


But the following [1,2,2,null,3,null,3] is not:

    1
   / \
  2   2
   \   \
   3    3
</code></pre></div><h3 id="notes">Notes</h3>
<p>Recursion !</p>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-recursive">Solution 1: recursive</h4>
<p>#+begin_src python
class Solution:
def isSymmetric(self, root):
if not root:
return True
return self.isMirrored(root.left, root.right)</p>
<p>def isMirrored(self, left, right):</p>
<pre><code>      if not left and not right:
          return True
      elif not left:
          return False
      elif not right:
          return False
      else:
          if left.val == right.val:
              return self.isMirrored(left.left, right.right) and \\
                  self.isMirrored(left.right, right.left)
          else:
              return False
</code></pre>
<p>#+end_sr</p>
<h2 id="198-house-robber">198 - House Robber</h2>
<p><a href="https://leetcode.com/problems/house-robber/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
</code></pre></div><h3 id="notes">Notes</h3>
<p>States: 1. house, 2. rob or not rob -&gt; dp[i][0 or 1]</p>
<p>Transition: dp[i][0] = max(dp[i-1][0], dp[i-1][1]), dp[i][1] = dp[i-1][0] + nums[i]</p>
<p>Base Case: dp[0][0] = 0, dp[0][1] = 0</p>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rob</span>(self, nums):
        robbed, notRobbed <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
            robbed, notRobbed <span style="color:#f92672">=</span> notRobbed <span style="color:#f92672">+</span> i, max(robbed, notRobbed)
</code></pre></div><h2 id="300-longest-increasing-subsequence">300 - Longest Increasing Subsequence</h2>
<p><a href="https://leetcode.com/problems/longest-increasing-subsequence/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an unsorted array of integers, find the length of longest increasing subsequence.

Example:

Input: [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
Note:

There may be more than one LIS combination, it is only necessary for you to return the length.
Your algorithm should run in O(n2) complexity.
Follow up: Could you improve it to O(n log n) time complexity?
</code></pre></div><h3 id="solution">Solution</h3>
<p>DP problem.</p>
<p>States: index, dp[index] = longest increasing subsequence at this position</p>
<p>Transition: if nums[j] &lt; nums[i]: dp[i] = max(dp[i], dp[j] + 1)</p>
<p>Base Case: dp[0] = 1</p>
<h4 id="solution-1-dp-with-o--n-2">Solution 1: DP with O(n^2)</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lengthOfLIS</span>(self, nums):
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> len(nums)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i):
               <span style="color:#66d9ef">if</span> nums[j] <span style="color:#f92672">&lt;</span> nums[i]:
                   dp[i] <span style="color:#f92672">=</span> max(dp[i], dp[j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)

       <span style="color:#66d9ef">return</span> max(dp) <span style="color:#66d9ef">if</span> nums <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h4 id="solution-2-dp-with-binary-search-for-lis">Solution 2: DP with binary search for LIS</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lengthOfLIS</span>(self, nums):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        dp <span style="color:#f92672">=</span> [nums[<span style="color:#ae81ff">0</span>]]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)):
            <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">&gt;</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                dp<span style="color:#f92672">.</span>append(nums[i])
            <span style="color:#66d9ef">else</span>:
                j <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>binarySearch(dp, nums[i])
                dp[j] <span style="color:#f92672">=</span> nums[i]

        <span style="color:#66d9ef">return</span> len(dp)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">binarySearch</span>(self, nums, target):
        l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        r <span style="color:#f92672">=</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> l <span style="color:#f92672">&lt;=</span> r:
            mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">if</span> nums[mid] <span style="color:#f92672">&gt;</span> target:
                r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> nums[mid] <span style="color:#f92672">&lt;</span> target:
                l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">return</span> mid

        <span style="color:#66d9ef">return</span> l
</code></pre></div><p>Time: O(nlogn)</p>
<p>Space: O(n)</p>
<h2 id="322-coin-change">322 - Coin Change</h2>
<p><a href="https://leetcode.com/problems/coin-change/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:

Input: coins = [1, 2, 5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
Example 2:

Input: coins = [2], amount = 3
Output: -1

Note:
You may assume that you have an infinite number of each kind of coin.
</code></pre></div><h3 id="notes">Notes</h3>
<p>DP problem</p>
<p>States: amount</p>
<p>Transition: dp[i] = min(dp[i], dp[i-coins[j]]+1)</p>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">coinChange</span>(self, coins, amount):
        dp <span style="color:#f92672">=</span> [float(<span style="color:#e6db74">&#39;inf&#39;</span>)] <span style="color:#f92672">*</span> (amount <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)

        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, amount <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(coins)):
                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">-</span> coins[j] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                    dp[i] <span style="color:#f92672">=</span> min(dp[i], dp[i <span style="color:#f92672">-</span> coins[j]] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">if</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> float(<span style="color:#e6db74">&#39;inf&#39;</span>) <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="152-maximum-product-subarray">152 - Maximum Product Subarray</h2>
<p><a href="https://leetcode.com/problems/maximum-product-subarray/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.

Example 1:

Input: [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:

Input: [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
</code></pre></div><h3 id="notes">Notes</h3>
<p>DP problem:</p>
<ul>
<li>
<p>States:
We have to know two previous states to deduct the current max product:</p>
<ul>
<li>index</li>
<li>max for positive or min for negative</li>
</ul>
<p>So the DP Table is dp[i(index)][0 or 1(max or min)]</p>
</li>
<li>
<p>Transition:</p>
<ul>
<li>
<p>if nums[i] &gt;= 0:
dp[i][0] = max(nums[i], dp[i-1][0] * nums[i])
dp[i][1] = dp[i-1][1] * nums[i]</p>
</li>
<li>
<p>if nums[i] &lt; 0:</p>
<p>dp[i][0] = dp[i-1][1] * nums[i])
dp[i][1] = min(nums[i], dp[i-1][0] * nums[i]</p>
</li>
</ul>
</li>
<li>
<p>Base case:</p>
<p>if there is only one element:</p>
<p>dp[0][0] = dp[0][1] = nums[0]</p>
</li>
</ul>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-dp">Solution 1: DP</h4>
<p>Original Version:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxProduct</span>(self, nums):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums))]
        res <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)):
            <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> max(nums[i], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> nums[i])
                dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> nums[i]
            <span style="color:#66d9ef">else</span>:
                dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> nums[i]
                dp[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> min(nums[i], nums[i] <span style="color:#f92672">*</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>])
            res <span style="color:#f92672">=</span> max(res, dp[i][<span style="color:#ae81ff">0</span>])
        <span style="color:#66d9ef">return</span> res
</code></pre></div><p>Simplify Version 1:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxProduct</span>(self, nums):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        pos <span style="color:#f92672">=</span> neg <span style="color:#f92672">=</span> res <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums[<span style="color:#ae81ff">1</span>:]:
            <span style="color:#66d9ef">if</span> i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>:
                pos <span style="color:#f92672">=</span> max(i, pos<span style="color:#f92672">*</span>i)
                neg <span style="color:#f92672">=</span> neg<span style="color:#f92672">*</span>i
            <span style="color:#66d9ef">else</span>:
                tmp <span style="color:#f92672">=</span> pos <span style="color:#75715e"># Important: remember the value, because we are gonna alter it.</span>
                pos <span style="color:#f92672">=</span> neg<span style="color:#f92672">*</span>i
                neg <span style="color:#f92672">=</span> min(tmp<span style="color:#f92672">*</span>i, i) <span style="color:#75715e"># Use the original value</span>
                <span style="color:#75715e"># We also can write as this, but we should notice it only works in like python or ruby</span>
                <span style="color:#75715e"># pos, neg = neg*i, min(pos*i, i), simplify to version 3</span>
            res <span style="color:#f92672">=</span> max(pos, res)
        <span style="color:#66d9ef">return</span> res
</code></pre></div><p>Simplify Version 2:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxProduct</span>(self, nums):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        pos <span style="color:#f92672">=</span> neg <span style="color:#f92672">=</span> res <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums[<span style="color:#ae81ff">1</span>:]:
            <span style="color:#66d9ef">if</span> i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>:
                pos, neg <span style="color:#f92672">=</span> max(i, pos<span style="color:#f92672">*</span>i), neg<span style="color:#f92672">*</span>i
            <span style="color:#66d9ef">else</span>:
                pos, neg <span style="color:#f92672">=</span> neg<span style="color:#f92672">*</span>i, min(i, pos<span style="color:#f92672">*</span>i)
            res <span style="color:#f92672">=</span> max(pos, res)
        <span style="color:#66d9ef">return</span> res
</code></pre></div><h4 id="solution-2-prefix-sum-and-suffix-sum">Solution 2: Prefix sum and Suffix sum</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxProduct</span>(self, nums):
        rnums <span style="color:#f92672">=</span> nums[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)):
            nums[i] <span style="color:#f92672">*=</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">or</span> <span style="color:#ae81ff">1</span>
            rnums[i] <span style="color:#f92672">*=</span> rnums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">or</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> max(nums<span style="color:#f92672">+</span>rnums)
</code></pre></div><p>Time: O(n)
Space: O(n)</p>
<h2 id="96-unique-binary-search-trees">96 - Unique Binary Search Trees</h2>
<p><a href="https://leetcode.com/problems/unique-binary-search-trees/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given n, how many structurally unique BST&#39;s (binary search trees) that store values 1 ... n?

Example:

Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST&#39;s:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</code></pre></div><h3 id="notes">Notes</h3>
<h4 id="solution-1-dp">Solution 1: DP</h4>
<p>In this dp problem, the hard part is to figure out the transition.</p>
<ul>
<li>
<p>States: n</p>
</li>
<li>
<p>Transition:</p>
<p>Some intuition:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">assume dp[0] = 1
dp[1] = dp[0]*dp[0]
dp[2] = dp[0]*dp[1] + dp[0]*dp[1]
dp[3] = dp[0]*dp[2] + dp[1]*dp[1] + dp[2]*dp[0]
dp[4] = dp[0]*dp[3] + dp[1]*dp[2] + dp[2]*dp[1] + dp[3]*dp[0]
dp[5] = dp[0]*dp[4] + dp[1]*dp[3] + dp[2]*dp[2] + dp[3]*dp[1] + dp[4]*dp[0]
dp[6] = dp[0]*dp[5] + dp[1]*dp[4] + dp[2]*dp[3] + dp[3]*dp[2] + dp[4]*dp[1] + dp[5]*dp[0]
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, i):
        dp[i] <span style="color:#f92672">+=</span> dp[j]<span style="color:#f92672">*</span>dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>j]
</code></pre></div></li>
<li>
<p>Base case:
dp[0] = 1</p>
</li>
</ul>
<h4 id="solution-2-catalan-number">Solution 2: Catalan Number</h4>
<p><a href="https://en.wikipedia.org/wiki/Catalan%5Fnumber">Catalan Number</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Cn = 1/(n+1)(2n n) = (2n)!/(n+1)!n!

The first Catalan numbers for n = 0, 1, 2, 3, ... are

1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012,
742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190,
6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-dp">Solution 1: DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numTrees</span>(self, n):
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, i):
                dp[i] <span style="color:#f92672">+=</span> dp[j]<span style="color:#f92672">*</span>dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>j]

        <span style="color:#66d9ef">return</span> dp[n]
</code></pre></div><h4 id="solutiojn-2-catalan-number">Solutiojn 2: Catalan Number</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> math
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numTrees</span>(self, n):
        <span style="color:#66d9ef">return</span> math<span style="color:#f92672">.</span>factorial(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>n)<span style="color:#f92672">/</span>(math<span style="color:#f92672">.</span>factorial(n)<span style="color:#f92672">*</span>math<span style="color:#f92672">.</span>factorial(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))
</code></pre></div><h2 id="221-maximal-square">221 - Maximal Square</h2>
<p><a href="https://leetcode.com/problems/maximal-square/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a 2D binary matrix filled with 0&#39;s and 1&#39;s, find the largest square containing only 1&#39;s and return its area.

Example:

Input:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Output: 4
</code></pre></div><h3 id="notes">Notes</h3>
<p>DP Problem:</p>
<ul>
<li>
<p>States:</p>
<ul>
<li>position -&gt; [i][j]</li>
<li>how many continues 1 in vertical direction -&gt; [i][j][0]</li>
<li>how many continues 1 in horizontal direction -&gt; [i][j][1]</li>
<li>square value(or the length of the square) -&gt; [i][j][2]</li>
</ul>
<p>dp[i][j][0 or 1 or 2]</p>
</li>
<li>
<p>Transition:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">dp[i + 1][j + 1][0] = dp[i][j + 1][0] + 1
dp[i + 1][j + 1][1] = dp[i + 1][j][1] + 1
dp[i + 1][j + 1][2] = min(dp[i][j][2]+1, dp[i + 1][j + 1][0], dp[i + 1][j + 1][1])
</code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Base Case:</p>
<p>One padding row on vertical and horizontal direction, with value 0</p>
</li>
</ul>
<h3 id="solution">Solution</h3>
<p>Original Version
:</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maximalSquare</span>(self, matrix):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        dp <span style="color:#f92672">=</span> [[[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(matrix[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(matrix) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]
        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(matrix)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(matrix[<span style="color:#ae81ff">0</span>])):
                <span style="color:#66d9ef">if</span> matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>:
                    dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[i][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> min(dp[i][j][<span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>])
                    res <span style="color:#f92672">=</span> max(res, dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>])

        <span style="color:#66d9ef">return</span> res<span style="color:#f92672">*</span>res
</code></pre></div><p>Time: O(mn)
Space: O(mn)</p>
<p>Simplified Version 1: optimize the space, 3xn space
:</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maximalSquare</span>(self, matrix):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(matrix[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]
        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(matrix)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(matrix[<span style="color:#ae81ff">0</span>])):
                <span style="color:#66d9ef">if</span> matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>:
                    dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[j][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> min(dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, dp[j][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
                    res <span style="color:#f92672">=</span> max(res, dp[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>])
                <span style="color:#66d9ef">else</span>:
                    dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">return</span> res<span style="color:#f92672">*</span>res
</code></pre></div><p>Space: O(n)</p>
<p>Simplified Version 2: n space
:</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maximalSquare</span>(self, matrix):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(matrix[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]
        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        prev <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#75715e"># previous diagnol element</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(matrix)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(matrix[<span style="color:#ae81ff">0</span>])):
                temp <span style="color:#f92672">=</span> dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
                <span style="color:#66d9ef">if</span> matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>:
                    dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> min(prev, dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], dp[j]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    res <span style="color:#f92672">=</span> max(res, dp[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])
                <span style="color:#66d9ef">else</span>:
                    dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

                prev <span style="color:#f92672">=</span> temp

        <span style="color:#66d9ef">return</span> res<span style="color:#f92672">*</span>res
</code></pre></div><p>Simplified Version 3: in place
:</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maximalSquare</span>(self, matrix):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        m <span style="color:#f92672">=</span> len(matrix)
        n <span style="color:#f92672">=</span> len(matrix[<span style="color:#ae81ff">0</span>])

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(m):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
                <span style="color:#66d9ef">if</span> matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>:
                    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                        matrix[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
                    <span style="color:#66d9ef">else</span>:
                        matrix[i][j] <span style="color:#f92672">=</span> min(matrix[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>],
                                           matrix[i][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>],
                                           matrix[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    res <span style="color:#f92672">=</span> max(res, matrix[i][j])
                <span style="color:#66d9ef">else</span>:
                    matrix[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">return</span> res <span style="color:#f92672">*</span> res
</code></pre></div><p>Space: O(1)</p>
<h2 id="279-perfect-squares">279 - Perfect Squares</h2>
<p><a href="https://leetcode.com/problems/perfect-squares/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n.

Example 1:

Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
Example 2:

Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
</code></pre></div><h3 id="notes">Notes</h3>
<p>DP problem</p>
<ul>
<li>
<p>States: n</p>
</li>
<li>
<p>Transition:</p>
</li>
<li>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">dp[i] = min([_dp[i-j*j]+1 if i-j*j &gt;= 0 else break for j in range(1, sqrt(i)+1)])
</code></pre></div></li>
<li>
<p>Base case:</p>
<ul>
<li>dp[0] = 0</li>
<li>dp[i] = i</li>
</ul>
</li>
</ul>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> math
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numSquares</span>(self, n):
        _dp <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>dp
        <span style="color:#66d9ef">if</span> len(_dp) <span style="color:#f92672">&gt;=</span> n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> _dp[n]
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(_dp), n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
                _dp <span style="color:#f92672">+=</span> [min([_dp[i<span style="color:#f92672">-</span>j<span style="color:#f92672">*</span>j]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, int(math<span style="color:#f92672">.</span>sqrt(i))<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">if</span> i<span style="color:#f92672">-</span>j<span style="color:#f92672">*</span>j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>])]
        <span style="color:#66d9ef">return</span> _dp[n]

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>numSquares(<span style="color:#ae81ff">12</span>))
</code></pre></div><h2 id="647-palindromic-substrings">647 - Palindromic Substrings</h2>
<p><a href="https://leetcode.com/problems/palindromic-substrings/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">
Given a string, your task is to count how many palindromic substrings in this string.

The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.

Example 1:

Input: &#34;abc&#34;
Output: 3
Explanation: Three palindromic strings: &#34;a&#34;, &#34;b&#34;, &#34;c&#34;.


Example 2:

Input: &#34;aaa&#34;
Output: 6
Explanation: Six palindromic strings: &#34;a&#34;, &#34;a&#34;, &#34;a&#34;, &#34;aa&#34;, &#34;aa&#34;, &#34;aaa&#34;.

Note:

The input string length won&#39;t exceed 1000.
</code></pre></div><h3 id="notes">Notes</h3>
<p>DP problem</p>
<ul>
<li>
<p>States:</p>
<p>left_index, right_index, mark if <code>s[left_index, right_index+1]</code> is palindromic</p>
</li>
<li>
<p>Transition:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">if s[l] == s[r]: # mark it only when both ends are same values

dp[l][r] = 1 if r == l              # if only one element
dp[l][r] = 1 if r+1 == l            # if only two elements
dp[l][r] = 1 if dp[l+1][r+1] = 1    # if the string in between is palindromic

results = results + 1
</code></pre></div></li>
<li>
<p>Base case:</p>
<p>initialize dp[i][j] = 0</p>
</li>
</ul>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countSubstrings</span>(self, s):
        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> len(s) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s))]
        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> range(len(s)):
            <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> range(r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> s[r] <span style="color:#f92672">==</span> s[l]:
                    <span style="color:#66d9ef">if</span> r <span style="color:#f92672">==</span> l <span style="color:#f92672">or</span> r<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> l <span style="color:#f92672">or</span> dp[l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][r<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
                        dp[l][r] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
                        res <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> res
<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>countSubstrings(<span style="color:#e6db74">&#34;aba&#34;</span>))
</code></pre></div><h2 id="5-longest-palindromic-substring">5 - Longest Palindromic Substring</h2>
<p><a href="https://leetcode.com/problems/longest-palindromic-substring/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: &#34;babad&#34;
Output: &#34;bab&#34;
Note: &#34;aba&#34; is also a valid answer.
Example 2:

Input: &#34;cbbd&#34;
Output: &#34;bb&#34;
</code></pre></div><h3 id="notes">Notes</h3>
<p>DP problem</p>
<ul>
<li>
<p>States:</p>
<p>left_index, right_index, mark if <code>s[left_index, right_index+1]</code> is palindromic</p>
</li>
<li>
<p>Transition:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">if s[l] == s[r]: # mark it only when both ends are same values

dp[l][r] = 1 if r == l              # if only one element
dp[l][r] = 1 if r+1 == l            # if only two elements
dp[l][r] = 1 if dp[l+1][r+1] = 1    # if the string in between is palindromic

results = s[l:r+1] if r-l+1&gt;len(results) # comparing the length, record the maximum
</code></pre></div></li>
<li>
<p>Base case:</p>
<p>initialize dp[i][j] = 0</p>
</li>
</ul>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-dp">Solution 1: DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestPalindrome</span>(self, s: str) <span style="color:#f92672">-&gt;</span> str:
        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> len(s) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s))]
        res <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
        <span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> range(len(s)):
            <span style="color:#66d9ef">for</span> l <span style="color:#f92672">in</span> range(r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> s[l] <span style="color:#f92672">==</span> s[r]:
                    <span style="color:#66d9ef">if</span> l <span style="color:#f92672">==</span> r <span style="color:#f92672">or</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> r <span style="color:#f92672">or</span> dp[l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][r <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
                        dp[l][r] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
                        <span style="color:#66d9ef">if</span> r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> len(res):
                            res <span style="color:#f92672">=</span> s[l:r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]
        <span style="color:#66d9ef">return</span> res
</code></pre></div><h4 id="solution-2-central-expansion">Solution 2: Central Expansion</h4>
<h2 id="136-single-number">136 - Single Number</h2>
<p><a href="https://leetcode.com/problems/single-number/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-empty array of integers, every element appears twice except for one. Find that single one.

Note:

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

Example 1:

Input: [2,2,1]
Output: 1
Example 2:

Input: [4,1,2,1,2]
Output: 4
</code></pre></div><h3 id="notes">Notes</h3>
<h4 id="solution-1-hash-table">Solution 1: Hash Table</h4>
<h4 id="solution-2-bit-manipulation">Solution 2: Bit manipulation</h4>
<p>Consider XOR all element together. The left number is the single number.</p>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-hash-table">Solution 1: Hash Table</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">singleNumber</span>(self, nums):
        table <span style="color:#f92672">=</span> {}
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
            table[i] <span style="color:#f92672">=</span> table<span style="color:#f92672">.</span>get(i, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> table:
            <span style="color:#66d9ef">if</span> table[k] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
                <span style="color:#66d9ef">return</span> k
</code></pre></div><h4 id="solution-2-bit-manipulation-for-finding-the-single-number">Solution 2: Bit manipulation for finding the single number</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">singleNumber</span>(self, nums):

        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
            res <span style="color:#f92672">^=</span> i

        <span style="color:#66d9ef">return</span> res

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>singleNumber([<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>]))
</code></pre></div><h4 id="solution-3-python-reduce">Solution 3: Python reduce</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> functools <span style="color:#f92672">import</span> reduce
<span style="color:#f92672">import</span> operator
nums <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>]
<span style="color:#66d9ef">print</span>(reduce(<span style="color:#66d9ef">lambda</span> x, y: x <span style="color:#f92672">^</span> y, nums))
<span style="color:#66d9ef">print</span>(reduce(operator<span style="color:#f92672">.</span>xor, nums))
</code></pre></div><h2 id="202-happy-number">202 - Happy Number</h2>
<p><a href="https://leetcode.com/problems/happy-number/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write an algorithm to determine if a number is &#34;happy&#34;.

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example:

Input: 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
</code></pre></div><h3 id="notes">Notes</h3>
<p>Hash Table</p>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isHappy</span>(self, n):
        table <span style="color:#f92672">=</span> {}

        <span style="color:#66d9ef">while</span> n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>:
            x <span style="color:#f92672">=</span> n
            n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
            <span style="color:#66d9ef">while</span> x <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
                n <span style="color:#f92672">+=</span> (x <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
                x <span style="color:#f92672">//=</span> <span style="color:#ae81ff">10</span>

            <span style="color:#66d9ef">if</span> table<span style="color:#f92672">.</span>get(n):
                <span style="color:#66d9ef">return</span> False
            <span style="color:#66d9ef">else</span>:
                table[n] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> True


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isHappy</span>(self, n):
        mem <span style="color:#f92672">=</span> set()
        <span style="color:#66d9ef">while</span> n <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> mem:
            mem<span style="color:#f92672">.</span>add(n)
            n <span style="color:#f92672">=</span> sum(int(i)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> str(n))
        <span style="color:#66d9ef">return</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="338-counting-bits">338 - Counting Bits</h2>
<p><a href="https://leetcode.com/problems/counting-bits/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&#39;s in their binary representation and return them as an array.

Example 1:

Input: 2
Output: [0,1,1]
Example 2:

Input: 5
Output: [0,1,1,2,1,2]
</code></pre></div><h3 id="notes">Notes</h3>
<p>DP problem</p>
<ul>
<li>States: index</li>
<li>Transition:</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">dp[0] = 0
dp[1] = dp[1-1] + 1 = 1
dp[2] = dp[2-2] + 1 = 1
dp[3] = dp[3-2] + 1 = 2
dp[4] = dp[4-4] + 1 = 1
dp[5] = dp[5-4] + 1 = 2
dp[6] = dp[6-4] + 1 = 2
dp[7] = dp[7-4] + 1 = 3
dp[8] = dp[8-8] + 1 = 1
dp[9] = dp[9-8] + 1 = 2
dp[i] = dp[i - log_2 (i)] + 1

A trick using bit manipulation:

8 -&gt; 1000
9 -&gt; 1001
10 -&gt; 1010

9 &amp; 8 -&gt; 1001 &amp; 1000 -&gt; 1000 dp[8] + 1  = 2
10 &amp; 9 -&gt; 1010 &amp; 1001 -&gt; 1000 dp[8] + 1 = 2
11 &amp; 10 -&gt; 1011 &amp; 1010 -&gt; 1010 dp[10] + 1 = 3
12 &amp; 11 -&gt; 1100 &amp; 1011 -&gt; 1000 dp[8] + 1 = 2

dp[i] = dp[i &amp; (i-1)] + 1
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-dp">Solution 1: DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countBits</span>(self, num):
        offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> offset <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> i:
                offset <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>
            dp[i] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">-</span> offset] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> dp
</code></pre></div><h4 id="solution-2-bit-manipulation-on-couting-bits">Solution 2: Bit manipulation on couting bits</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countBits</span>(self, num):
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
            dp[i] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">&amp;</span> (i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> dp
</code></pre></div><h4 id="solution-3">Solution 3:</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countBits</span>(self, num):
        res<span style="color:#f92672">=</span>[<span style="color:#ae81ff">0</span>]
        <span style="color:#66d9ef">while</span> len(res)<span style="color:#f92672">&lt;=</span>num:
            res<span style="color:#f92672">+=</span>[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> res]
        <span style="color:#66d9ef">return</span> res[:num<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h4 id="solution-4">Solution 4:</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countBits</span>(self, num):
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, num<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>:
                dp[i] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>]
            <span style="color:#66d9ef">else</span>:
                dp[i] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> dp[num]
</code></pre></div><h2 id="494-target-sum">494 - Target Sum</h2>
<p><a href="https://leetcode.com/problems/target-sum/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.

Find out how many ways to assign symbols to make sum of integers equal to target S.

Example 1:
Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.
Note:
The length of the given array is positive and will not exceed 20.
The sum of elements in the given array will not exceed 1000.
Your output answer is guaranteed to be fitted in a 32-bit integer.
</code></pre></div><h3 id="solution">Solution</h3>
<p>DP problem. The hardest part of this problem is to find the states.</p>
<p>What states do we have to calculate the current result, which is the number of ways of reaching the target.</p>
<ul>
<li>
<p>States:</p>
<ul>
<li>index: how many different numbers -&gt; n</li>
<li>sum: how many different possible sums -&gt; [-sum(nums), +sum(nums)]</li>
</ul>
<p>The tricky part is how you present the range of sum in an array.</p>
<p>You have to add an offest as large as the sum(nums) to shift the range into the positive side.</p>
<p>So it becomes [0, 2sum(nums)]</p>
<p>For example:</p>
<p>[1, 1, 1, 1, 1], you have a range of [-5, 5].</p>
<p>-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5</p>
<p>Add an offset of sum = 5</p>
<p>0,  1,  2,  3,  4, 5, 6, 7, 8, 9, 10  -&gt; 11 numbers</p>
<p>dp should have a length of 2sum(nums) + 1</p>
</li>
<li>
<p>Transition:</p>
</li>
</ul>
<p>We need all the sum values of the previous number to calculate the current one.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>sum<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
    <span style="color:#66d9ef">if</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>: <span style="color:#75715e"># only check the ones, which have been reached</span>
      <span style="color:#66d9ef">if</span> j<span style="color:#f92672">+</span>nums[i] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>sum <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>: <span style="color:#75715e"># sign + to the current number, we transit from j to j+nums[i]</span>
        dp[i][j<span style="color:#f92672">+</span>nums[i]] <span style="color:#f92672">+=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]
      <span style="color:#66d9ef">if</span> j<span style="color:#f92672">-</span>nums[i] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>: <span style="color:#75715e"># sign + to the current number, we transit from j to j-nums[i]</span>
        dp[i][j<span style="color:#f92672">-</span>nums[i]] <span style="color:#f92672">+=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]
</code></pre></div><ul>
<li>Base case:</li>
</ul>
<p>We start from the offset.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># the first number with symbols</span>
dp[<span style="color:#ae81ff">0</span>][offset<span style="color:#f92672">+</span>nums[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
dp[<span style="color:#ae81ff">0</span>][offset<span style="color:#f92672">-</span>nums[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p><strong>Important</strong>:
You have to use += 1, not only = 1, because the number can be 0.</p>
<p>For exmaple: we take sum = 5
When the first number is 1 (not 0):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">d[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span><span style="color:#f92672">+</span>sum <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
d[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span><span style="color:#f92672">+</span>sum <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>It means:</p>
<p>there is one ways to reach 1 (6 - offset)</p>
<p>there is one ways to reach -1 (4 - offset)</p>
<p>When the first number is 0:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">d[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span><span style="color:#f92672">+</span>sum <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
d[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span><span style="color:#f92672">+</span>sum <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span> dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</code></pre></div><p>It means there are 2 ways to reach 0 (5 - offset)</p>
<h4 id="solution-1-2d-dp">Solution 1: 2D - DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>():
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findTargetSumWays</span>(self, nums, S):
        l <span style="color:#f92672">=</span> len(nums)
        n <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> sum(nums) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        offset <span style="color:#f92672">=</span> sum(nums)

        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums]

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#75715e"># base case</span>
        dp[<span style="color:#ae81ff">0</span>][offset <span style="color:#f92672">-</span> nums[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        dp[<span style="color:#ae81ff">0</span>][offset <span style="color:#f92672">+</span> nums[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
                <span style="color:#66d9ef">if</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                    <span style="color:#66d9ef">if</span> j <span style="color:#f92672">+</span> nums[i] <span style="color:#f92672">&lt;</span> n:
                        dp[i][j <span style="color:#f92672">+</span> nums[i]] <span style="color:#f92672">+=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]
                    <span style="color:#66d9ef">if</span> j <span style="color:#f92672">-</span> nums[i] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                        dp[i][j <span style="color:#f92672">-</span> nums[i]] <span style="color:#f92672">+=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][offset <span style="color:#f92672">+</span> S]


<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>findTargetSumWays([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">3</span>))
</code></pre></div><p>Time: O(l*n)
Space: O(l*n)</p>
<h4 id="solution-2-1d-dp">Solution 2: 1D - DP</h4>
<p>We notice that, to calculate the dp array at the current index, we only have to know one previous row.</p>
<p>So we only have to maintain two dp arrays to record previous values and current values respectly.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findTargetSumWays</span>(self, nums, S):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        l <span style="color:#f92672">=</span> len(nums)
        n <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> sum(nums) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        offset <span style="color:#f92672">=</span> sum(nums)
        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums]

        dp[<span style="color:#ae81ff">0</span>][offset <span style="color:#f92672">+</span> nums[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        dp[<span style="color:#ae81ff">0</span>][offset <span style="color:#f92672">-</span> nums[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, l):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
                <span style="color:#66d9ef">if</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                    <span style="color:#66d9ef">if</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">&lt;</span> n:
                        dp[i][j <span style="color:#f92672">+</span> nums[i]] <span style="color:#f92672">+=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j]
                    <span style="color:#66d9ef">if</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                        dp[i][j <span style="color:#f92672">-</span> nums[i]] <span style="color:#f92672">+=</span> dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][offset <span style="color:#f92672">+</span> S]

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>findTargetSumWays([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">3</span>))
</code></pre></div><h2 id="283-move-zeros">283 - Move Zeros</h2>
<p><a href="https://leetcode.com/problems/move-zeroes/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array nums, write a function to move all 0&#39;s to the end of it while maintaining the relative order of the non-zero elements.

Example:

Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
Note:

You must do this in-place without making a copy of the array.
Minimize the total number of operations.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Two pointers.</p>
<p>One pointer is for the start of 0.</p>
<p>One pointer keeps going forward.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">moveZeros</span>(self, nums):

        p1, p2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> p2 <span style="color:#f92672">&lt;</span> len(nums):
            <span style="color:#66d9ef">if</span> nums[p1] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
                p1 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> nums[p2] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
                nums[p1], nums[p2] <span style="color:#f92672">=</span> nums[p2], nums[p1]
                p1 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            p2 <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> nums
</code></pre></div><h2 id="416-partition-equal-subset-sum">416 - Partition Equal Subset Sum</h2>
<p><a href="https://leetcode.com/problems/partition-equal-subset-sum/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

Note:

Each of the array element will not exceed 100.
The array size will not exceed 200.


Example 1:

Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].


Example 2:

Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.
</code></pre></div><h3 id="solution">Solution</h3>
<p>DP problem, it is similar to problem 494 Target Sum.</p>
<p>Maintain a dp table: dp[i][sum]. Don&rsquo;t forget to the offset.</p>
<p>Transition:
dp[i][j-nums[i]] += dp[i-1][j]
dp[i][j+nums[i]] += dp[i-1][j]</p>
<p>When the transition is only depend on the last row, usually you always can transform the dp table to 1 dimensional.</p>
<h4 id="solution-1-1d-dp">Solution 1: 1D-DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canPartition</span>(slef, nums):
        nums_sum <span style="color:#f92672">=</span> sum(nums)
        <span style="color:#66d9ef">if</span> nums_sum <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> False

        target <span style="color:#f92672">=</span> nums_sum<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>
        n <span style="color:#f92672">=</span> target <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

        dp <span style="color:#f92672">=</span> [False] <span style="color:#f92672">*</span> n
        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> True
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> reversed(range(nums[i], n)):
                dp[j] <span style="color:#f92672">=</span> dp[j<span style="color:#f92672">-</span>nums[i]] <span style="color:#f92672">or</span> dp[j]
                <span style="color:#66d9ef">if</span> dp[target]:
                    <span style="color:#66d9ef">return</span> True
        <span style="color:#66d9ef">return</span> dp[target]
</code></pre></div><p>Time: O(len(nums)*sum(nums))</p>
<p>Space: O(len(nums)*sum(nums))</p>
<h4 id="solution-2-bit-manipulation-for-maintaning-the-dp-table">Solution 2: Bit manipulation for maintaning the dp table</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canPartition</span>(self, nums):
        s <span style="color:#f92672">=</span> sum(nums)
        <span style="color:#66d9ef">if</span> s<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> False

        bits <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
            bits <span style="color:#f92672">|=</span> bits <span style="color:#f92672">&lt;&lt;</span> i

        <span style="color:#66d9ef">return</span> (bits <span style="color:#f92672">&gt;&gt;</span> (s<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>)) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>Time: O(n)</p>
<p>Space: O(1) maybe, depends on the sum of the array, the bits can be longer</p>
<h2 id="698-partition-to-k-equal-sum-subsets">698 - Partition to K Equal Sum Subsets</h2>
<p><a href="https://leetcode.com/problems/partition-to-k-equal-sum-subsets/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array of integers nums and a positive integer k, find whether it&#39;s possible to divide this array into k non-empty subsets whose sums are all equal.



Example 1:

Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4
Output: True
Explanation: It&#39;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.


Note:

1 &lt;= k &lt;= len(nums) &lt;= 16.
0 &lt; nums[i] &lt; 10000.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
</code></pre></div><h2 id="215-kth-largest-element-in-an-array">215 - Kth Largest Element in an Array</h2>
<p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">215. Kth Largest Element in an Array
Medium

3152

222

Add to List

Share
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:

Input: [3,2,1,5,6,4] and k = 2
Output: 5
Example 2:

Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
Note:
You may assume k is always valid, 1 ≤ k ≤ array&#39;s length.
</code></pre></div><h3 id="solution">Solution</h3>
<p>The naive solution would be to maintain an array of length k and update the array
in each iteration to keep the first kth largest element in the array</p>
<h4 id="solution-1-array-of-k">Solution 1: Array of k</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findKthLargest</span>(self, nums, k):
        l <span style="color:#f92672">=</span> []

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> l:
                l<span style="color:#f92672">.</span>append(i)
            <span style="color:#66d9ef">else</span>:
                len0 <span style="color:#f92672">=</span> len(l)
                <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(l)):
                    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;=</span> l[j]:
                        l <span style="color:#f92672">=</span> l[<span style="color:#ae81ff">0</span>:j] <span style="color:#f92672">+</span> [i] <span style="color:#f92672">+</span> l[j:]
                        <span style="color:#66d9ef">break</span>
                <span style="color:#66d9ef">if</span> len0 <span style="color:#f92672">==</span> len(l) <span style="color:#f92672">and</span> len0 <span style="color:#f92672">!=</span> k:
                    l<span style="color:#f92672">.</span>append(i)
                l <span style="color:#f92672">=</span> l[<span style="color:#ae81ff">0</span>:k]
        <span style="color:#66d9ef">return</span> l[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><p>Time: O(nk)</p>
<p>Space: O(k)</p>
<h4 id="solution-2-partition-to-find-the-kth-largest">Solution 2: Partition to find the kth largest</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findKthLargest</span>(self, nums, k):
        pos <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>partition(nums, <span style="color:#ae81ff">0</span>, len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">if</span> pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> k:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>findKthLargest(nums[pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>:], k <span style="color:#f92672">-</span> pos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">elif</span> pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> k:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>findKthLargest(nums[<span style="color:#ae81ff">0</span>:pos], k)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> nums[pos]

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">partition</span>(self, nums, l, r):
        p <span style="color:#f92672">=</span> r

        <span style="color:#66d9ef">while</span>(l <span style="color:#f92672">&lt;</span> r):
            <span style="color:#66d9ef">while</span> l <span style="color:#f92672">&lt;</span> r <span style="color:#f92672">and</span> nums[l] <span style="color:#f92672">&gt;</span> nums[p]:
                l <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">while</span> l <span style="color:#f92672">&lt;</span> r <span style="color:#f92672">and</span> nums[r] <span style="color:#f92672">&lt;=</span> nums[p]:
                r <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
            nums[l], nums[r] <span style="color:#f92672">=</span> nums[r], nums[l]
        nums[l], nums[p] <span style="color:#f92672">=</span> nums[p], nums[l]
        <span style="color:#66d9ef">return</span> l
</code></pre></div><p>Time: O(klogn)</p>
<p>Space: O(1)</p>
<h2 id="49-group-anagrams">49 - Group Anagrams</h2>
<p><a href="https://leetcode.com/problems/group-anagrams/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array of strings, group anagrams together.

Example:

Input: [&#34;eat&#34;, &#34;tea&#34;, &#34;tan&#34;, &#34;ate&#34;, &#34;nat&#34;, &#34;bat&#34;],
Output:
[
  [&#34;ate&#34;,&#34;eat&#34;,&#34;tea&#34;],
  [&#34;nat&#34;,&#34;tan&#34;],
  [&#34;bat&#34;]
]
Note:

All inputs will be in lowercase.
The order of your output does not matter.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Use the sorted string as key in hash table</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> collections
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">groupAnagrams</span>(self, strs):
        ans <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>defaultdict(list)
        <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> strs:
            ans[tuple(sorted(s))]<span style="color:#f92672">.</span>append(s)
        <span style="color:#66d9ef">return</span> list(ans<span style="color:#f92672">.</span>values())
</code></pre></div><p>Or use the counter</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> collections
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">groupAnagrams</span>(self, strs):
        ans <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>defaultdict(list)
        <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> strs:
            a <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">26</span>
            <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
                a[ord(c) <span style="color:#f92672">-</span> ord(<span style="color:#e6db74">&#39;a&#39;</span>)] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            ans[tuple(a)]<span style="color:#f92672">.</span>append(s)
        <span style="color:#66d9ef">return</span> list(ans<span style="color:#f92672">.</span>values())
</code></pre></div><h2 id="876-middle-of-the-linked-list">876 - Middle of the Linked List</h2>
<p><a href="https://leetcode.com/problems/middle-of-the-linked-list/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-empty, singly linked list with head node head, return a middle node of linked list.

If there are two middle nodes, return the second middle node.



Example 1:

Input: [1,2,3,4,5]
Output: Node 3 from this list (Serialization: [3,4,5])
The returned node has value 3.  (The judge&#39;s serialization of this node is [3,4,5]).
Note that we returned a ListNode object ans, such that:
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.
Example 2:

Input: [1,2,3,4,5,6]
Output: Node 4 from this list (Serialization: [4,5,6])
Since the list has two middle nodes with values 3 and 4, we return the second one.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-two-pointer">Solution 1: two-pointer</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">middleNode</span>(self, head: ListNode) <span style="color:#f92672">-&gt;</span> ListNode:
        p1 <span style="color:#f92672">=</span> p2 <span style="color:#f92672">=</span> head
        <span style="color:#66d9ef">while</span> p2 <span style="color:#f92672">and</span> p2<span style="color:#f92672">.</span>next:
            p2 <span style="color:#f92672">=</span> p2<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next
            p1 <span style="color:#f92672">=</span> p1<span style="color:#f92672">.</span>next

        <span style="color:#66d9ef">return</span> p1
</code></pre></div><h4 id="solution-2-counter">Solution 2: counter</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">middleNode</span>(self, head):
        mid <span style="color:#f92672">=</span> head
        count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">while</span> head:
            count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">if</span> count <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                mid <span style="color:#f92672">=</span> mid<span style="color:#f92672">.</span>next
            head <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span>next
        <span style="color:#66d9ef">return</span> mid
</code></pre></div><h2 id="844-backspace-string-compare">844 - Backspace String Compare</h2>
<p><a href="https://leetcode.com/problems/backspace-string-compare/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.

Example 1:

Input: S = &#34;ab#c&#34;, T = &#34;ad#c&#34;
Output: true
Explanation: Both S and T become &#34;ac&#34;.
Example 2:

Input: S = &#34;ab##&#34;, T = &#34;c#d#&#34;
Output: true
Explanation: Both S and T become &#34;&#34;.
Example 3:

Input: S = &#34;a##c&#34;, T = &#34;#a#c&#34;
Output: true
Explanation: Both S and T become &#34;c&#34;.
Example 4:

Input: S = &#34;a#c&#34;, T = &#34;b&#34;
Output: false
Explanation: S becomes &#34;c&#34; while T becomes &#34;b&#34;.
Note:

1 &lt;= S.length &lt;= 200
1 &lt;= T.length &lt;= 200
S and T only contain lowercase letters and &#39;#&#39; characters.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-stack">Solution 1: stack</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">backspaceCompare</span>(self, S, T):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>build(S) <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>build(T)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build</span>(self, s):
        res <span style="color:#f92672">=</span> []

        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
            <span style="color:#66d9ef">if</span> c <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;#&#34;</span>:
                res<span style="color:#f92672">.</span>append(c)
            <span style="color:#66d9ef">elif</span> res:
                res<span style="color:#f92672">.</span>pop()

        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(res)

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>backspaceCompare(<span style="color:#e6db74">&#34;ac#cc#&#34;</span>, <span style="color:#e6db74">&#34;ab#c&#34;</span>))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> functools <span style="color:#f92672">import</span> reduce

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">backspaceCompare</span>(self, S, T):
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">back</span>(res, c):
            <span style="color:#66d9ef">if</span> c <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;#&#34;</span>:
                res<span style="color:#f92672">.</span>append(c)
            <span style="color:#66d9ef">elif</span> res:
                res<span style="color:#f92672">.</span>pop()
            <span style="color:#66d9ef">return</span> res

        <span style="color:#66d9ef">return</span> reduce(back, S, []) <span style="color:#f92672">==</span> reduce(back, T, [])

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>backspaceCompare(<span style="color:#e6db74">&#34;ac#cc#&#34;</span>, <span style="color:#e6db74">&#34;ab#c&#34;</span>))
</code></pre></div><h4 id="solution-2-two-pointer-reserve">Solution 2: two pointer, reserve</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">backspaceCompare</span>(self, S, T):
        pS, pT <span style="color:#f92672">=</span> len(S) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, len(T) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        backS, backT <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">while</span> pS <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> pT <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">while</span> pS <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">if</span> S[pS] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;#&#34;</span>:
                    backS <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                    pS <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">elif</span> backS:
                    backS <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                    pS <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    <span style="color:#66d9ef">break</span>

            <span style="color:#66d9ef">while</span> pT <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">if</span> T[pT] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;#&#34;</span>:
                    backT <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                    pT <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">elif</span> backT:
                    backT <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                    pT <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    <span style="color:#66d9ef">break</span>

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> (pS <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> pT <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> S[pS] <span style="color:#f92672">==</span> T[pT]):
                <span style="color:#66d9ef">return</span> pS <span style="color:#f92672">==</span> pT <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

            pS <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
            pT <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> True
<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>backspaceCompare(<span style="color:#e6db74">&#34;###ac#b&#34;</span>, <span style="color:#e6db74">&#34;ab#b&#34;</span>))
</code></pre></div><h2 id="155-min-stack">155 - Min Stack</h2>
<p><a href="https://leetcode.com/problemset/all/?search=Min%20Stack">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.


Example:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; Returns -3.
minStack.pop();
minStack.top();      --&gt; Returns 0.
minStack.getMin();   --&gt; Returns -2.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Use a second stack to keep track of the min value.
Pay attention to the return value. Remember to return None when there is no result.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MinStack</span>:
    <span style="color:#66d9ef">def</span> __init__(self):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        initialize your data structure here.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>stack <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>min <span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">push</span>(self, x: int) <span style="color:#f92672">-&gt;</span> None:
        self<span style="color:#f92672">.</span>stack<span style="color:#f92672">.</span>append(x)
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>getMin() <span style="color:#f92672">or</span> self<span style="color:#f92672">.</span>getMin() <span style="color:#f92672">&gt;=</span> x:
            self<span style="color:#f92672">.</span>min<span style="color:#f92672">.</span>append(x)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pop</span>(self) <span style="color:#f92672">-&gt;</span> None:
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>stack:
            x <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>stack<span style="color:#f92672">.</span>pop()
            <span style="color:#66d9ef">if</span> x <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>min[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                self<span style="color:#f92672">.</span>min<span style="color:#f92672">.</span>pop()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">top</span>(self) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>stack:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> None

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getMin</span>(self) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>min:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>min[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> None
</code></pre></div><h2 id="543-diameter-of-binary-tree">543 - Diameter of Binary Tree</h2>
<p><a href="https://leetcode.com/problems/diameter-of-binary-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

Example:
Given a binary tree
          1
         / \
        2   3
       / \
      4   5
Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].

Note: The length of path between two nodes is represented by the number of edges between them.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">diameterOfBinaryTree</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right:
            <span style="color:#66d9ef">return</span> max(self<span style="color:#f92672">.</span>diameterOfBinaryTree(root<span style="color:#f92672">.</span>left),
                       <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>left))
        <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left:
            <span style="color:#66d9ef">return</span> max(self<span style="color:#f92672">.</span>diameterOfBinaryTree(root<span style="color:#f92672">.</span>right),
                       <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>right))
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> max(self<span style="color:#f92672">.</span>diameterOfBinaryTree(root<span style="color:#f92672">.</span>right),
                       self<span style="color:#f92672">.</span>diameterOfBinaryTree(root<span style="color:#f92672">.</span>left),
                       self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>left) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>right) <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">height</span>(self, root):

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max(self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>left), self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>right))
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">diameterOfBinaryTree</span>(self, root):
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">depth</span>(node):
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> node:
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
            r <span style="color:#f92672">=</span> depth(node<span style="color:#f92672">.</span>right)
            l <span style="color:#f92672">=</span> depth(node<span style="color:#f92672">.</span>left)
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> max(self<span style="color:#f92672">.</span>ans, r<span style="color:#f92672">+</span>l)
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max(r, l)
        depth(root)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans
</code></pre></div><h2 id="1046-last-stone-weight">1046 - Last Stone Weight</h2>
<p><a href="https://leetcode.com/problems/last-stone-weight/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">We have a collection of stones, each stone has a positive integer weight.

Each turn, we choose the two heaviest stones and smash them together.  Suppose the stones have weights x and y with x &lt;= y.  The result of this smash is:

If x == y, both stones are totally destroyed;
If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.
At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)



Example 1:

Input: [2,7,4,1,8,1]
Output: 1
Explanation:
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of last stone.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Priority queue, max heap can be used here.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lastStoneWeight</span>(self, stones):
        res <span style="color:#f92672">=</span> [ <span style="color:#f92672">-</span>s <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> stones ]

        heapq<span style="color:#f92672">.</span>heapify(res)

        <span style="color:#66d9ef">while</span> len(res) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> :
            y <span style="color:#f92672">=</span> heapq<span style="color:#f92672">.</span>heappop(res)
            x <span style="color:#f92672">=</span> heapq<span style="color:#f92672">.</span>heappop(res)
            <span style="color:#66d9ef">if</span> y <span style="color:#f92672">!=</span> x:
                heapq<span style="color:#f92672">.</span>heappush(res, y<span style="color:#f92672">-</span>x)

        <span style="color:#66d9ef">return</span> res[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*-</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> res <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h2 id="525-contiguous-array">525 - Contiguous Array</h2>
<p><a href="https://leetcode.com/problems/contiguous-array">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.

Example 1:
Input: [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.
Example 2:
Input: [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
Note: The length of the given binary array will not exceed 50,000.
</code></pre></div><h3 id="solution">Solution</h3>
<p>We keep a count, which decrease 1 if 0, increase 1 if 1.</p>
<p>If at x and y, they have the same value v of count, then the numbers between x+1 and y have the equal number of 1s and 0s. The max length = y - (x + 1) + 1 = y - x</p>
<p>And after that, if we found at index w, it also has value v of count. The max length should be w - x.</p>
<p>So we have to maintain a hashmap h using the values of count as keys, and the first index of that count as its value.</p>
<p>The <code>maxlen = max(maxlen, h[count])</code> if current count in the map.</p>
<p><strong>Important</strong></p>
<p>We have an initial value of the map.</p>
<p>h[0] = -1 (If count == 0 at index i, we have all the numbers between h[0] + 1 and i. And h[0] + 1 should at index 0, so h[0] = -1)</p>
<p>Consider the input [0, 1]:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Index 0: h[-1] = 0, maxlen = 0
Index 1: h[0] = -1, maxlen = 1 - (-1) = 2
maxlen = 2
</code></pre></div><h4 id="solution-counting-contiguous-1s-and-0s-with-a-hashmap">Solution: counting contiguous 1s and 0s with a Hashmap</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMaxLength</span>(self, nums):
        h <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>: <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>}

        count <span style="color:#f92672">=</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums)):
            count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> nums[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
            ans <span style="color:#f92672">=</span> max(ans, h<span style="color:#f92672">.</span>setdefault(count, i))

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="perform-string-shifts">Perform String Shifts</h2>
<p><a href="https://leetcode.com/explore/other/card/30-day-leetcoding-challenge/529/week-2/3299/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [direction, amount]:

direction can be 0 (for left shift) or 1 (for right shift).
amount is the amount by which string s is to be shifted.
A left shift by 1 means remove the first character of s and append it to the end.
Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.
Return the final string after all operations.

Example 1:

Input: s = &#34;abc&#34;, shift = [[0,1],[1,2]]
Output: &#34;cab&#34;
Explanation:
[0,1] means shift to left by 1. &#34;abc&#34; -&gt; &#34;bca&#34;
[1,2] means shift to right by 2. &#34;bca&#34; -&gt; &#34;cab&#34;

Example 2:

Input: s = &#34;abcdefg&#34;, shift = [[1,1],[1,1],[0,2],[1,3]]
Output: &#34;efgabcd&#34;
Explanation:
[1,1] means shift to right by 1. &#34;abcdefg&#34; -&gt; &#34;gabcdef&#34;
[1,1] means shift to right by 1. &#34;gabcdef&#34; -&gt; &#34;fgabcde&#34;
[0,2] means shift to left by 2. &#34;fgabcde&#34; -&gt; &#34;abcdefg&#34;
[1,3] means shift to right by 3. &#34;abcdefg&#34; -&gt; &#34;efgabcd&#34;
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stringShift</span>(self, s: str, shift: List[List[int]]) <span style="color:#f92672">-&gt;</span> str:
        count <span style="color:#f92672">=</span> sum([ (<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>x)<span style="color:#f92672">*</span>y <span style="color:#66d9ef">for</span> x, y <span style="color:#f92672">in</span> shift ]) <span style="color:#f92672">%</span> len(s)
        ds <span style="color:#f92672">=</span> s <span style="color:#f92672">+</span> s
        <span style="color:#66d9ef">return</span> ds[len(s)<span style="color:#f92672">-</span>count: <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>len(s) <span style="color:#f92672">-</span> count]
</code></pre></div><h2 id="238-product-of-array-except-self">238 - Product of Array Except Self</h2>
<p><a href="https://leetcode.com/problems/product-of-array-except-self/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">238. Product of Array Except Self
Medium

4145

358

Add to List

Share
Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Example:

Input:  [1,2,3,4]
Output: [24,12,8,6]
Constraint: It&#39;s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.

Note: Please solve it without division and in O(n).

Follow up:
Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-prefix-product-and-suffix-product">Solution 1: prefix product and suffix product</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">productExceptSelf</span>(self, nums):
        n <span style="color:#f92672">=</span> len(nums)
        ans <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n
        ans[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
            ans[i] <span style="color:#f92672">=</span> ans[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

        R <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> reversed(range(n)):
            ans[i] <span style="color:#f92672">=</span> ans[i] <span style="color:#f92672">*</span> R
            R <span style="color:#f92672">*=</span> nums[i]

        <span style="color:#66d9ef">return</span> ans

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>productExceptSelf([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]))
</code></pre></div><h2 id="678-valid-parenthesis-string">678 - Valid Parenthesis String</h2>
<p><a href="https://leetcode.com/problems/valid-parenthesis-string/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string containing only three types of characters: &#39;(&#39;, &#39;)&#39; and &#39;*&#39;, write a function to check whether this string is valid. We define the validity of a string by these rules:

Any left parenthesis &#39;(&#39; must have a corresponding right parenthesis &#39;)&#39;.
Any right parenthesis &#39;)&#39; must have a corresponding left parenthesis &#39;(&#39;.
Left parenthesis &#39;(&#39; must go before the corresponding right parenthesis &#39;)&#39;.
&#39;*&#39; could be treated as a single right parenthesis &#39;)&#39; or a single left parenthesis &#39;(&#39; or an empty string.
An empty string is also valid.
Example 1:
Input: &#34;()&#34;
Output: True
Example 2:
Input: &#34;(*)&#34;
Output: True
Example 3:
Input: &#34;(*))&#34;
Output: True
Note:
The string size will be in the range [1, 100].
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-cmin-and-cmax-to-valida-to-parenthesis">Solution 1: cmin and cmax to valida to parenthesis</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">checkValidString</span>(self, s: str) <span style="color:#f92672">-&gt;</span> bool:
        counter_max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        counter_min <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
            <span style="color:#66d9ef">if</span> c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;(&#34;</span>:
                counter_max <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                counter_min <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;)&#34;</span>:
                counter_max <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                counter_min <span style="color:#f92672">=</span> max(counter_min<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">else</span>:
                counter_max <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                counter_min <span style="color:#f92672">=</span> max(counter_min<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)

            <span style="color:#66d9ef">if</span> counter_max <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">return</span> counter_min <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h2 id="200-number-of-islands">200 - Number of Islands</h2>
<p><a href="https://leetcode.com/problems/number-of-islands/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:

Input:
11110
11010
11000
00000

Output: 1
Example 2:

Input:
11000
11000
00100
00011

Output: 3
</code></pre></div><h3 id="solution">Solution</h3>
<p>DFS problem. Straight forward.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numIslands</span>(self, grid):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> grid:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        h <span style="color:#f92672">=</span> len(grid)
        w <span style="color:#f92672">=</span> len(grid[<span style="color:#ae81ff">0</span>])
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        m <span style="color:#f92672">=</span> [ [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> w <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(h) ]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(h):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(w):
                <span style="color:#66d9ef">if</span> grid[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">and</span> m[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                    self<span style="color:#f92672">.</span>dfs(grid, i, j, m)
                    ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, grid, i, j, m):
        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">&gt;=</span> len(grid) <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">&gt;=</span> len(grid[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">or</span> grid[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#f92672">or</span> m[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> None
        <span style="color:#66d9ef">else</span>:
            m[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            self<span style="color:#f92672">.</span>dfs(grid, i, j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, m)
            self<span style="color:#f92672">.</span>dfs(grid, i, j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, m)
            self<span style="color:#f92672">.</span>dfs(grid, i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, j, m)
            self<span style="color:#f92672">.</span>dfs(grid, i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, j, m)
        <span style="color:#66d9ef">return</span> None
</code></pre></div><h2 id="46-permutations">46 - Permutations</h2>
<p><a href="https://leetcode.com/problems/permutations-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1">Solution 1</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">permute</span>(self, nums):
        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>backtrack([], nums, ans)
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">backtrack</span>(self, path, nums, ans):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            ans<span style="color:#f92672">.</span>append(path[:])
            <span style="color:#66d9ef">return</span>
        <span style="color:#66d9ef">for</span> i, v <span style="color:#f92672">in</span> enumerate(nums):
            self<span style="color:#f92672">.</span>backtrack(path<span style="color:#f92672">+</span>[v], nums[:i]<span style="color:#f92672">+</span>nums[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:], ans)
</code></pre></div><h4 id="solution-2">Solution 2</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">permute</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        ans <span style="color:#f92672">=</span> []
        marked <span style="color:#f92672">=</span> [False] <span style="color:#f92672">*</span> len(nums)
        self<span style="color:#f92672">.</span>dfs(nums, [], marked, ans)
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, nums, path, marked, ans):
        <span style="color:#66d9ef">if</span> len(path) <span style="color:#f92672">==</span> len(nums):
            ans<span style="color:#f92672">.</span>append(list(path))
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">for</span> i, n <span style="color:#f92672">in</span> enumerate(nums):
            <span style="color:#66d9ef">if</span> marked[i]:
                <span style="color:#66d9ef">continue</span>
            marked[i] <span style="color:#f92672">=</span> True
            path<span style="color:#f92672">.</span>append(n)
            self<span style="color:#f92672">.</span>dfs(nums, path, marked, ans)
            path<span style="color:#f92672">.</span>pop()
            marked[i] <span style="color:#f92672">=</span> False
</code></pre></div><h2 id="47-permutations-ii">47 - Permutations II</h2>
<p><a href="https://leetcode.com/problems/permutations-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre></div><h3 id="solution">Solution</h3>
<p>Backtrack problem.</p>
<p>Framework of backtrack problem:</p>
<ol>
<li>choose a path</li>
<li>selection pool</li>
<li>return condition</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">ans = []

def backtrack(path, pool):

  if meet condition:
    ans.add(path)
    return

  for selection in pool:

    path.add(selection)
    backtrack(path, new_pool)
    path.remove(selection)
</code></pre></div><p><strong>Important</strong>:</p>
<p>Pay attention, you must add a copy of the path to result, not the path it self. It may get modified afterwards.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">permuteUnique</span>(self, nums):
        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>backtrack([], nums, ans)
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">backtrack</span>(self, path, pool, ans):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> pool:
            ans<span style="color:#f92672">.</span>append(path[:])
            <span style="color:#66d9ef">return</span>

        t <span style="color:#f92672">=</span> {}

        <span style="color:#66d9ef">for</span> i, v <span style="color:#f92672">in</span> enumerate(pool):
            <span style="color:#66d9ef">if</span> v <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> t:
                t[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
                self<span style="color:#f92672">.</span>backtrack(path<span style="color:#f92672">+</span>[v], pool[:i]<span style="color:#f92672">+</span>pool[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:], ans)

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>permuteUnique([<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>]))
</code></pre></div><h2 id="1008-construct-binary-search-tree-from-preorder-traversal">1008 - Construct Binary Search Tree from Preorder Traversal</h2>
<p><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Return the root node of a binary search tree that matches the given preorder traversal.

(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)

Example 1:

Input: [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]
</code></pre></div><h3 id="solution">Solution</h3>
<p>We keep track of a low bound for the function.</p>
<p>We always build the right child with the low bound as the current node value.</p>
<p>If next value is smaller then current node value, we construct the left node.</p>
<p>If next value is smaller then current low bound, we construct the right node.</p>
<p>If next value is larger then current low bound, we jump out of the funciton.</p>
<p>Let the recursive jump back to the last level and repeat the same proccess</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bstFromPreorder</span>(self, preorder):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> preorder:
            <span style="color:#66d9ef">return</span> None
        root <span style="color:#f92672">=</span> TreeNode(preorder[<span style="color:#ae81ff">0</span>])
        self<span style="color:#f92672">.</span>buildTree(root, <span style="color:#ae81ff">1</span>, preorder, sys<span style="color:#f92672">.</span>maxsize)
        <span style="color:#66d9ef">return</span> root

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">buildTree</span>(self, root, pos, preorder, rmax):
        <span style="color:#66d9ef">if</span> pos <span style="color:#f92672">&gt;=</span> len(preorder) <span style="color:#f92672">or</span> preorder[pos] <span style="color:#f92672">&gt;</span> rmax:
            <span style="color:#66d9ef">return</span> None

        <span style="color:#66d9ef">if</span> preorder[pos] <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>val:
            root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> TreeNode(preorder[pos])
            pos <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>buildTree(root<span style="color:#f92672">.</span>left, pos<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, preorder, root<span style="color:#f92672">.</span>val <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">if</span> pos <span style="color:#f92672">&lt;</span> len(preorder) <span style="color:#f92672">and</span> preorder[pos] <span style="color:#f92672">&lt;=</span> rmax:
            root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> TreeNode(preorder[pos])
            pos <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>buildTree(root<span style="color:#f92672">.</span>right, pos<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, preorder, rmax)

        <span style="color:#66d9ef">return</span> pos
</code></pre></div><p>Concise version:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bstFromPreorder</span>(self, preorder, bound<span style="color:#f92672">=</span>float(<span style="color:#e6db74">&#39;inf&#39;</span>)):
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>pos <span style="color:#f92672">&gt;=</span> len(preorder) <span style="color:#f92672">or</span> preorder[self<span style="color:#f92672">.</span>pos] <span style="color:#f92672">&gt;</span> bound:
            <span style="color:#66d9ef">return</span> None
        root <span style="color:#f92672">=</span> TreeNode(preorder[self<span style="color:#f92672">.</span>pos])
        self<span style="color:#f92672">.</span>pos <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bstFromPreorder(preorder, root<span style="color:#f92672">.</span>val)
        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bstFromPreorder(preorder, bound)
        <span style="color:#66d9ef">return</span> root
</code></pre></div><h2 id="105-construct-binary-tree-from-preorder-and-inorder-traversal">105 - Construct Binary Tree from Preorder and Inorder Traversal</h2>
<p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
</code></pre></div><h3 id="solution">Solution</h3>
<ol>
<li>The first node of the preorder is always the root.</li>
<li>Find the root in the inorder array, split it there. The left part are all the nodes in left branch. the right part in the right branch.</li>
<li>Repeat it recursively. Note that we should always pop the first node of preorder as current root(solution 1). All keep a global index as shown(solution 2).</li>
</ol>
<p>Simple Version:</p>
<p>It uses a lot resources</p>
<ol>
<li>index() operation is also not O(1).</li>
<li>inorder[:split] copies the sub array to the next level recursion.</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">buildTree</span>(self, preorder, inorder):
        <span style="color:#66d9ef">if</span> inorder:
            node <span style="color:#f92672">=</span> TreeNode(preorder<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>))
            split <span style="color:#f92672">=</span> inorder<span style="color:#f92672">.</span>index(node<span style="color:#f92672">.</span>val)
            node<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>buildTree(preorder, inorder[:split])
            ndoe<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>buildTree(preorder, inorder[split<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:])
            <span style="color:#66d9ef">return</span> node
</code></pre></div><p>Optimized Version:</p>
<ol>
<li>use a map instead of index() operation</li>
<li>pass the index instead of the sub array it self</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>map <span style="color:#f92672">=</span> {}

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">buildTree</span>(self, preorder, inorder):
        <span style="color:#66d9ef">for</span> i, val <span style="color:#f92672">in</span> enumerate(inorder):
            self<span style="color:#f92672">.</span>map[val] <span style="color:#f92672">=</span> i

        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>recursive(<span style="color:#ae81ff">0</span>, len(preorder) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, preorder, inorder)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">recursive</span>(self, start, end, preorder, inorder):
        <span style="color:#66d9ef">if</span> (start <span style="color:#f92672">&gt;</span> end):
            <span style="color:#66d9ef">return</span> None

        node <span style="color:#f92672">=</span> TreeNode(preorder<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>))

        split <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>map[node<span style="color:#f92672">.</span>val]

        node<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>recursive(start, split <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, preorder, inorder)
        node<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>recursive(split <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, end, preorder, inorder)

        <span style="color:#66d9ef">return</span> node
</code></pre></div><h2 id="leftmost-column-with-at-least-a-one">Leftmost Column with at Least a One</h2>
<p><a href="https://leetcode.com/explore/featured/card/30-day-leetcoding-challenge/530/week-3/3306">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order.

Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn&#39;t exist, return -1.

You can&#39;t access the Binary Matrix directly.  You may only access the matrix using a BinaryMatrix interface:

BinaryMatrix.get(x, y) returns the element of the matrix at index (x, y) (0-indexed).
BinaryMatrix.dimensions() returns a list of 2 elements [m, n], which means the matrix is m * n.
Submissions making more than 1000 calls to BinaryMatrix.get will be judged Wrong Answer.  Also, any solutions that attempt to circumvent the judge will result in disqualification.

For custom testing purposes you&#39;re given the binary matrix mat as input in the following four examples. You will not have access the binary matrix directly.

Example 1:

Input: mat = [[0,0],[1,1]]
Output: 0

Example 4:
Input: mat = [[0,0,0,1],[0,0,1,1],[0,1,1,1]]
Output: 1
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># &#34;&#34;&#34;</span>
<span style="color:#75715e"># This is BinaryMatrix&#39;s API interface.</span>
<span style="color:#75715e"># You should not implement it, or speculate about its implementation</span>
<span style="color:#75715e"># &#34;&#34;&#34;</span>
<span style="color:#75715e">#class BinaryMatrix(object):</span>
<span style="color:#75715e">#    def get(self, x: int, y: int) -&gt; int:</span>
<span style="color:#75715e">#    def dimensions(self) -&gt; list[]:</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">leftMostColumnWithOne</span>(self, binaryMatrix):
        n, m <span style="color:#f92672">=</span> binaryMatrix<span style="color:#f92672">.</span>dimensions()
        ans <span style="color:#f92672">=</span> m
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            x <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>findOne(binaryMatrix, i, <span style="color:#ae81ff">0</span>, m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
            <span style="color:#66d9ef">if</span> x <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
                ans <span style="color:#f92672">=</span> min(ans, x)
        <span style="color:#66d9ef">return</span> ans <span style="color:#66d9ef">if</span> ans <span style="color:#f92672">!=</span> m <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findOne</span>(self, m, r, i, j):
        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> j:
            <span style="color:#66d9ef">return</span> i <span style="color:#66d9ef">if</span> m<span style="color:#f92672">.</span>get(r, i) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

        mid <span style="color:#f92672">=</span> (i <span style="color:#f92672">+</span> j) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">if</span> m<span style="color:#f92672">.</span>get(r, mid) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">if</span> mid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> m<span style="color:#f92672">.</span>get(r, mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">return</span> mid
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>findOne(m, r, i, mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>findOne(m, r, mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, j)
</code></pre></div><h2 id="560-subarray-sum-equals-k">560 Subarray Sum Equals K</h2>
<p><a href="https://leetcode.com/problems/subarray-sum-equals-k/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.

Example 1:
Input:nums = [1,1,1], k = 2
Output: 2
Note:
The length of the array is in range [1, 20,000].
The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">subArraySum</span>(self, nums, k):
        h <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>: <span style="color:#ae81ff">1</span>}
        s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
            s <span style="color:#f92672">+=</span> i
            ans <span style="color:#f92672">+=</span> h<span style="color:#f92672">.</span>get(s<span style="color:#f92672">-</span>k, <span style="color:#ae81ff">0</span>)
            h[s] <span style="color:#f92672">=</span> h<span style="color:#f92672">.</span>get(s, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="201-bitwise-and-of-numbers-range">201 - Bitwise AND of Numbers Range</h2>
<p><a href="https://leetcode.com/problems/bitwise-and-of-numbers-range/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

Example 1:

Input: [5,7]
Output: 4
Example 2:

Input: [0,1]
Output: 0
</code></pre></div><h3 id="solution">Solution</h3>
<p>m = xxx1yyyy
n = xxx01zzz</p>
<p><code>xxx</code> is the parts that two numbers are the same.
We can definitly find these two numbers in the range</p>
<p>m' = xxx1000
n' = xxx0100</p>
<p>So the result will be xxx0000</p>
<p>The idea is the find position where the the numbers are the same.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rangeBitwiseAnd</span>(self, m, n):
        i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">while</span> m <span style="color:#f92672">!=</span> n:
            m <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>
            n <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>
            i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> n <span style="color:#f92672">&lt;&lt;</span> i
</code></pre></div><h2 id="146-lru-cache">146 - LRU Cache</h2>
<p><a href="https://leetcode.com/problems/lru-cache/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

The cache is initialized with a positive capacity.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
</code></pre></div><h3 id="solution">Solution</h3>
<ol>
<li>
<p>How to manage to have a O(1) for get()?</p>
<p>Hash Table</p>
</li>
<li>
<p>How to manage to have a O(1) for put()?</p>
<p>We have to somehow maintain its order, when something is added.</p>
<p>Linked list would come to mind at first. But how we can change its order when we call get() on a node
and also be able to delete the last one. We would like to know the previous one of a node.</p>
<p>A <strong>Double Linked List</strong> is a perfect match.</p>
</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LRUCache</span>:

    <span style="color:#66d9ef">def</span> __init__(self, capacity: int):
        self<span style="color:#f92672">.</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        self<span style="color:#f92672">.</span>capacity <span style="color:#f92672">=</span> capacity
        self<span style="color:#f92672">.</span>hash <span style="color:#f92672">=</span> {}
        self<span style="color:#f92672">.</span>head <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
        self<span style="color:#f92672">.</span>tail <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
        self<span style="color:#f92672">.</span>head<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>tail
        self<span style="color:#f92672">.</span>tail<span style="color:#f92672">.</span>prev <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>head

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get</span>(self, key: int) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> key <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>hash:
            node <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>hash[key]
            self<span style="color:#f92672">.</span>_remove(node)
            self<span style="color:#f92672">.</span>_add(node)
            <span style="color:#66d9ef">return</span> node<span style="color:#f92672">.</span>value
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">put</span>(self, key: int, value: int) <span style="color:#f92672">-&gt;</span> None:
        <span style="color:#66d9ef">if</span> key <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>hash:
            node <span style="color:#f92672">=</span> Node(key, value)
            self<span style="color:#f92672">.</span>hash[key] <span style="color:#f92672">=</span> node
            self<span style="color:#f92672">.</span>count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            self<span style="color:#f92672">.</span>_add(node)
        <span style="color:#66d9ef">else</span>:
            node <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>hash[key]
            node<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span> value
            self<span style="color:#f92672">.</span>get(key)

        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>count <span style="color:#f92672">&gt;</span> self<span style="color:#f92672">.</span>capacity:
            n <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>tail<span style="color:#f92672">.</span>prev
            self<span style="color:#f92672">.</span>hash<span style="color:#f92672">.</span>pop(n<span style="color:#f92672">.</span>key)
            self<span style="color:#f92672">.</span>_remove(n)
            self<span style="color:#f92672">.</span>count <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_connect</span>(self, p, n):
        p<span style="color:#f92672">.</span>next, n<span style="color:#f92672">.</span>prev <span style="color:#f92672">=</span> n, p

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_add</span>(self, n):
        tmp <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>head<span style="color:#f92672">.</span>next
        self<span style="color:#f92672">.</span>_connect(self<span style="color:#f92672">.</span>head, n)
        self<span style="color:#f92672">.</span>_connect(n, tmp)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_remove</span>(self, node):
        self<span style="color:#f92672">.</span>_connect(node<span style="color:#f92672">.</span>prev, node<span style="color:#f92672">.</span>next)



<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
    <span style="color:#66d9ef">def</span> __init__(self, key, value):
        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
        self<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span>  value
        self<span style="color:#f92672">.</span>prev <span style="color:#f92672">=</span> None
        self<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> None


<span style="color:#75715e"># Your LRUCache object will be instantiated and called as such:</span>
<span style="color:#75715e"># obj = LRUCache(capacity)</span>
<span style="color:#75715e"># param_1 = obj.get(key)</span>
<span style="color:#75715e"># obj.put(key,value)</span>
</code></pre></div><h2 id="460-lfu-cache">460 - LFU Cache</h2>
<p><a href="https://leetcode.com/problems/lfu-cache/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.

Note that the number of times an item is used is the number of calls to the get and put functions for that item since it was inserted. This number is set to zero when the item is removed.



Follow up:
Could you do both operations in O(1) time complexity?



Example:

LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
</code></pre></div><h3 id="solution">Solution</h3>
<ol>
<li>O(1) get =&gt; Hash table for all nodes</li>
<li>for keeping the oder by frequency, we can have another hash table. the key is the frequency. the value is a double linked list</li>
<li>We need a min_freqeuncy to find the list of min frequency in O(1), and delete the last element of the list</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
    <span style="color:#66d9ef">def</span> __init__(self, key, value):
        self<span style="color:#f92672">.</span>freq <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        self<span style="color:#f92672">.</span>key <span style="color:#f92672">=</span> key
        self<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span> value
        self<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> None
        self<span style="color:#f92672">.</span>prev <span style="color:#f92672">=</span> None


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DoubleLinkedList</span>:
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>_head <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
        self<span style="color:#f92672">.</span>_tail <span style="color:#f92672">=</span> Node(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
        self<span style="color:#f92672">.</span>_head<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>_tail
        self<span style="color:#f92672">.</span>_tail<span style="color:#f92672">.</span>prev <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>_head
        self<span style="color:#f92672">.</span>_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">append</span>(self, node):
        self<span style="color:#f92672">.</span>_connect(node, self<span style="color:#f92672">.</span>_head<span style="color:#f92672">.</span>next)
        self<span style="color:#f92672">.</span>_connect(self<span style="color:#f92672">.</span>_head, node)
        self<span style="color:#f92672">.</span>_size <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pop</span>(self, node):
        self<span style="color:#f92672">.</span>_connect(node<span style="color:#f92672">.</span>prev, node<span style="color:#f92672">.</span>next)
        node<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> None
        node<span style="color:#f92672">.</span>prev <span style="color:#f92672">=</span> None
        self<span style="color:#f92672">.</span>_size <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> node

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pop_last</span>(self):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>pop(self<span style="color:#f92672">.</span>_tail<span style="color:#f92672">.</span>prev)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_size</span>(self):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>_size

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_connect</span>(self, p, n):
        p<span style="color:#f92672">.</span>next, n<span style="color:#f92672">.</span>prev <span style="color:#f92672">=</span> n, p


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LFUCache</span>:
    <span style="color:#66d9ef">def</span> __init__(self, capacity):
        self<span style="color:#f92672">.</span>nodes <span style="color:#f92672">=</span> {}
        self<span style="color:#f92672">.</span>freq <span style="color:#f92672">=</span> {}
        self<span style="color:#f92672">.</span>min_freq <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        self<span style="color:#f92672">.</span>capacity <span style="color:#f92672">=</span> capacity

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get</span>(self, key):
        <span style="color:#66d9ef">if</span> key <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>nodes:
            node <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>nodes[key]
            l <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>freq[node<span style="color:#f92672">.</span>freq]
            l<span style="color:#f92672">.</span>pop(node)
            <span style="color:#66d9ef">if</span> l<span style="color:#f92672">.</span>get_size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> self<span style="color:#f92672">.</span>min_freq <span style="color:#f92672">==</span> node<span style="color:#f92672">.</span>freq:
                self<span style="color:#f92672">.</span>min_freq <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

            node<span style="color:#f92672">.</span>freq <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>freq<span style="color:#f92672">.</span>get(node<span style="color:#f92672">.</span>freq):
                self<span style="color:#f92672">.</span>freq[node<span style="color:#f92672">.</span>freq]<span style="color:#f92672">.</span>append(node)
            <span style="color:#66d9ef">else</span>:
                l <span style="color:#f92672">=</span> DoubleLinkedList()
                l<span style="color:#f92672">.</span>append(node)
                self<span style="color:#f92672">.</span>freq[node<span style="color:#f92672">.</span>freq] <span style="color:#f92672">=</span> l
            <span style="color:#66d9ef">return</span> node<span style="color:#f92672">.</span>value
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">put</span>(self, key, value):

        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>capacity <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">if</span> key <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>nodes:
            self<span style="color:#f92672">.</span>nodes[key]<span style="color:#f92672">.</span>value <span style="color:#f92672">=</span> value
            self<span style="color:#f92672">.</span>get(key)
        <span style="color:#66d9ef">else</span>:
            node <span style="color:#f92672">=</span> Node(key, value)
            <span style="color:#66d9ef">if</span> len(self<span style="color:#f92672">.</span>nodes) <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>capacity:
                l <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>freq[self<span style="color:#f92672">.</span>min_freq]
                n <span style="color:#f92672">=</span> l<span style="color:#f92672">.</span>pop_last()
                self<span style="color:#f92672">.</span>nodes<span style="color:#f92672">.</span>pop(n<span style="color:#f92672">.</span>key)

            self<span style="color:#f92672">.</span>nodes[key] <span style="color:#f92672">=</span> node

            <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>freq:
                self<span style="color:#f92672">.</span>freq[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>append(node)
            <span style="color:#66d9ef">else</span>:
                l <span style="color:#f92672">=</span> DoubleLinkedList()
                l<span style="color:#f92672">.</span>append(node)
                self<span style="color:#f92672">.</span>freq[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> l
            self<span style="color:#f92672">.</span>min_freq <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>


c <span style="color:#f92672">=</span> LFUCache(<span style="color:#ae81ff">3</span>)
c<span style="color:#f92672">.</span>put(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
c<span style="color:#f92672">.</span>put(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
<span style="color:#66d9ef">print</span>(c<span style="color:#f92672">.</span>get(<span style="color:#ae81ff">1</span>))
<span style="color:#66d9ef">print</span>(c<span style="color:#f92672">.</span>get(<span style="color:#ae81ff">2</span>))
<span style="color:#66d9ef">print</span>(c<span style="color:#f92672">.</span>get(<span style="color:#ae81ff">1</span>))
c<span style="color:#f92672">.</span>put(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">3</span>)
<span style="color:#66d9ef">print</span>(c<span style="color:#f92672">.</span>get(<span style="color:#ae81ff">2</span>))
<span style="color:#66d9ef">print</span>(c<span style="color:#f92672">.</span>get(<span style="color:#ae81ff">3</span>))
c<span style="color:#f92672">.</span>put(<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>)

<span style="color:#66d9ef">print</span>(c<span style="color:#f92672">.</span>get(<span style="color:#ae81ff">4</span>))
</code></pre></div><h2 id="437-path-sum-iii">437 - Path Sum III</h2>
<p><a href="https://leetcode.com/problems/path-sum-iii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given a binary tree in which each node contains an integer value.

Find the number of paths that sum to a given value.

The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).

The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

Example:

root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11
</code></pre></div><h3 id="solution">Solution</h3>
<p><strong>Important</strong>:</p>
<p>Three parts in recursion:</p>
<ol>
<li>the path sum of the left child</li>
<li>the path sum of the right child</li>
<li>the path sum only from the root</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pathSum</span>(self, root, sum):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>pathSum(root<span style="color:#f92672">.</span>left, sum) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>pathSum(
            root<span style="color:#f92672">.</span>right, sum) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>pathSumFrom(root, sum)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pathSumFrom</span>(self, root, sum):

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> sum:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>pathSumFrom(root<span style="color:#f92672">.</span>left, <span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>pathSumFrom(
                root<span style="color:#f92672">.</span>right, <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>pathSumFrom(root<span style="color:#f92672">.</span>left,
                                    sum <span style="color:#f92672">-</span> root<span style="color:#f92672">.</span>val) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>pathSumFrom(
                                        root<span style="color:#f92672">.</span>right, sum <span style="color:#f92672">-</span> root<span style="color:#f92672">.</span>val)
</code></pre></div><h2 id="1143-longest-common-subsequence">1143 - Longest Common Subsequence</h2>
<p><a href="https://leetcode.com/problems/longest-common-subsequence/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given two strings text1 and text2, return the length of their longest common subsequence.

A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters.
(eg, &#34;ace&#34; is a subsequence of &#34;abcde&#34; while &#34;aec&#34; is not).
A common subsequence of two strings is a subsequence that is common to both strings.

If there is no common subsequence, return 0.

Example 1:

Input: text1 = &#34;abcde&#34;, text2 = &#34;ace&#34;
Output: 3
Explanation: The longest common subsequence is &#34;ace&#34; and its length is 3.

Example 2:

Input: text1 = &#34;abc&#34;, text2 = &#34;abc&#34;
Output: 3
Explanation: The longest common subsequence is &#34;abc&#34; and its length is 3.

Example 3:

Input: text1 = &#34;abc&#34;, text2 = &#34;def&#34;
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
</code></pre></div><h3 id="solution">Solution</h3>
<p>The hardest part of this problem is to figure out what is the transition.</p>
<p>The current state should be determined by index i, j for each string respectively.</p>
<ol>
<li>
<p>States: dp[i][j] means the longest common subsequence for text1 til index i and text2 til index j</p>
</li>
<li>
<p>Transition:</p>
<p>if text1[i] <code>= text2[j]: dp[i][j] = dp[i-1][j-1] if text1[i] !</code> text2[j]: dp[i][j] = max(dp[i-1][j], dp[i][j-1])</p>
</li>
<li>
<p>Base Case: we need padding for i = 0 and j = 0</p>
</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestCommonSubsequence</span>(self, text1: str, text2: str) <span style="color:#f92672">-&gt;</span> int:
        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (len(text1) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(text2) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(text2)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(text1)):
                <span style="color:#66d9ef">if</span> text2[i] <span style="color:#f92672">==</span> text1[j]:
                    dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[i][j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j], dp[i][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="887-super-egg-drop">887 - Super Egg Drop</h2>
<p><a href="https://leetcode.com/problems/super-egg-drop/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given K eggs, and you have access to a building with N floors from 1 to N.

Each egg is identical in function, and if an egg breaks, you cannot drop it again.

You know that there exists a floor F with 0 &lt;= F &lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.

Each move, you may take an egg (if you have an unbroken one) and drop it from any floor X (with 1 &lt;= X &lt;= N).

Your goal is to know with certainty what the value of F is.

What is the minimum number of moves that you need to know with certainty what F is, regardless of the initial value of F?

Example 1:

Input: K = 1, N = 2

Output: 2

Explanation:
Drop the egg from floor 1.  If it breaks, we know with certainty that F = 0.
Otherwise, drop the egg from floor 2.  If it breaks, we know with certainty that F = 1.
If it didn&#39;t break, then we know with certainty F = 2.
Hence, we needed 2 moves in the worst case to know what F is with certainty.

Example 2:

Input: K = 2, N = 6

Output: 3

Example 3:

Input: K = 3, N = 14

Output: 4
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-dp">Solution 1: dp</h4>
<p>A naive approach with dp. Time consuming.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">superEggDrop</span>(self, K: int, N: int) <span style="color:#f92672">-&gt;</span> int:
        memo <span style="color:#f92672">=</span> dict()

        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dp</span>(K, N):
            <span style="color:#66d9ef">if</span> K <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
                <span style="color:#66d9ef">return</span> N
            <span style="color:#66d9ef">if</span> N <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
            <span style="color:#66d9ef">if</span> (K, N) <span style="color:#f92672">in</span> memo:
                <span style="color:#66d9ef">return</span> memo[(K, N)]

            res <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#39;INF&#39;</span>)

            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
                res <span style="color:#f92672">=</span> min(res, max(dp(K<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>), dp(K, N <span style="color:#f92672">-</span> i)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)

            memo[(K, N)] <span style="color:#f92672">=</span> res
            <span style="color:#66d9ef">return</span> res

        <span style="color:#66d9ef">return</span> dp(K, N)
</code></pre></div><p>Time: O(K*N*N)</p>
<p>Space: O(K*N)</p>
<h4 id="solution-2-dp-with-binary-search">Solution 2: dp with binary search</h4>
<p>Improve the previous one with a binary search</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">superEggDrop</span>(self, K: int, N: int) <span style="color:#f92672">-&gt;</span> int:
        memo <span style="color:#f92672">=</span> dict()

        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dp</span>(K, N):
            <span style="color:#66d9ef">if</span> K <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
                <span style="color:#66d9ef">return</span> N
            <span style="color:#66d9ef">if</span> N <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
            <span style="color:#66d9ef">if</span> (K, N) <span style="color:#f92672">in</span> memo:
                <span style="color:#66d9ef">return</span> memo[(K, N)]

            res <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#39;INF&#39;</span>)
            lo <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            hi <span style="color:#f92672">=</span> N
            <span style="color:#66d9ef">while</span> lo <span style="color:#f92672">&lt;=</span> hi:
                mid <span style="color:#f92672">=</span> (lo <span style="color:#f92672">+</span> hi) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
                broken <span style="color:#f92672">=</span> dp(K <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
                not_broken <span style="color:#f92672">=</span> dp(K, N <span style="color:#f92672">-</span> mid)
                <span style="color:#66d9ef">if</span> broken <span style="color:#f92672">&gt;</span> not_broken:
                    hi <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
                    res <span style="color:#f92672">=</span> min(res, broken <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
                <span style="color:#66d9ef">else</span>:
                    lo <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    res <span style="color:#f92672">=</span> min(res, not_broken <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)

            memo[(K, N)] <span style="color:#f92672">=</span> res
            <span style="color:#66d9ef">return</span> res

        <span style="color:#66d9ef">return</span> dp(K, N)
<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>superEggDrop(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">14</span>))
</code></pre></div><p>Time: O(K*N*logN)</p>
<p>Space: O(K*N)</p>
<h4 id="solution-3-dp-with-moves-eggs">Solution 3: dp with moves*eggs</h4>
<p>Use a different transition.</p>
<p>Think about the problem as, given K eggs and M moves, what N can you at least reach.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">superEggDrop</span>(self, K, N):
      dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>(K<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]
      m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
      <span style="color:#66d9ef">while</span> dp[m][K] <span style="color:#f92672">&lt;</span> N:
          m <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
          <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, K<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
              dp[m][i] <span style="color:#f92672">=</span> dp[m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][i] <span style="color:#f92672">+</span> dp[m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
      <span style="color:#66d9ef">return</span> m

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>superEggDrop(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">6</span>))
<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>superEggDrop(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">14</span>))
</code></pre></div><p>Time: O(K*N)</p>
<p>Space: O(K*N)</p>
<p>The transition is only related two previous value, we can reduce the dp matrix two O(1).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">superEggDrop</span>(self, K, N):
      m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
      dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (K<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
      <span style="color:#66d9ef">while</span> dp[K] <span style="color:#f92672">&lt;</span> N:
          m <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
          prev <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
          <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, K<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
              tmp <span style="color:#f92672">=</span> dp[i]
              dp[i] <span style="color:#f92672">=</span> dp[i] <span style="color:#f92672">+</span> prev <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
              prev <span style="color:#f92672">=</span> tmp
      <span style="color:#66d9ef">return</span> m
</code></pre></div><h2 id="28-implement-strstr--kmp-algorithm">28 - Implement strStr() (KMP Algorithm)</h2>
<p><a href="https://leetcode.com/problems/implement-strstr/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = &#34;hello&#34;, needle = &#34;ll&#34;
Output: 2
Example 2:

Input: haystack = &#34;aaaaa&#34;, needle = &#34;bba&#34;
Output: -1
</code></pre></div><h3 id="solution">Solution</h3>
<p><a href="https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/dong-tai-gui-hua-zhi-kmp-zi-fu-pi-pei-suan-fa">KMP tutorial</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> __init__(self, pat):
        self<span style="color:#f92672">.</span>pat <span style="color:#f92672">=</span> pat
        self<span style="color:#f92672">.</span>dp <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>KMP(self<span style="color:#f92672">.</span>pat)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">KMP</span>(self, pat):

        M <span style="color:#f92672">=</span> len(pat)
        self<span style="color:#f92672">.</span>dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> <span style="color:#ae81ff">256</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(M)]
        self<span style="color:#f92672">.</span>dp[<span style="color:#ae81ff">0</span>][ord(pat[<span style="color:#ae81ff">0</span>])] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        X <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, M):
            <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">256</span>):
                <span style="color:#66d9ef">if</span> ord(pat[j]) <span style="color:#f92672">==</span> c:
                    self<span style="color:#f92672">.</span>dp[j][c] <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    self<span style="color:#f92672">.</span>dp[j][c] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>dp[X][c]

            X <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>dp[X][ord(pat[j])]

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">search</span>(self, txt):
        M <span style="color:#f92672">=</span> len(self<span style="color:#f92672">.</span>pat)
        N <span style="color:#f92672">=</span> len(txt)
        s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
            s <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>dp[s][ord(txt[i])]
            <span style="color:#66d9ef">if</span> s <span style="color:#f92672">==</span> M:
                <span style="color:#66d9ef">return</span> i <span style="color:#f92672">-</span> M <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

sol <span style="color:#f92672">=</span> Solution(<span style="color:#e6db74">&#34;ababc&#34;</span>)

<span style="color:#66d9ef">print</span>(sol<span style="color:#f92672">.</span>search(<span style="color:#e6db74">&#34;ababdabababc&#34;</span>))
</code></pre></div><h2 id="169-majority-element">169 - Majority Element</h2>
<p><a href="https://leetcode.com/problems/majority-element/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:</p>
<p>Input: [3,2,3]
Output: 3</p>
<p>Example 2:</p>
<p>Input: [2,2,1,1,1,2,2]
Output: 2</p>
<h3 id="solution">Solution</h3>
<h4 id="solution-1-hash-table">Solution 1: Hash Table</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> Counter
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">majorityElement</span>(self, nums):
        c <span style="color:#f92672">=</span> Counter()
        l <span style="color:#f92672">=</span> len(nums)
        <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> nums:
            c[n] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">if</span> c[n] <span style="color:#f92672">&gt;</span> l<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>:
                <span style="color:#66d9ef">return</span> n

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>majorityElement([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>]))
</code></pre></div><p>Time: O(n)</p>
<p>Space: O(n)</p>
<h4 id="solution-2-boyer-moore-majority-vote-algorithm">Solution 2: Boyer-Moore Majority Vote Algorithm</h4>
<p><a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html">http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html</a></p>
<p>This algorithm works only when the majorty exists.</p>
<p>For array like [1, 1, 2, 2, 2, 1], it return 2. But it is not a majority element.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">majorityElement</span>(self, nums):
        counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        ans <span style="color:#f92672">=</span> nums[<span style="color:#ae81ff">0</span>]

        <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> nums[<span style="color:#ae81ff">1</span>:]:
            <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> ans:
                counter <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                counter <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">if</span> counter <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
                    counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
                    ans <span style="color:#f92672">=</span> n
        <span style="color:#66d9ef">return</span> ans
<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>majorityElement([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>]))
</code></pre></div><p>Time: O(n)</p>
<p>Space: O(1)</p>
<h2 id="448-find-all-numbers-disappeard-in-an-array">448 - Find All Numbers Disappeard in an Array</h2>
<p><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p>Example:</p>
<p>Input:
[4,3,2,7,8,2,3,1]</p>
<p>Output:
[5,6]</p>
<h3 id="solution">Solution</h3>
<p>Move all the numbers to its position. For example, 4 move to index 3, 3 move to index 2 and so on.</p>
<p>The numbers at index i, which are not equal i + 1, are the ones disappeared.</p>
<p>The operation is in-place.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findDisappearedNumbers</span>(self, nums):
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
            j <span style="color:#f92672">=</span> i
            <span style="color:#66d9ef">while</span> nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> j:
                nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], j <span style="color:#f92672">=</span> j, nums[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

        <span style="color:#66d9ef">return</span> [i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums)) <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">!=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
</code></pre></div><p>Time: O(N)</p>
<p>Space: O(1)</p>
<h2 id="124-binary-tree-maximum-path-sum">124 - Binary Tree Maximum Path Sum</h2>
<p><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Given a non-empty binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p>
<p>Example 1:</p>
<p>Input: [1,2,3]</p>
<p>1
/ \<br>
2   3</p>
<p>Output: 6
Example 2:</p>
<p>Input: [-10,9,20,null,null,15,7]</p>
<p>-10
/ \<br>
9  20
/  \<br>
15   7</p>
<p>Output: 42</p>
<!-- raw HTML omitted -->
<h3 id="solution">Solution</h3>
<p><strong>Important</strong>:</p>
<p>Remember we should find a path, not a sub tree.</p>
<h4 id="solution-1-hash">Solution 1: Hash</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TreeNode</span>:
    <span style="color:#66d9ef">def</span> __init__(self, val<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, left<span style="color:#f92672">=</span>None, right<span style="color:#f92672">=</span>None):
        self<span style="color:#f92672">.</span>val <span style="color:#f92672">=</span> val
        self<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> left
        self<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> right

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    h <span style="color:#f92672">=</span> defaultdict(int)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxPathSum</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>sys<span style="color:#f92672">.</span>maxsize

        <span style="color:#66d9ef">return</span> max(self<span style="color:#f92672">.</span>maxPathSumFrom(root), self<span style="color:#f92672">.</span>maxPathSum(root<span style="color:#f92672">.</span>left),
                   self<span style="color:#f92672">.</span>maxPathSum(root<span style="color:#f92672">.</span>right))

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxPathSumFrom</span>(self, root):

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">return</span> max(
            root<span style="color:#f92672">.</span>val, root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>maxPathSumDfs(root<span style="color:#f92672">.</span>right),
            root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>maxPathSumDfs(root<span style="color:#f92672">.</span>left), root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span>
            self<span style="color:#f92672">.</span>maxPathSumDfs(root<span style="color:#f92672">.</span>right) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>maxPathSumDfs(root<span style="color:#f92672">.</span>left))

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxPathSumDfs</span>(self, root):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">if</span> root <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>h:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>h[root]
        <span style="color:#66d9ef">else</span>:
            rightSum <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>h<span style="color:#f92672">.</span>get(root<span style="color:#f92672">.</span>right, self<span style="color:#f92672">.</span>maxPathSumDfs(root<span style="color:#f92672">.</span>right))
            leftSum <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>h<span style="color:#f92672">.</span>get(root<span style="color:#f92672">.</span>left, self<span style="color:#f92672">.</span>maxPathSumDfs(root<span style="color:#f92672">.</span>left))
            ans <span style="color:#f92672">=</span> max(root<span style="color:#f92672">.</span>val, root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> rightSum, root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> leftSum)
            self<span style="color:#f92672">.</span>h[root] <span style="color:#f92672">=</span> ans

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h4 id="solution-2-global-maximum-with-dfs">Solution 2: Global maximum with dfs</h4>
<p>The tricky part here is to update the global maximum always with both left branch and right branch,
but dfs only returns with the larger branch of the node, because we have to keep the left and right side as a &ldquo;path&rdquo; not a &ldquo;tree</p>
<p>Version 1:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>sys<span style="color:#f92672">.</span>maxsize

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxPathSum</span>(self, root):
        self<span style="color:#f92672">.</span>dfs(root)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, root):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        left <span style="color:#f92672">=</span> max(self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>left), <span style="color:#ae81ff">0</span>)
        right <span style="color:#f92672">=</span> max(self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>right), <span style="color:#ae81ff">0</span>)

        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> max(self<span style="color:#f92672">.</span>ans, root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> left <span style="color:#f92672">+</span> right)
        <span style="color:#66d9ef">return</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> max(left, right)
</code></pre></div><p>Version 2: I find it easier to understand</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>sys<span style="color:#f92672">.</span>maxsize

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxPathSum</span>(self, root):
        self<span style="color:#f92672">.</span>dfs(root)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, root):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>left)
        right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>right)

        val <span style="color:#f92672">=</span> max(root<span style="color:#f92672">.</span>val, root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> left, root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> right)
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> max(self<span style="color:#f92672">.</span>ans, val, root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> left <span style="color:#f92672">+</span> right)

        <span style="color:#66d9ef">return</span> val
</code></pre></div><h2 id="278-first-bad-version">278 - First Bad Version</h2>
<p><a href="https://leetcode.com/problems/first-bad-version/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are a product manager and currently leading a team to develop a new product.
Unfortunately, the latest version of your product fails the quality check.
Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad.
Implement a function to find the first bad version. You should minimize the number of calls to the API.

Example:

Given n = 5, and version = 4 is the first bad version.

call isBadVersion(3) -&gt; false
call isBadVersion(5) -&gt; true
call isBadVersion(4) -&gt; true

Then 4 is the first bad version.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Binary Search is your friend!</p>
<h4 id="solution-1-binary-search-to-the-end">Solution 1: Binary Search to the end</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">firstBadVerion</span>(self, n):
        l, r, mid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, n, (<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>n) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>

        <span style="color:#66d9ef">while</span> l <span style="color:#f92672">!=</span> mid:
            <span style="color:#66d9ef">if</span> isBadVersion(mid):
                l <span style="color:#f92672">=</span> mid
            <span style="color:#66d9ef">else</span>:
                r <span style="color:#f92672">=</span> mid
            mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>

        <span style="color:#66d9ef">return</span> l <span style="color:#66d9ef">if</span> isBadVersion(l) <span style="color:#66d9ef">else</span> r
</code></pre></div><h4 id="solution-2-binary-search-with-break">Solution 2: Binary Search with break</h4>
<p>It should be faster then solution 1, because we do not wait for l meets mid, which might take longer.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">firstBadVersion</span>(self, n):
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>

        l, r <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>, n

        <span style="color:#66d9ef">while</span> l <span style="color:#f92672">&lt;=</span> r:
            mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">if</span> isBadVersion(mid) <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> isBadVersion(mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">return</span> mid
            <span style="color:#66d9ef">elif</span> isBadVersion(mid):
                r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="106-construct-binary-tree-from-inorder-and-postorder-traversal">106 - Construct Binary Tree from Inorder and Postorder Traversal</h2>
<p><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
</code></pre></div><h3 id="solution">Solution</h3>
<p>The problem is almost the same as <a href="http://alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/">105 Construct BT from Preorder and Inorder</a>. Notes can be found there.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">buildTree</span>(self, inorder: List[int], postorder: List[int]) <span style="color:#f92672">-&gt;</span> TreeNode:
        <span style="color:#66d9ef">if</span> inorder:
            node <span style="color:#f92672">=</span> TreeNode(postorder<span style="color:#f92672">.</span>pop())
            split <span style="color:#f92672">=</span> inorder<span style="color:#f92672">.</span>index(node<span style="color:#f92672">.</span>val)
            node<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>buildTree(inorder[split <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>:], postorder)
            node<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>buildTree(inorder[:split], postorder)

            <span style="color:#66d9ef">return</span> node
</code></pre></div><h2 id="128-longest-consecutive-sequence">128 - Longest Consecutive Sequence</h2>
<p><a href="https://leetcode.com/problems/longest-consecutive-sequence/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

Example:

Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-hash-map">Solution 1: Hash Map</h4>
<p>For each value, we maintain the left bound and right bound of range and also update the bounds for left value and right value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestConsecutive</span>(self, nums):
        h <span style="color:#f92672">=</span> dict()
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> num <span style="color:#f92672">in</span> nums:
            <span style="color:#66d9ef">if</span> num <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> h:
                <span style="color:#66d9ef">if</span> num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> h <span style="color:#f92672">and</span> num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> h:
                    h[h[num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> h[num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]
                    h[h[num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> h[num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]
                    h[num] <span style="color:#f92672">=</span> [h[num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>], h[num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]]
                <span style="color:#66d9ef">elif</span> num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> h:
                    h[h[num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                    h[num] <span style="color:#f92672">=</span> h[h[num <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]]
                <span style="color:#66d9ef">elif</span> num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> h:
                    h[h[num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                    h[num] <span style="color:#f92672">=</span> h[h[num <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]]
                <span style="color:#66d9ef">else</span>:
                    h[num] <span style="color:#f92672">=</span> [num, num]
                ans <span style="color:#f92672">=</span> max(ans, h[num][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> h[num][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><p>Time: O(n)</p>
<p>Space: O(n)</p>
<h4 id="solution-2-keep-counting">Solution 2: Keep Counting!</h4>
<p>Notice the <code>if x - t not in nums</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestConsecutive</span>(self, nums):
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        nums <span style="color:#f92672">=</span> set(nums)
        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> nums:
            <span style="color:#66d9ef">if</span> x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> nums:
                y <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">while</span> y <span style="color:#f92672">in</span> nums:
                    y <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                ans <span style="color:#f92672">=</span> max(ans, y <span style="color:#f92672">-</span> x)
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><p>Time: O(n)</p>
<p>Space: O(n)</p>
<h2 id="98-validate-binary-search-tree">98 - Validate Binary Search Tree</h2>
<p><a href="https://leetcode.com/problems/validate-binary-search-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

- The left subtree of a node contains only nodes with keys less than the node&#39;s key.
- The right subtree of a node contains only nodes with keys greater than the node&#39;s key.
- Both the left and right subtrees must also be binary search trees.

Example 1:

    2
   / \
  1   3

Input: [2,1,3]
Output: true

Example 2:

    5
   / \
  1   4
     / \
    3   6

Input: [5,1,4,null,null,3,6]
Output: false
Explanation: The root node&#39;s value is 5 but its right child&#39;s value is 4.
</code></pre></div><h3 id="solution">Solution</h3>
<p><strong>Important</strong>:</p>
<p>You don&rsquo;t only valid the current node with its left and right value.
You have to:</p>
<ul>
<li>pass the new high bound for left branch, because all the values in the left branch must be less than this high bound, low bound remains</li>
<li>pass the new low bound for right branch, because all the values in the right branch must be greater than this low bound, high bound remains</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isValidBST</span>(self, root):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>isValidBSTBound(root, <span style="color:#f92672">-</span>sys<span style="color:#f92672">.</span>maxsize, sys<span style="color:#f92672">.</span>maxisze)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isValidBSTBound</span>(self, root, lb, hb):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">if</span> lb <span style="color:#f92672">&lt;</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">&lt;</span> hb:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>isValidBSTBound(root<span style="color:#f92672">.</span>left, lb, root<span style="color:#f92672">.</span>val) <span style="color:#f92672">and</span> self<span style="color:#f92672">.</span>isValidBSTBound(root<span style="color:#f92672">.</span>right, root<span style="color:#f92672">.</span>val, hb)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> False
</code></pre></div><h2 id="1009-complement-of-base-10-integer">1009 - Complement of Base 10 Integer</h2>
<p><a href="https://leetcode.com/problems/complement-of-base-10-integer/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Every non-negative integer N has a binary representation.  For example, 5 can be represented as &#34;101&#34; in binary, 11 as &#34;1011&#34; in binary, and so on.  Note that except for N = 0, there are no leading zeroes in any binary representation.

The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1.  For example, the complement of &#34;101&#34; in binary is &#34;010&#34; in binary.

For a given number N in base-10, return the complement of it&#39;s binary representation as a base-10 integer.

Example 1:

Input: 5
Output: 2
Explanation: 5 is &#34;101&#34; in binary, with complement &#34;010&#34; in binary, which is 2 in base-10.

Example 2:

Input: 7
Output: 0
Explanation: 7 is &#34;111&#34; in binary, with complement &#34;000&#34; in binary, which is 0 in base-10.

Example 3:

Input: 10
Output: 5
Explanation: 10 is &#34;1010&#34; in binary, with complement &#34;0101&#34; in binary, which is 5 in base-10.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-xor">Solution 1: XOR</h4>
<p>Watch out the corner case when num is 0.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bitwiseComplement</span>(self, num: int) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> num <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>

        c <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        n <span style="color:#f92672">=</span> num
        <span style="color:#66d9ef">while</span> n:
            c <span style="color:#f92672">*=</span> <span style="color:#ae81ff">2</span>
            n <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> num <span style="color:#f92672">^</span> (c <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</code></pre></div><h4 id="solution-2">Solution 2:</h4>
<p><code>x = 2 * x + 1</code></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">1 = 1
1*2 + 1 = 3 = 11
3*2 + 1 = 7 = 111
7*2 + 1 = 15 = 1111
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bitwiseComplement</span>(self, num):
        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> x <span style="color:#f92672">&lt;</span> num: x <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> x <span style="color:#f92672">-</span> num
</code></pre></div><h2 id="337-house-robber-iii">337 - House Robber III</h2>
<p><a href="https://leetcode.com/problems/house-robber-iii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &#34;root.&#34; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &#34;all houses in this place forms a binary tree&#34;. It will automatically contact the police if two directly-linked houses were broken into on the same night.

Determine the maximum amount of money the thief can rob tonight without alerting the police.

Example 1:

Input: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \
     3   1

Output: 7
Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
Example 2:

Input: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \
 1   3   1

Output: 9
Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9.
</code></pre></div><h3 id="solution">Solution</h3>
<p>We can do it recursively with a memo, to reduce the search depth.</p>
<p>On every node, we have 2 statuses, which will determine our next move:</p>
<ul>
<li>
<p>Status:</p>
<ol>
<li>Existence of current node</li>
<li>Wether the parent node was robbed?</li>
</ol>
<p>So we can define a recursive function with two parameters:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">robRec</span>(root, isRobbed)
</code></pre></div></li>
<li>
<p>Transition:</p>
<ul>
<li>
<p>If parent robbed</p>
<p>Then we can not rob the current node, we just sum up the result of the children</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">ans <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>left, False) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>right, Falsek)
</code></pre></div></li>
<li>
<p>If not robbed</p>
<p>Then we have a choice: rob the current node or not.</p>
<ul>
<li>
<p>if we rob the current node</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">rob <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>left, True) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>right, True)
</code></pre></div></li>
<li>
<p>if we do not rob the current node</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">not_rob <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>left, False) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>right, True)
</code></pre></div></li>
</ul>
</li>
</ul>
<p>And we have to choose the greater one</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">ans <span style="color:#f92672">=</span> max(rob, not_rob)
</code></pre></div></li>
<li>
<p>Initial state</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">root <span style="color:#f92672">=</span> root
isRobbed <span style="color:#f92672">=</span> False
</code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    memo <span style="color:#f92672">=</span> {}
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rob</span>(self, root):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>robRec(root, False)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">robRec</span>(self, root, isRobbed):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">if</span> (root, isRobbed) <span style="color:#f92672">in</span> memo:
            <span style="color:#66d9ef">return</span> memo[(root, isRobbed)]

        <span style="color:#66d9ef">if</span> isRobbed:
            ans <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>left, False) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>right, False)
        <span style="color:#66d9ef">else</span>:
            ans <span style="color:#f92672">=</span> max(root<span style="color:#f92672">.</span>val <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>left, True) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>right, True),
                      self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>left, False) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>robRec(root<span style="color:#f92672">.</span>right, False))

        memo[(root, isRobbed)] <span style="color:#f92672">=</span> ans

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="cousins-in-binary-tree">Cousins in Binary Tree</h2>
<p><a href="https://leetcode.com/explore/featured/card/may-leetcoding-challenge/534/week-1-may-1st-may-7th/3322/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">
In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.

Two nodes of a binary tree are cousins if they have the same depth, but have different parents.

We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.

Return true if and only if the nodes corresponding to the values x and y are cousins.

Example 1:

Input: root = [1,2,3,4], x = 4, y = 3
Output: false
Example 2:

Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
Output: true
Example 3:

Input: root = [1,2,3,null,4], x = 2, y = 3
Output: false

Note:

The number of nodes in the tree will be between 2 and 100.
Each node has a unique integer value from 1 to 100.
</code></pre></div><h3 id="solution">Solution</h3>
<ul>
<li>depth funciton for depth comparison</li>
<li>A map for remember the parent value of the node</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    m <span style="color:#f92672">=</span> {}

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isCousins</span>(self, root, x, y):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>depth(root, x) <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>depth(root, y):
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>m[x] <span style="color:#f92672">!=</span> self<span style="color:#f92672">.</span>m[y]

        <span style="color:#66d9ef">return</span> False

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">depth</span>(self, root, val):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> val:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">else</span>:

            left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>depth(root<span style="color:#f92672">.</span>left, val)
            right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>depth(root<span style="color:#f92672">.</span>right, val)

            <span style="color:#66d9ef">if</span> left <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                self<span style="color:#f92672">.</span>m[root<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>val] <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>val
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> left
            <span style="color:#66d9ef">elif</span> right <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                self<span style="color:#f92672">.</span>m[root<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>val] <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>val
                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> right

        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="1232-check-if-it-is-a-straight-line">1232 - Check If It Is a Straight Line</h2>
<p><a href="https://leetcode.com/problems/check-if-it-is-a-straight-line/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given an array coordinates, coordinates[i] = [x, y],
where [x, y] represents the coordinate of a point.

Check if these points make a straight line in the XY plane.
</code></pre></div><h3 id="solution">Solution</h3>
<p><strong>Important</strong></p>
<p>Notice the divider. It may be zero, when the lines are horizontal.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">checkStraightLine</span>(self, coordinates: List[List[int]]) <span style="color:#f92672">-&gt;</span> bool:
        p1 <span style="color:#f92672">=</span> coordinates[<span style="color:#ae81ff">0</span>]
        p2 <span style="color:#f92672">=</span> coordinates[<span style="color:#ae81ff">1</span>]
        slope <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>slope(p1, p2)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, len(coordinates)):
            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>slope(coordinates[<span style="color:#ae81ff">0</span>], coordinates[i]) <span style="color:#f92672">!=</span> slope:
                <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">return</span> True

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">slope</span>(self, p1, p2):
        <span style="color:#66d9ef">if</span> p1[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> p2[<span style="color:#ae81ff">1</span>]:
            <span style="color:#66d9ef">return</span> sys<span style="color:#f92672">.</span>maxsize

        <span style="color:#66d9ef">return</span> (p1[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> p2[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">/</span> (p1[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> p2[<span style="color:#ae81ff">1</span>])
</code></pre></div><h2 id="733-flood-fill">733 - Flood Fill</h2>
<p><a href="https://leetcode.com/problems/flood-fill/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).

Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, &#34;flood fill&#34; the image.

To perform a &#34;flood fill&#34;, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.

At the end, return the modified image.

Example 1:
Input:
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation:
From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected
by a path of the same color as the starting pixel are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected
to the starting pixel.
Note:

The length of image and image[0] will be in the range [1, 50].
The given starting pixel will satisfy 0 &lt;= sr &lt; image.length and 0 &lt;= sc &lt; image[0].length.
The value of each color in image[i][j] and newColor will be an integer in [0, 65535].
</code></pre></div><h3 id="solution">Solution</h3>
<p>Stack.</p>
<ol>
<li>Add the starting point to stack</li>
<li>Stack pop. Fill the point, add its valid neighbours to the stack.</li>
<li>Repeat 2 until stack is empty</li>
</ol>
<p><strong>Important</strong>:</p>
<p>When the color to fill is the same as the starting  point. We don&rsquo;t need to continue.
Otherwise you will be always adding the same points again and again into the stack.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">floodFill</span>(self, image, sr: int, sc: int, newColor: int):
        oldColor <span style="color:#f92672">=</span> image[sr][sc]
        stack <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">if</span> newColor <span style="color:#f92672">!=</span> oldColor:
            stack<span style="color:#f92672">.</span>append([sr, sc])

        m <span style="color:#f92672">=</span> len(image)
        n <span style="color:#f92672">=</span> len(image[<span style="color:#ae81ff">0</span>])

        <span style="color:#66d9ef">while</span> stack:
            p <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span>pop()
            x, y <span style="color:#f92672">=</span> p

            image[x][y] <span style="color:#f92672">=</span> newColor

            <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> [[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]]:
                <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> [<span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                    r <span style="color:#f92672">=</span> v[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> s
                    c <span style="color:#f92672">=</span> v[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> s
                    <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">+</span> r <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> y <span style="color:#f92672">+</span> c <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">and</span> image[x <span style="color:#f92672">+</span> r][y <span style="color:#f92672">+</span> c] <span style="color:#f92672">==</span> oldColor:
                        stack<span style="color:#f92672">.</span>append([x <span style="color:#f92672">+</span> r, y <span style="color:#f92672">+</span> c])

        <span style="color:#66d9ef">return</span> image
</code></pre></div><h2 id="997-find-the-town-judge">997 - Find the Town Judge</h2>
<p><a href="https://leetcode.com/problems/find-the-town-judge/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">In a town, there are N people labelled from 1 to N.
There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:

1. The town judge trusts nobody.
2. Everybody (except for the town judge) trusts the town judge.
3. There is exactly one person that satisfies properties 1 and 2.

You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.

Example 1:

Input: N = 2, trust = [[1,2]]
Output: 2

Example 2:

Input: N = 3, trust = [[1,3],[2,3]]
Output: 3

Example 3:

Input: N = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1

Example 4:

Input: N = 3, trust = [[1,2],[2,3]]
Output: -1

Example 5:

Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
Output: 3


Note:

1 &lt;= N &lt;= 1000
trust.length &lt;= 10000
trust[i] are all different
trust[i][0] != trust[i][1]
1 &lt;= trust[i][0], trust[i][1] &lt;= N
</code></pre></div><h3 id="solution">Solution</h3>
<p>Two tables:</p>
<ol>
<li>one for counting how many trusts each person gets</li>
<li>one for counting how many other people each person trusts</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findJudge</span>(self, N: int, trust: List[List[int]]) <span style="color:#f92672">-&gt;</span> int:
        people <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (N)
        h <span style="color:#f92672">=</span> defaultdict(int)

        <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> trust:
            people[t[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            h[t[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N):
            <span style="color:#66d9ef">if</span> people[i] <span style="color:#f92672">&gt;=</span> N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> h[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">return</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="540-single-element-in-a-sorted-array">540 - Single Element in a Sorted Array</h2>
<p><a href="https://leetcode.com/problems/single-element-in-a-sorted-array/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<blockquote>
<p>You are given a sorted array consisting of only integers where every element appears exactly twice,
except for one element which appears exactly once. Find this single element that appears only once.</p>
<p>Example 1:</p>
<p>Input: [1,1,2,3,3,4,4,8,8]
Output: 2</p>
<p>Example 2:</p>
<p>Input: [3,3,7,7,10,11,11]
Output: 10</p>
</blockquote>
<h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">singleNonDuplicate</span>(self, nums):
        lo <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        hi <span style="color:#f92672">=</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">while</span> lo <span style="color:#f92672">&lt;</span> hi:
            mid <span style="color:#f92672">=</span> (lo <span style="color:#f92672">+</span> hi) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">if</span> mid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">return</span> mid

            <span style="color:#66d9ef">if</span> (mid <span style="color:#f92672">-</span> lo <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">if</span> nums[mid] <span style="color:#f92672">==</span> nums[mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]:
                    lo <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    hi <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">if</span> nums[mid] <span style="color:#f92672">==</span> nums[mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]:
                    hi <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>
                <span style="color:#66d9ef">else</span>:
                    lo <span style="color:#f92672">=</span> mid
        <span style="color:#66d9ef">return</span> nums[lo]

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>singleNonDuplicate([<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">10</span>]))
</code></pre></div><h2 id="402-remove-k-digits">402 - Remove K Digits</h2>
<p><a href="https://leetcode.com/problems/remove-k-digits/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<blockquote>
<p>Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.</p>
<p>Note:
The length of num is less than 10002 and will be ≥ k.
The given num does not contain any leading zero.</p>
<p>Example 1:</p>
<p>Input: num = &ldquo;1432219&rdquo;, k = 3
Output: &ldquo;1219&rdquo;
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</p>
<p>Example 2:</p>
<p>Input: num = &ldquo;10200&rdquo;, k = 1
Output: &ldquo;200&rdquo;
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</p>
<p>Example 3:</p>
<p>Input: num = &ldquo;10&rdquo;, k = 2
Output: &ldquo;0&rdquo;
Explanation: Remove all the digits from the number and it is left with nothing which is 0.</p>
</blockquote>
<h3 id="solution">Solution</h3>
<p>Stack</p>
<p>Corner cases:</p>
<blockquote>
<p>&lsquo;1234567&rsquo; k = 3: k will not be reduced to 0. So stack[:-k or None]
&lsquo;10200&rsquo; k = 1: k can be reduced to 0. stack[:-0] will result in []. So stack[:-k or None]
&lsquo;1000000&rsquo; k = 1: &hellip;&hellip;lstrip(&lsquo;0&rsquo;) will result 0. So we have to add <code>or '0'</code></p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">removeKdigits</span>(self, num, k):
        stack <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> num:
            <span style="color:#66d9ef">while</span> k <span style="color:#f92672">and</span> stack <span style="color:#f92672">and</span> stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> c:
                stack<span style="color:#f92672">.</span>pop()
                k <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
            stack<span style="color:#f92672">.</span>append(c)

        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(stack[:<span style="color:#f92672">-</span>k <span style="color:#f92672">or</span> None])<span style="color:#f92672">.</span>lstrip(<span style="color:#e6db74">&#39;0&#39;</span>) <span style="color:#f92672">or</span> <span style="color:#e6db74">&#39;0&#39;</span>
</code></pre></div><h2 id="208-implement-trie--prefix-tree">208 - Implement Trie (Prefix Tree)</h2>
<p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<blockquote>
<p>Implement a trie with insert, search, and startsWith methods.</p>
<p>Example:</p>
<p>Trie trie = new Trie();</p>
<p>trie.insert(&ldquo;apple&rdquo;);
trie.search(&ldquo;apple&rdquo;);   <em>/ returns true
trie.search(&ldquo;app&rdquo;);     /</em> returns false
trie.startsWith(&ldquo;app&rdquo;); // returns true
trie.insert(&ldquo;app&rdquo;);
trie.search(&ldquo;app&rdquo;);     // returns true</p>
</blockquote>
<h3 id="solution">Solution</h3>
<p>Trie.</p>
<p>Use a &ldquo;END&rdquo; Symbol for word ending.</p>
<p><code>search</code> method checks for &ldquo;END&rdquo;, <code>startsWith</code> not.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span>:

    <span style="color:#66d9ef">def</span> __init__(self):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Initialize your data structure here.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>root <span style="color:#f92672">=</span> Node()


    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(self, word: str) <span style="color:#f92672">-&gt;</span> None:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Inserts a word into the trie.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        node <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>root
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> word:
            node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>next[c]

        node<span style="color:#f92672">.</span>isWord <span style="color:#f92672">=</span> True

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">search</span>(self, word: str) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Returns if the word is in the trie.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        node <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>root

        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> word:
            node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>get(c)
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> node:
                <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">return</span> node<span style="color:#f92672">.</span>isWord


    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">startsWith</span>(self, prefix: str) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Returns if there is any word in the trie that starts with the given prefix.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        node <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>root
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> prefix:
            node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>get(c)
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> node:
                <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">return</span> True

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span>:
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> defaultdict(Node)
        self<span style="color:#f92672">.</span>isWord <span style="color:#f92672">=</span> False


s <span style="color:#f92672">=</span> Trie()

s<span style="color:#f92672">.</span>insert(<span style="color:#e6db74">&#34;apple&#34;</span>)
s<span style="color:#f92672">.</span>insert(<span style="color:#e6db74">&#34;banana&#34;</span>)
<span style="color:#66d9ef">print</span>(s<span style="color:#f92672">.</span>search(<span style="color:#e6db74">&#34;app&#34;</span>))
<span style="color:#66d9ef">print</span>(s<span style="color:#f92672">.</span>search(<span style="color:#e6db74">&#34;bananananana&#34;</span>))
<span style="color:#66d9ef">print</span>(s<span style="color:#f92672">.</span>search(<span style="color:#e6db74">&#34;banana&#34;</span>))
<span style="color:#66d9ef">print</span>(s<span style="color:#f92672">.</span>startsWith(<span style="color:#e6db74">&#34;ban&#34;</span>))
</code></pre></div><h2 id="918-maximum-sum-circular-subarray">918 - Maximum Sum Circular Subarray</h2>
<p><a href="https://leetcode.com/problems/maximum-sum-circular-subarray/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<blockquote>
<p>Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.</p>
<p>Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, C[i] = A[i] when 0 &lt;= i &lt; A.length, and C[i+A.length] = C[i] when i &gt;= 0.)</p>
<p>Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray C[i], C[i+1], &hellip;, C[j], there does not exist i &lt;= k1, k2 &lt;= j with k1 % A.length = k2 % A.length.)</p>
<p>Example 1:</p>
<p>Input: [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3</p>
<p>Example 2:</p>
<p>Input: [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10</p>
<p>Example 3:</p>
<p>Input: [3,-1,2,-1]
Output: 4
Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4</p>
<p>Example 4:</p>
<p>Input: [3,-2,2,-3]
Output: 3
Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</p>
<p>Example 5:</p>
<p>Input: [-2,-3,-1]
Output: -1
Explanation: Subarray [-1] has maximum sum -1</p>
<p>Note:</p>
<p>-30000 &lt;= A[i] &lt;= 30000
1 &lt;= A.length &lt;= 30000</p>
</blockquote>
<h3 id="solution">Solution</h3>
<p>Use dp we can solve the problem without circular easily. See problem 53. Maximum Subarray.</p>
<p>So we have a maxSum.</p>
<p>There are only two possibility where the sub array locates.</p>
<ol>
<li>
<p>The sub array is in the loop of array</p>
<p>&mdash;-[&mdash;&ndash;]&mdash;&ndash; &mdash;&mdash;&mdash;&mdash;</p>
<p>It&rsquo;s <code>maxSum</code>.</p>
</li>
<li>
<p>The sub array connects the next loop.</p>
<p>&mdash;&mdash;&mdash;-[&ndash; &mdash;]&mdash;&mdash;&mdash;-</p>
<p>we can rearrange it to:</p>
<p>[&mdash;]&mdash;&mdash;[&ndash;]</p>
<p>The the part outside the maximum subarray is &ldquo;minimum subarray&rdquo;.</p>
<p>And we can calculate the <code>minSum</code> with the same algorithm for <code>maxSum</code>.</p>
</li>
</ol>
<p>The results is</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">max(maxSum, s <span style="color:#f92672">-</span> minSum)
</code></pre></div><p>Corner case:</p>
<p>When all elements are negative, the maxSum is also negative. and s - minSum would be 0. max(maxSum, s - minSum) is 0.</p>
<p>But according to the description, we should return maxSum.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxSubarraySumCircular</span>(self, A):
        curMin <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        curMax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        minSum <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>maxsize
        maxSum <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>sys<span style="color:#f92672">.</span>maxsize
        s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> A:
            s <span style="color:#f92672">+=</span> c
            curMax <span style="color:#f92672">=</span> max(c, curMax <span style="color:#f92672">+</span> c)
            maxSum <span style="color:#f92672">=</span> max(maxSum, curMax)
            curMin <span style="color:#f92672">=</span> min(c, curMin <span style="color:#f92672">+</span> c)
            minSum <span style="color:#f92672">=</span> min(minSum, curMin)

        <span style="color:#66d9ef">return</span> max(maxSum, s <span style="color:#f92672">-</span> minSum) <span style="color:#66d9ef">if</span> maxSum <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> maxSum
</code></pre></div><h2 id="328-odd-even-linked-list">328 - Odd Even Linked List</h2>
<p><a href="https://leetcode.com/problems/odd-even-linked-list/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a singly linked list, group all odd nodes together followed by the even nodes.
Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

Example 1:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL

Example 2:

Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL
Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL
Note:

The relative order inside both the even and odd groups should remain as it was in the input.
The first node is considered odd, the second node even and so on ...
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">oddEvenList</span>(self, head: ListNode) <span style="color:#f92672">-&gt;</span> ListNode:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> head <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> head<span style="color:#f92672">.</span>next <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> head<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next:
            <span style="color:#66d9ef">return</span> head

        p1, p2 <span style="color:#f92672">=</span> head, head<span style="color:#f92672">.</span>next
        even <span style="color:#f92672">=</span> p2

        <span style="color:#66d9ef">while</span> p2 <span style="color:#f92672">and</span> p2<span style="color:#f92672">.</span>next:
            p1<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> p2<span style="color:#f92672">.</span>next
            p1 <span style="color:#f92672">=</span> p1<span style="color:#f92672">.</span>next
            p2<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> p1<span style="color:#f92672">.</span>next
            p2 <span style="color:#f92672">=</span> p2<span style="color:#f92672">.</span>next

        p1<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> even

        <span style="color:#66d9ef">return</span> head
</code></pre></div><h2 id="438-find-all-anagrams-in-a-string">438 - Find All Anagrams in a String</h2>
<p><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string s and a non-empty string p, find all the start indices of p&#39;s anagrams in s.

Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.

The order of output does not matter.

Example 1:

Input:
s: &#34;cbaebabacd&#34; p: &#34;abc&#34;

Output:
[0, 6]

Explanation:
The substring with start index = 0 is &#34;cba&#34;, which is an anagram of &#34;abc&#34;.
The substring with start index = 6 is &#34;bac&#34;, which is an anagram of &#34;abc&#34;.
Example 2:

Input:
s: &#34;abab&#34; p: &#34;ab&#34;

Output:
[0, 1, 2]

Explanation:
The substring with start index = 0 is &#34;ab&#34;, which is an anagram of &#34;ab&#34;.
The substring with start index = 1 is &#34;ba&#34;, which is an anagram of &#34;ab&#34;.
The substring with start index = 2 is &#34;ab&#34;, which is an anagram of &#34;ab&#34;.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findAllAnagrams</span>(self, s, p):
        target, window <span style="color:#f92672">=</span> defaultdict(int), defaultdict(int)
        left, right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
        match <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        ans <span style="color:#f92672">=</span> []

        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> p:
            target[c] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">while</span> right <span style="color:#f92672">&lt;</span> len(s):
            c <span style="color:#f92672">=</span> s[right]
            <span style="color:#66d9ef">if</span> c <span style="color:#f92672">in</span> target:
                window[c] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">if</span> window[c] <span style="color:#f92672">==</span> target[c]:
                    match <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

            right <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

            <span style="color:#66d9ef">while</span> right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> len(p):
                <span style="color:#66d9ef">if</span> match <span style="color:#f92672">==</span> len(target):
                    ans<span style="color:#f92672">.</span>append(left)
                c <span style="color:#f92672">=</span> s[left]
                left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

                <span style="color:#66d9ef">if</span> c <span style="color:#f92672">in</span> window:
                    <span style="color:#66d9ef">if</span> window[c] <span style="color:#f92672">==</span> target[c]:
                        match <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                    window[c] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>


        <span style="color:#66d9ef">return</span> ans

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>findAllAnagrams(<span style="color:#e6db74">&#34;cbaeabac&#34;</span>, <span style="color:#e6db74">&#34;abc&#34;</span>))
</code></pre></div><h2 id="567-permutation-in-string">567 - Permutation in String</h2>
<p><a href="https://leetcode.com/problems/permutation-in-string/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1.
In other words, one of the first string&#39;s permutations is the substring of the second string.

Example 1:

Input: s1 = &#34;ab&#34; s2 = &#34;eidbaooo&#34;
Output: True
Explanation: s2 contains one permutation of s1 (&#34;ba&#34;).

Example 2:

Input:s1= &#34;ab&#34; s2 = &#34;eidboaoo&#34;
Output: False


Note:

The input strings only contain lower case letters.
The length of both given strings is in range [1, 10,000].
Accepted
</code></pre></div><h3 id="solution">Solution</h3>
<p>Sliding window.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">checkInclusion</span>(self, s1: str, s2: str) <span style="color:#f92672">-&gt;</span> bool:
        target, window <span style="color:#f92672">=</span> defaultdict(int), defaultdict(int)
        left, right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
        match <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s1:
            target[c] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">&lt;</span> len(s2)):

            c <span style="color:#f92672">=</span> s2[right]
            <span style="color:#66d9ef">if</span> c <span style="color:#f92672">in</span> target:
                window[c] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">if</span> window[c] <span style="color:#f92672">==</span> target[c]:
                    match <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

            right <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

            <span style="color:#66d9ef">while</span> (right <span style="color:#f92672">-</span> left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> len(s1)):
                <span style="color:#66d9ef">if</span> match <span style="color:#f92672">==</span> len(target):
                    <span style="color:#66d9ef">return</span> True
                c <span style="color:#f92672">=</span> s2[left]
                left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

                <span style="color:#66d9ef">if</span> c <span style="color:#f92672">in</span> window:
                    <span style="color:#66d9ef">if</span> window[c] <span style="color:#f92672">==</span> target[c]:
                        match <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>

                    window[c] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> False
</code></pre></div><h2 id="901-onine-stock-span">901 - Onine Stock Span</h2>
<p><a href="https://leetcode.com/problems/online-stock-span/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock&#39;s price for the current day.

The span of the stock&#39;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today&#39;s price.

For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].



Example 1:

Input: [&#34;StockSpanner&#34;,&#34;next&#34;,&#34;next&#34;,&#34;next&#34;,&#34;next&#34;,&#34;next&#34;,&#34;next&#34;,&#34;next&#34;], [[],[100],[80],[60],[70],[60],[75],[85]]
Output: [null,1,1,1,2,1,4,6]
Explanation:
First, S = StockSpanner() is initialized.  Then:
S.next(100) is called and returns 1,
S.next(80) is called and returns 1,
S.next(60) is called and returns 1,
S.next(70) is called and returns 2,
S.next(60) is called and returns 1,
S.next(75) is called and returns 4,
S.next(85) is called and returns 6.

Note that (for example) S.next(75) returned 4, because the last 4 prices
(including today&#39;s price of 75) were less than or equal to today&#39;s price.

Note:

Calls to StockSpanner.next(int price) will have 1 &lt;= price &lt;= 10^5.
There will be at most 10000 calls to StockSpanner.next per test case.
There will be at most 150000 calls to StockSpanner.next across all test cases.
The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Stack problem.</p>
<p>Pop all the smaller one and calculate the result before pushing current one into stack.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StockSpanner</span>:

    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>stack<span style="color:#f92672">=</span>[]

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">next</span>(self, price):
        res<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> self<span style="color:#f92672">.</span>stack <span style="color:#f92672">and</span> self<span style="color:#f92672">.</span>stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&lt;=</span>price:
            res<span style="color:#f92672">+=</span>self<span style="color:#f92672">.</span>stack<span style="color:#f92672">.</span>pop()[<span style="color:#ae81ff">1</span>]

        self<span style="color:#f92672">.</span>stack<span style="color:#f92672">.</span>append([price,res])

        <span style="color:#66d9ef">return</span> res
</code></pre></div><h2 id="230-kth-smallest-element-in-a-bst">230 - Kth Smallest Element in a BST</h2>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">230. Kth Smallest Element in a BST
Medium

2239

57

Add to List

Share
Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note:
You may assume k is always valid, 1 ≤ k ≤ BST&#39;s total elements.

Example 1:

Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1
Example 2:

Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kthSmallest</span>(self, root):
        self<span style="color:#f92672">.</span>k <span style="color:#f92672">=</span> k
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>val
        traverse(root)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">traverse</span>(self, root):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span>
        traverse(root<span style="color:#f92672">.</span>left)

        self<span style="color:#f92672">.</span>k <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>k:
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>val
        <span style="color:#66d9ef">else</span>:
            traverse(root<span style="color:#f92672">.</span>right)
</code></pre></div><h2 id="1277-count-square-submatrices-with-all-ones">1277 - Count Square Submatrices with All Ones</h2>
<p><a href="https://leetcode.com/problems/count-square-submatrices-with-all-ones/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.



Example 1:

Input: matrix =
[
  [0,1,1,1],
  [1,1,1,1],
  [0,1,1,1]
]
Output: 15
Explanation:
There are 10 squares of side 1.
There are 4 squares of side 2.
There is  1 square of side 3.
Total number of squares = 10 + 4 + 1 = 15.

Example 2:

Input: matrix =
[
  [1,0,1],
  [1,1,0],
  [1,1,0]
]
Output: 7
Explanation:
There are 6 squares of side 1.
There is 1 square of side 2.
Total number of squares = 6 + 1 = 7.
</code></pre></div><h3 id="solution">Solution</h3>
<p>DP problem. Same as p227.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countSquares</span>(self, matrix):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> matrix[<span style="color:#ae81ff">0</span>]:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        m <span style="color:#f92672">=</span> len(matrix)
        n <span style="color:#f92672">=</span> len(matrix[<span style="color:#ae81ff">0</span>])
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(m):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
                <span style="color:#66d9ef">if</span> matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
                    <span style="color:#66d9ef">if</span> i <span style="color:#f92672">and</span> j:
                        matrix[i][j] <span style="color:#f92672">=</span> min(matrix[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], matrix[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], matrix[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    ans <span style="color:#f92672">+=</span> matrix[i][j]
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="76-minimum-window-substring">76 - Minimum Window Substring</h2>
<p><a href="https://leetcode.com/problems/minimum-window-substring/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

Example:

Input: S = &#34;ADOBECODEBANC&#34;, T = &#34;ABC&#34;
Output: &#34;BANC&#34;
Note:

If there is no such window in S that covers all characters in T, return the empty string &#34;&#34;.
If there is such window, you are guaranteed that there will always be only one unique minimum window in S.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minWindow</span>(self, s: str, t: str) <span style="color:#f92672">-&gt;</span> str:
        target, window <span style="color:#f92672">=</span> defaultdict(int), defaultdict(int)
        left, right, match <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
        d <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#34;inf&#34;</span>)
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> t:
            target[c] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> right <span style="color:#f92672">&lt;</span> len(s):
            c <span style="color:#f92672">=</span> s[right]
            <span style="color:#66d9ef">if</span> c <span style="color:#f92672">in</span> target:
                window[c] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">if</span> window[c] <span style="color:#f92672">==</span> target[c]:
                    match <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            right <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

            <span style="color:#66d9ef">while</span> (match <span style="color:#f92672">==</span> len(target)):
                <span style="color:#66d9ef">if</span> right <span style="color:#f92672">-</span> left <span style="color:#f92672">&lt;</span> d:
                    ans <span style="color:#f92672">=</span> s[left:right]
                    d <span style="color:#f92672">=</span> right <span style="color:#f92672">-</span> left

                c <span style="color:#f92672">=</span> s[left]
                left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

                <span style="color:#66d9ef">if</span> c <span style="color:#f92672">in</span> target:
                    <span style="color:#66d9ef">if</span> window[c] <span style="color:#f92672">==</span> target[c]:
                        match <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                    window[c] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#66d9ef">if</span> d <span style="color:#f92672">==</span> float(<span style="color:#e6db74">&#34;inf&#34;</span>) <span style="color:#66d9ef">else</span> ans
</code></pre></div><h2 id="451-sort-characters-by-frequency">451 - Sort Characters By Frequency</h2>
<p><a href="https://leetcode.com/problems/sort-characters-by-frequency/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string, sort it in decreasing order based on the frequency of characters.

Example 1:

Input:
&#34;tree&#34;

Output:
&#34;eert&#34;

Explanation:
&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.
So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &#34;eetr&#34; is also a valid answer.

Example 2:

Input:
&#34;cccaaa&#34;

Output:
&#34;cccaaa&#34;

Explanation:
Both &#39;c&#39; and &#39;a&#39; appear three times, so &#34;aaaccc&#34; is also a valid answer.
Note that &#34;cacaca&#34; is incorrect, as the same characters must be together.

Example 3:

Input:
&#34;Aabb&#34;

Output:
&#34;bbAa&#34;

Explanation:
&#34;bbaA&#34; is also a valid answer, but &#34;Aabb&#34; is incorrect.
Note that &#39;A&#39; and &#39;a&#39; are treated as two different characters.
</code></pre></div><h3 id="solution">Solution</h3>
<ol>
<li>Use a map to count the characters.</li>
<li>Loop the map to the characters into a map using the frequency as key. The value will be a list, containing all the characters with the same frequency.</li>
<li>Go through the map.</li>
</ol>
<h4 id="solution-1-two-maps">Solution 1: Two maps</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">frequencySort</span>(self, s: str) <span style="color:#f92672">-&gt;</span> str:
        cnt <span style="color:#f92672">=</span> defaultdict(int)
        freq <span style="color:#f92672">=</span> {}
        max_f <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        ans <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>

        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
            cnt[c] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> c, f <span style="color:#f92672">in</span> cnt<span style="color:#f92672">.</span>items():
            <span style="color:#66d9ef">if</span> f <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> freq:
                freq[f] <span style="color:#f92672">=</span> []

            freq[f]<span style="color:#f92672">.</span>append(c)
            max_f <span style="color:#f92672">=</span> max(max_f, f)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(max_f, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">in</span> freq:
                <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> freq[i]:
                    ans <span style="color:#f92672">+=</span> c <span style="color:#f92672">*</span> i

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h4 id="solution-2-one-liner">Solution 2: One liner</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> Counter
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">frequencySort</span>(self, s):
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([c <span style="color:#f92672">*</span> cnt <span style="color:#66d9ef">for</span> c, cnt <span style="color:#f92672">in</span> Counter(s)<span style="color:#f92672">.</span>most_common()])
</code></pre></div><h3 id="similar-problems">Similar Problems</h3>
<h4 id="347-dot-top-k-frequent-element">347. Top K Frequent Element</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-empty array of integers, return the k most frequent elements.

Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]

Example 2:

Input: nums = [1], k = 1
Output: [1]
Note:

You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Your algorithm&#39;s time complexity must be better than O(n log n), where n is the array&#39;s size.
It&#39;s guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique.
You can return the answer in any order.
</code></pre></div><p>Solution</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">topKFrequent</span>(self, nums: List[int], k: int) <span style="color:#f92672">-&gt;</span> List[int]:
        <span style="color:#66d9ef">return</span> [ i <span style="color:#66d9ef">for</span> i, cnt <span style="color:#f92672">in</span> Counter(nums)<span style="color:#f92672">.</span>most_common()[:k]]
</code></pre></div><h4 id="692-dot-top-k-frequent-words">692. Top K Frequent Words</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-empty list of words, return the k most frequent elements.

Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.

Example 1:
Input: [&#34;i&#34;, &#34;love&#34;, &#34;leetcode&#34;, &#34;i&#34;, &#34;love&#34;, &#34;coding&#34;], k = 2
Output: [&#34;i&#34;, &#34;love&#34;]
Explanation: &#34;i&#34; and &#34;love&#34; are the two most frequent words.
    Note that &#34;i&#34; comes before &#34;love&#34; due to a lower alphabetical order.
Example 2:
Input: [&#34;the&#34;, &#34;day&#34;, &#34;is&#34;, &#34;sunny&#34;, &#34;the&#34;, &#34;the&#34;, &#34;the&#34;, &#34;sunny&#34;, &#34;is&#34;, &#34;is&#34;], k = 4
Output: [&#34;the&#34;, &#34;is&#34;, &#34;sunny&#34;, &#34;day&#34;]
Explanation: &#34;the&#34;, &#34;is&#34;, &#34;sunny&#34; and &#34;day&#34; are the four most frequent words,
    with the number of occurrence being 4, 3, 2 and 1 respectively.
Note:
You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
Input words contain only lowercase letters.
Follow up:
Try to solve it in O(n log k) time and O(n) extra space.
</code></pre></div><p>Solution</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">topKFrequent</span>(self, words: List[str], k: int) <span style="color:#f92672">-&gt;</span> List[str]:
        counter <span style="color:#f92672">=</span> Counter(words)
        <span style="color:#66d9ef">return</span> heapq<span style="color:#f92672">.</span>nsmallest(k,
                               counter,
                               key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> word: (<span style="color:#f92672">-</span>counter[word], word))
</code></pre></div><h2 id="986-interval-list-intersections">986 - Interval List Intersections</h2>
<p><a href="https://leetcode.com/problems/interval-list-intersections/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.

Return the intersection of these two interval lists.

(Formally, a closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)

Example 1:

Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]
Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]
Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">intervalListIntersection</span>(self, A, B):
        ans <span style="color:#f92672">=</span> []
        i <span style="color:#f92672">=</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> len(A) <span style="color:#f92672">and</span> j <span style="color:#f92672">&lt;</span> len(B):
            left <span style="color:#f92672">=</span> max(A[i][<span style="color:#ae81ff">0</span>], B[j][<span style="color:#ae81ff">0</span>])
            right <span style="color:#f92672">=</span> min(A[i][<span style="color:#ae81ff">1</span>], B[j][<span style="color:#ae81ff">1</span>])
            <span style="color:#66d9ef">if</span> left <span style="color:#f92672">&lt;=</span> right:
                ans<span style="color:#f92672">.</span>append([left, right])
            <span style="color:#66d9ef">if</span> A[i][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> B[j][<span style="color:#ae81ff">1</span>]:
                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="1035-uncrossed-lines">1035 - Uncrossed Lines</h2>
<p><a href="https://leetcode.com/problems/uncrossed-lines/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">We write the integers of A and B (in the order they are given) on two separate horizontal lines.

Now, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j] such that:

A[i] == B[j];
The line we draw does not intersect any other connecting (non-horizontal) line.
Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.

Return the maximum number of connecting lines we can draw in this way.

Example 1:

Input: A = [1,4,2], B = [1,2,4]
Output: 2
Explanation: We can draw 2 uncrossed lines as in the diagram.
We cannot draw 3 uncrossed lines, because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.

Example 2:

Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2]
Output: 3

Example 3:

Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1]
Output: 2

Note:

1 &lt;= A.length &lt;= 500
1 &lt;= B.length &lt;= 500
1 &lt;= A[i], B[i] &lt;= 2000
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxUncrossedLines</span>(self, A, B):

        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (len(A)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(len(B)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(B)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(A)):
                <span style="color:#66d9ef">if</span> B[i] <span style="color:#f92672">==</span> A[j]:
                    dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], dp[i][j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
                <span style="color:#66d9ef">else</span>:
                    dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], dp[i][j])

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="886-possible-bipartition">886 - Possible Bipartition</h2>
<p><a href="https://leetcode.com/problems/possible-bipartition/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size.

Each person may dislike some other people, and they should not go into the same group.

Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group.

Return true if and only if it is possible to split everyone into two groups in this way.

Example 1:

Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]
Output: true
Explanation: group1 [1,4], group2 [2,3]

Example 2:

Input: N = 3, dislikes = [[1,2],[1,3],[2,3]]
Output: false

Example 3:

Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
Output: false


Note:

1. 1 &lt;= N &lt;= 2000
2. 0 &lt;= dislikes.length &lt;= 10000
3. 1 &lt;= dislikes[i][j] &lt;= N
4. dislikes[i][0] &lt; dislikes[i][1]
5. There does not exist i != j for which dislikes[i] == dislikes[j].
</code></pre></div><h3 id="solution">Solution</h3>
<p>Graph.</p>
<p>Every dislike is an edge in graph.</p>
<p>We color all vertice in two colors. Every adjacent vertice should have different colors.</p>
<p>Use DFS to color all vetices. If you can color all vertices without contradiction, then the graph has a bipartition.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">possibleBipartition</span>(self, N: int, dislikes):
        self<span style="color:#f92672">.</span>graph <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]
        self<span style="color:#f92672">.</span>marked <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">for</span> pair <span style="color:#f92672">in</span> dislikes:
            v, w <span style="color:#f92672">=</span> pair
            self<span style="color:#f92672">.</span>graph[v]<span style="color:#f92672">.</span>append(w)
            self<span style="color:#f92672">.</span>graph[w]<span style="color:#f92672">.</span>append(v)

        <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>marked[v] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>dfs(v, <span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">return</span> False
        <span style="color:#66d9ef">return</span> True

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, v, color):
        self<span style="color:#f92672">.</span>marked[v] <span style="color:#f92672">=</span> color
        <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>graph[v]:
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>marked[w] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>dfs(w, <span style="color:#f92672">-</span>color):
                <span style="color:#66d9ef">return</span> False
            <span style="color:#66d9ef">elif</span> self<span style="color:#f92672">.</span>marked[w] <span style="color:#f92672">==</span> color:
                <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">return</span> True
</code></pre></div><h2 id="207-course-schedule">207 - Course Schedule</h2>
<p><a href="https://leetcode.com/problems/course-schedule/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take.
             To take course 1 you should have finished course 0. So it is possible.

Example 2:

Input: numCourses = 2, prerequisites = [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take.
             To take course 1 you should have finished course 0, and to take course 0 you should
             also have finished course 1. So it is impossible.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-dag-with-dfs">Solution 1: DAG with DFS</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canFinish</span>(self, numCourses, prerequisites):
        self<span style="color:#f92672">.</span>hasCycle <span style="color:#f92672">=</span> False
        self<span style="color:#f92672">.</span>adj <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(numCourses)]
        self<span style="color:#f92672">.</span>marked <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> numCourses
        self<span style="color:#f92672">.</span>stack <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> numCourses

        <span style="color:#66d9ef">for</span> pre <span style="color:#f92672">in</span> prerequisite:
            v, w <span style="color:#f92672">=</span> pre
            adj[v]<span style="color:#f92672">.</span>append(w)

        <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> range(numCourses):
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>marked[v]:
                self<span style="color:#f92672">.</span>dfs(v)

        <span style="color:#66d9ef">return</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>hasCycle

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, v):
        self<span style="color:#f92672">.</span>marked[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        self<span style="color:#f92672">.</span>stack[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>adj[v]:
            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>hasCycle:
                <span style="color:#66d9ef">return</span>
            <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>marked[w]:
                self<span style="color:#f92672">.</span>dfs(w)
            <span style="color:#66d9ef">elif</span> self<span style="color:#f92672">.</span>stack[w]:
                self<span style="color:#f92672">.</span>hasCycle <span style="color:#f92672">=</span> True
</code></pre></div><h4 id="solution-2-topological-sort">Solution 2: Topological Sort</h4>
<p>If a graph has a topological sort order, there is no cycle.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canFinish</span>(self, numCourses, prerequisites):
        adj <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(numCourses)]
        degree <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> numCourses

        <span style="color:#66d9ef">for</span> pre <span style="color:#f92672">in</span> prerequisites:
            v, w <span style="color:#f92672">=</span> pre
            adj[w]<span style="color:#f92672">.</span>append(v)
            degree[v] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        q <span style="color:#f92672">=</span> [v <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> range(numCourses) <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> degree[v]]
        order <span style="color:#f92672">=</span> []

        <span style="color:#66d9ef">while</span> q:
            v <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>)
            order<span style="color:#f92672">.</span>append(v)
            <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> adj[v]:
                degree[w] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> degree[w]:
                    q<span style="color:#f92672">.</span>append(w)

        <span style="color:#66d9ef">return</span> len(order) <span style="color:#f92672">==</span> numCourses
</code></pre></div><h2 id="210-course-schedule-ii">210 - Course Schedule II</h2>
<p><a href="https://leetcode.com/problems/course-schedule-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">There are a total of n courses you have to take, labeled from 0 to n-1.

Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]

Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.

There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

Example 1:

Input: 2, [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished
             course 0. So the correct course order is [0,1] .
Example 2:

Input: 4, [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3] or [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both
             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .
</code></pre></div><h3 id="solution">Solution</h3>
<p>Topological sort.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canFinish</span>(self, numCourses, prerequisites):
        adj <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(numCourses)]
        degree <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> numCourses

        <span style="color:#66d9ef">for</span> pre <span style="color:#f92672">in</span> prerequisites:
            v, w <span style="color:#f92672">=</span> pre
            adj[w]<span style="color:#f92672">.</span>append(v)
            degree[v] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        q <span style="color:#f92672">=</span> [v <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> range(numCourses) <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> degree[v]]
        order <span style="color:#f92672">=</span> []

        <span style="color:#66d9ef">while</span> q:
            v <span style="color:#f92672">=</span> q<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>)
            order<span style="color:#f92672">.</span>append(v)
            <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> adj[v]:
                degree[w] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> degree[w]:
                    q<span style="color:#f92672">.</span>append(w)

        <span style="color:#66d9ef">return</span> len(order) <span style="color:#f92672">==</span> numCourses
</code></pre></div><h2 id="973-k-closest-points-to-origin">973 - K Closest Points to Origin</h2>
<p><a href="https://leetcode.com/problems/k-closest-points-to-origin/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">We have a list of points on the plane.  Find the K closest points to the origin (0, 0).

(Here, the distance between two points on a plane is the Euclidean distance.)

You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)

Example 1:

Input: points = [[1,3],[-2,2]], K = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.
We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].

Example 2:

Input: points = [[3,3],[5,-1],[-2,4]], K = 2
Output: [[3,3],[-2,4]]
(The answer [[-2,4],[3,3]] would also be accepted.)
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-sort">Solution 1: sort</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kClosest</span>(self, points, K: int):
        <span style="color:#66d9ef">return</span> sorted(points, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> p: p[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> p[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>)[:K]
</code></pre></div><h4 id="solution-2-heap">Solution 2: heap</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kClosest</span>(self, points, K):
        <span style="color:#66d9ef">return</span> heapq<span style="color:#f92672">.</span>nsmallest(K, points, <span style="color:#66d9ef">lambda</span> (x, y): x <span style="color:#f92672">*</span> x <span style="color:#f92672">+</span> y <span style="color:#f92672">*</span> y)
</code></pre></div><h2 id="72-edit-distance">72 - Edit Distance</h2>
<p><a href="https://leetcode.com/problems/edit-distance/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character

Example 1:

Input: word1 = &#34;horse&#34;, word2 = &#34;ros&#34;
Output: 3

Explanation:
horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)
rorse -&gt; rose (remove &#39;r&#39;)
rose -&gt; ros (remove &#39;e&#39;)

Example 2:

Input: word1 = &#34;intention&#34;, word2 = &#34;execution&#34;
Output: 5

Explanation:
intention -&gt; inention (remove &#39;t&#39;)
inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)
enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)
exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)
exection -&gt; execution (insert &#39;u&#39;)
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minDistance</span>(self, word1: str, word2: str) <span style="color:#f92672">-&gt;</span> int:
        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>len(word2)) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>len(word1))]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>len(word1)):
            dp[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> i
        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>len(word2)):
            dp[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> j

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>len(word1)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>len(word2)):
                <span style="color:#66d9ef">if</span> word1[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> word2[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                    dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#66d9ef">else</span>:
                    dp[i][j] <span style="color:#f92672">=</span> min(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="226-invert-binary-tree">226 - Invert Binary Tree</h2>
<p><a href="https://leetcode.com/problems/invert-binary-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Invert a binary tree.

Example:

Input:

     4
   /   \
  2     7
 / \   / \
1   3 6   9
Output:

     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">invertTree</span>(self):
        <span style="color:#66d9ef">if</span> root:
            tmp <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left
            root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>invertTree(root<span style="color:#f92672">.</span>right)
            root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>invertTree(tmp)
        <span style="color:#66d9ef">return</span> root
</code></pre></div><h2 id="746-min-cost-climbing-stairs">746 - Min Cost Climbing Stairs</h2>
<p><a href="https://leetcode.com/problems/min-cost-climbing-stairs/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).

Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.

Example 1:
Input: cost = [10, 15, 20]
Output: 15
Explanation: Cheapest is start on cost[1], pay that cost and go to the top.

Example 2:
Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
Output: 6
Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3].

Note:
cost will have a length in the range [2, 1000].
Every cost[i] will be an integer in the range [0, 999].
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minCostClimbingStairs</span>(self, cost: List[int]) <span style="color:#f92672">-&gt;</span> int:
        dp <span style="color:#f92672">=</span> [float(<span style="color:#e6db74">&#39;inf&#39;</span>)] <span style="color:#f92672">*</span> len(cost)
        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>, len(cost)):
            dp[i] <span style="color:#f92672">=</span> min(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>cost[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span>cost[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>])
        <span style="color:#66d9ef">return</span> min(dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>cost[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span>cost[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>])
</code></pre></div><h2 id="237-delete-node-in-a-linked-list">237 - Delete Node in a Linked List</h2>
<p><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Given linked list -- head = [4,5,1,9], which looks like following:

Example 1:

Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.

Example 2:

Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">deleteNode</span>(self, node):
        node<span style="color:#f92672">.</span>val <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>val
        node<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next
</code></pre></div><h2 id="1029-two-city-scheduling">1029 - Two City Scheduling</h2>
<p><a href="https://leetcode.com/problems/two-city-scheduling/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1].

Return the minimum cost to fly every person to a city such that exactly N people arrive in each city.

Example 1:

Input: [[10,20],[30,200],[400,50],[30,20]]
Output: 110
Explanation:
The first person goes to city A for a cost of 10.
The second person goes to city A for a cost of 30.
The third person goes to city B for a cost of 50.
The fourth person goes to city B for a cost of 20.

The total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.

Note:

1 &lt;= costs.length &lt;= 100
It is guaranteed that costs.length is even.
1 &lt;= costs[i][0], costs[i][1] &lt;= 1000
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-dp">Solution 1: DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">twoCitySchedCost</span>(self, costs: List[List[int]]) <span style="color:#f92672">-&gt;</span> int:
        N <span style="color:#f92672">=</span> len(costs) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>

        dp <span style="color:#f92672">=</span> [[[float(<span style="color:#e6db74">&#39;inf&#39;</span>)] <span style="color:#f92672">*</span> (N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>), [float(<span style="color:#e6db74">&#39;inf&#39;</span>)] <span style="color:#f92672">*</span> (N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]
              <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]

        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">-</span> k <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> i <span style="color:#f92672">-</span> k <span style="color:#f92672">&lt;=</span> N:
                    dp[i][<span style="color:#ae81ff">0</span>][k] <span style="color:#f92672">=</span> min(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>][k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>],
                                      dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>][i <span style="color:#f92672">-</span> k]) <span style="color:#f92672">+</span> costs[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]
                    dp[i][<span style="color:#ae81ff">1</span>][k] <span style="color:#f92672">=</span> min(dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>][k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>],
                                      dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>][i <span style="color:#f92672">-</span> k]) <span style="color:#f92672">+</span> costs[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>]

        <span style="color:#66d9ef">return</span> min(dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</code></pre></div><h4 id="solution-2-sort">Solution 2: sort</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">twoCitySchedCost</span>(self, costs):
        sortedCosts <span style="color:#f92672">=</span> sorted(costs, key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> cost: cost[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> cost[<span style="color:#ae81ff">1</span>])

        minCost <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        N <span style="color:#f92672">=</span> len(costs)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>):
            minCost <span style="color:#f92672">+=</span> sortedCosts[i][<span style="color:#ae81ff">0</span>]
            minCost <span style="color:#f92672">+=</span> sortedCosts[N<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>i][<span style="color:#ae81ff">1</span>]

        <span style="color:#66d9ef">return</span> minCost
</code></pre></div><h2 id="528-random-pick-with-weight">528 - Random Pick with Weight</h2>
<p><a href="https://leetcode.com/problems/random-pick-with-weight/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight.

Note:

1 &lt;= w.length &lt;= 10000
1 &lt;= w[i] &lt;= 10^5
pickIndex will be called at most 10000 times.

Example 1:

Input:
[&#34;Solution&#34;,&#34;pickIndex&#34;]
[[[1]],[]]
Output: [null,0]

Example 2:

Input:
[&#34;Solution&#34;,&#34;pickIndex&#34;,&#34;pickIndex&#34;,&#34;pickIndex&#34;,&#34;pickIndex&#34;,&#34;pickIndex&#34;]
[[[1,3]],[],[],[],[],[]]
Output: [null,0,1,1,1,0]
Explanation of Input Syntax:

The input is two lists: the subroutines called and their arguments. Solution&#39;s constructor has one argument, the array w. pickIndex has no arguments. Arguments are always wrapped with a list, even if there aren&#39;t any.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> __init__(self, w):
        self<span style="color:#f92672">.</span>w <span style="color:#f92672">=</span> list(itertools<span style="color:#f92672">.</span>accumulate(w))

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pickIndex</span>(self):
        <span style="color:#66d9ef">return</span> bisect<span style="color:#f92672">.</span>bisect_left(self<span style="color:#f92672">.</span>w, random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">1</span>, self<span style="color:#f92672">.</span>w[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]))
</code></pre></div><h2 id="518-coin-change-2">518 - Coin Change 2</h2>
<p><a href="https://leetcode.com/problems/coin-change-2/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.

Example 1:

Input: amount = 5, coins = [1, 2, 5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

Example 2:

Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.

Example 3:

Input: amount = 10, coins = [10]
Output: 1

Note:

You can assume that

0 &lt;= amount &lt;= 5000
1 &lt;= coin &lt;= 5000
the number of coins is less than 500
the answer is guaranteed to fit into signed 32-bit integer
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">change</span>(self, amount: int, coins: List[int]) <span style="color:#f92672">-&gt;</span> int:
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (amount <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> coins:
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i, amount <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
                dp[j] <span style="color:#f92672">+=</span> dp[j <span style="color:#f92672">-</span> i]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="231-power-of-two">231 - Power of Two</h2>
<p><a href="https://leetcode.com/problems/power-of-two/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an integer, write a function to determine if it is a power of two.

Example 1:

Input: 1
Output: true
Explanation: 20 = 1

Example 2:

Input: 16
Output: true
Explanation: 24 = 16

Example 3:

Input: 218
Output: false
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-straight-forward">Solution 1: Straight forward</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">powerOfTwo</span>(self, n):
        <span style="color:#66d9ef">while</span> n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">if</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>:
                <span style="color:#66d9ef">return</span> False
            n <span style="color:#f92672">//=</span> <span style="color:#ae81ff">2</span>

        <span style="color:#66d9ef">return</span> True
</code></pre></div><h4 id="solution-2-bit-manipulation">Solution 2: Bit manipulation</h4>
<p>power of two:
n     = 1000000
n - 1 = 111111
n &amp; (n-1) == 0</p>
<p>Note: n can not be 0</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">powerOfTwo</span>(self, n):
        <span style="color:#66d9ef">return</span> n <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> (n <span style="color:#f92672">&amp;</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</code></pre></div><h2 id="406-queue-reconstruction-by-height">406 - Queue Reconstruction by Height</h2>
<p><a href="https://leetcode.com/problems/queue-reconstruction-by-height/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue.

Note:
The number of people is less than 1,100.

Example

Input:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

Output:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>(self, people):
        people<span style="color:#f92672">.</span>sort(key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> p: (<span style="color:#f92672">-</span>p[<span style="color:#ae81ff">0</span>], p[<span style="color:#ae81ff">1</span>]))
        ans <span style="color:#f92672">=</span> []

        <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> people:
            ans<span style="color:#f92672">.</span>insert(p[<span style="color:#ae81ff">1</span>], p)
</code></pre></div><h2 id="213-house-robber-ii">213 - House Robber II</h2>
<p><a href="https://leetcode.com/problems/house-robber-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
Example 2:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Two loops of dp:</p>
<ol>
<li>consider the array from 0 to n - 2</li>
<li>consider the array from 1 to n - 1</li>
<li>return the max value from this two loops</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rob</span>(self, nums):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> nums[<span style="color:#ae81ff">0</span>]

        rob <span style="color:#f92672">=</span> nrob <span style="color:#f92672">=</span> rob2 <span style="color:#f92672">=</span> nrob2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)):
            rob, nrob <span style="color:#f92672">=</span> nrob <span style="color:#f92672">+</span> nums[n], max(rob, nrob)
            rob2, nrob2 <span style="color:#f92672">=</span> nrob2 <span style="color:#f92672">+</span> nums[n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>], max(rob2, nrob2)

        <span style="color:#66d9ef">return</span> max(rob, nrob, rob2, nrob2)
</code></pre></div><h2 id="38-count-and-say">38 - Count and Say</h2>
<p><a href="https://leetcode.com/problems/count-and-say/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 is read off as &#34;one 1&#34; or 11.
11 is read off as &#34;two 1s&#34; or 21.
21 is read off as &#34;one 2, then one 1&#34; or 1211.

Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence. You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.

Note: Each term of the sequence of integers will be represented as a string.



Example 1:

Input: 1
Output: &#34;1&#34;
Explanation: This is the base case.
Example 2:

Input: 4
Output: &#34;1211&#34;
Explanation: For n = 3 the term was &#34;21&#34; in which we have two groups &#34;2&#34; and &#34;1&#34;, &#34;2&#34; can be read as &#34;12&#34; which means frequency = 1 and value = 2, the same way &#34;1&#34; is read as &#34;11&#34;, so the answer is the concatenation of &#34;12&#34; and &#34;11&#34; which is &#34;1211&#34;.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countAndSay</span>(self, n: int) <span style="color:#f92672">-&gt;</span> str:
        s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1&#34;</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            say <span style="color:#f92672">=</span> s[<span style="color:#ae81ff">0</span>]
            count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
            tmp <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
            <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s:
                <span style="color:#66d9ef">if</span> c <span style="color:#f92672">==</span> say:
                    count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    tmp <span style="color:#f92672">=</span> tmp <span style="color:#f92672">+</span> str(count) <span style="color:#f92672">+</span> say
                    say <span style="color:#f92672">=</span> c
                    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            s <span style="color:#f92672">=</span> tmp <span style="color:#f92672">+</span> str(count) <span style="color:#f92672">+</span> say
        <span style="color:#66d9ef">return</span> s
</code></pre></div><h2 id="66-plus-one">66 - Plus One</h2>
<p><a href="https://leetcode.com/problems/plus-one/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-empty array of digits representing a non-negative integer, plus one to the integer.

The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.

You may assume the integer does not contain any leading zero, except the number 0 itself.

Example 1:

Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Example 2:

Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">plusOne</span>(self, digits):
        add <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(digits) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            digits[i], add <span style="color:#f92672">=</span> (digits[i] <span style="color:#f92672">+</span> add) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>, (digits[i] <span style="color:#f92672">+</span> add)<span style="color:#f92672">//</span><span style="color:#ae81ff">10</span>

        <span style="color:#66d9ef">if</span> add:
            digits<span style="color:#f92672">.</span>insert(<span style="color:#ae81ff">0</span>, add)

        <span style="color:#66d9ef">return</span> digits
</code></pre></div><h2 id="392-is-subsequence">392 - Is Subsequence</h2>
<p><a href="https://leetcode.com/problems/is-subsequence/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string s and a string t, check if s is subsequence of t.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &#34;ace&#34; is a subsequence of &#34;abcde&#34; while &#34;aec&#34; is not).

Follow up:
If there are lots of incoming S, say S1, S2, ... , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?

Credits:
Special thanks to @pbrother for adding this problem and creating all test cases.



Example 1:

Input: s = &#34;abc&#34;, t = &#34;ahbgdc&#34;
Output: true
Example 2:

Input: s = &#34;axc&#34;, t = &#34;ahbgdc&#34;
Output: false
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isSubsequence</span>(self, s: str, t: str) <span style="color:#f92672">-&gt;</span> bool:
        i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> t:
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> len(s) <span style="color:#f92672">and</span> c <span style="color:#f92672">==</span> s[i]:
                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> i <span style="color:#f92672">==</span> len(s)
</code></pre></div><h2 id="40-combination-sum-ii">40 - Combination Sum II</h2>
<p><a href="https://leetcode.com/problems/combination-sum-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
</code></pre></div><h3 id="solution">Solution</h3>
<p>Backtracking problem.</p>
<p>Use DFS.</p>
<ol>
<li>make a choice</li>
<li>call dfs recursive for all rest choices</li>
<li>revert the choice</li>
</ol>
<p>Notes:</p>
<ol>
<li>sort the candidates and avoid the duplicates</li>
<li>return early when the target is smaller than 0</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum</span>(self, candidates, target):
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> []
        candidates<span style="color:#f92672">.</span>sort()
        self<span style="color:#f92672">.</span>dfs(candidates, <span style="color:#ae81ff">0</span>, [], target)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, candidates, index, path, target):
        <span style="color:#66d9ef">if</span> target <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">if</span> target <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            self<span style="color:#f92672">.</span>ans<span style="color:#f92672">.</span>append(list(path))

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index, len(candidates)):
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;</span> index <span style="color:#f92672">and</span> candidates[i] <span style="color:#f92672">==</span> candidates[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                <span style="color:#66d9ef">continue</span>
            path<span style="color:#f92672">.</span>append(candidates[i])
            self<span style="color:#f92672">.</span>dfs(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, candidates, path, target<span style="color:#f92672">-</span>candidates[i])
            path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="39-combination-sum">39 - Combination Sum</h2>
<p><a href="https://leetcode.com/problems/combination-sum/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a set of candidate numbers (candidates) (without duplicates) and a target number (target),
find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.

Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]

Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</code></pre></div><h3 id="solution">Solution</h3>
<p>Backtracking problem.</p>
<p>See <a href="http://alfmunny.com/leetcode-blog/posts/40-combination-sum-ii/">Problem 40</a>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum</span>(self, candidates, target):
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(sorted(candidates), <span style="color:#ae81ff">0</span>, [], target)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, candidates, index, path, target):
        <span style="color:#66d9ef">if</span> target <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            self<span style="color:#f92672">.</span>ans<span style="color:#f92672">.</span>append(list(path))

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index, len(candidates)):
            v <span style="color:#f92672">=</span> candidates[i]
            <span style="color:#66d9ef">if</span> v <span style="color:#f92672">&gt;</span> target:
                <span style="color:#66d9ef">return</span>
            path<span style="color:#f92672">.</span>append(v)
            self<span style="color:#f92672">.</span>dfs(candidates, i, path, target<span style="color:#f92672">-</span>v)
            path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="377-combination-sum-iv">377 - Combination Sum IV</h2>
<p><a href="https://leetcode.com/problems/combination-sum-iv/submissions/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

Example:

nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
</code></pre></div><h3 id="solution">Solution</h3>
<p>It develops from DFS and then optimize it to DP problem</p>
<p>Consider you always choose a num as the leading number in the combination sequence.</p>
<p>Then for a target, the current combination would be:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">for i in nums:
  dp[target] += dp[target - i]
</code></pre></div><p>Note here that we should have dp[target - i] already calculdated beforehand.
So we need to do it from bottom-up. And the base case would be dp[0] = 1, because when i == target, we want dp[target - i] = 1 at first, it means we find the combination.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">dp[0] = 1
for t in range(target+1):
  for i in nums:
    dp[target] += dp[target - i]
</code></pre></div><h4 id="solution-1-dfs">Solution 1: DFS</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum4</span>(self, nums, target):
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        self<span style="color:#f92672">.</span>dfs(nums, target)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, nums, target):
        <span style="color:#66d9ef">if</span> target <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">if</span> target <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
            self<span style="color:#f92672">.</span>dfs(nums, target <span style="color:#f92672">-</span> i)
</code></pre></div><p>It exceeds time limit.</p>
<h4 id="solution-2-dfs-with-memo">Solution 2: DFS with memo</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum4</span>(self, nums, target):
        memo <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (target<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
        self<span style="color:#f92672">.</span>dfs(nums, target, memo)
        <span style="color:#66d9ef">return</span> memo[target]

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, nums, target, memo):
        <span style="color:#66d9ef">if</span> target <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">if</span> memo[target]:
            <span style="color:#66d9ef">return</span> memo[target]

        <span style="color:#66d9ef">if</span> target <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>

        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
            ans <span style="color:#f92672">+=</span> self<span style="color:#f92672">.</span>dfs(nums, target <span style="color:#f92672">-</span> i, memo)

        memo[target] <span style="color:#f92672">=</span> ans

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><p>It still exceeds time limit.</p>
<h4 id="solution-3-dp">Solution 3: DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum4</span>(self, nums, target):
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (target <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(target<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> nums:
                <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> j:
                    <span style="color:#66d9ef">continue</span>
                dp[i] <span style="color:#f92672">+=</span> dp[i<span style="color:#f92672">-</span>j]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="216-combination-sum-iii">216 - Combination Sum III</h2>
<p><a href="https://leetcode.com/problems/combination-sum-iv/submissions/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.

Note:

All numbers will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: k = 3, n = 7
Output: [[1,2,4]]
Example 2:

Input: k = 3, n = 9
Output: [[1,2,6], [1,3,5], [2,3,4]]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum3</span>(self, k: int, n: int) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(<span style="color:#ae81ff">1</span>, [], ans, k, n)
        <span style="color:#66d9ef">return</span> ans


    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, index, path, ans, k, n):
        <span style="color:#66d9ef">if</span> k <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            ans<span style="color:#f92672">.</span>append(list(path))
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index, <span style="color:#ae81ff">10</span>):
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;</span> n:
                <span style="color:#66d9ef">return</span>
            path<span style="color:#f92672">.</span>append(i)
            self<span style="color:#f92672">.</span>dfs(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, path, ans, k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, n<span style="color:#f92672">-</span>i)
            path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="47-permutations-ii">47 - Permutations II</h2>
<p><a href="https://leetcode.com/problems/permutations-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre></div><h3 id="solution">Solution</h3>
<p>The tricky part is how to avoid duplicates.</p>
<p>First sort the array.</p>
<p>When chose the next element, if it is the same as the previous one and the previous one is now not choosen, we should skip it, because it means the previous one has been already choosen for this position before.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">if i &gt; 0 and nums[i] == nums[i-1] and not marked[i-1]:
  continue
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">permuteUnique</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        marked <span style="color:#f92672">=</span> [False] <span style="color:#f92672">*</span> len(nums)
        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(sorted(nums), marked, [], ans)
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, nums, marked, path, ans):
        <span style="color:#66d9ef">if</span> len(path) <span style="color:#f92672">==</span> len(nums):
            ans<span style="color:#f92672">.</span>append(list(path))
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums)):
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> nums[i] <span style="color:#f92672">==</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> marked[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                <span style="color:#66d9ef">continue</span>
            <span style="color:#66d9ef">if</span> marked[i]:
                <span style="color:#66d9ef">continue</span>
            marked[i] <span style="color:#f92672">=</span> True
            path<span style="color:#f92672">.</span>append(nums[i])
            self<span style="color:#f92672">.</span>dfs(nums, marked, path, ans)
            marked[i] <span style="color:#f92672">=</span> False
            path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="51-n-queens">51 - N-Queens</h2>
<p><a href="https://leetcode.com/problems/n-queens/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.

Given an integer n, return all distinct solutions to the n-queens puzzle.

Each solution contains a distinct board configuration of the n-queens&#39; placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solveNQueens</span>(self, n):
        ans <span style="color:#f92672">=</span> []

        self<span style="color:#f92672">.</span>dfs(<span style="color:#ae81ff">0</span>, n, [], ans)
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, row, n, path, ans):
        <span style="color:#66d9ef">if</span> row <span style="color:#f92672">==</span> n <span style="color:#f92672">and</span> len(path) <span style="color:#f92672">==</span> n:
            ans<span style="color:#f92672">.</span>append(self<span style="color:#f92672">.</span>draw(path, n))
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>attack(path, row, i):
                <span style="color:#66d9ef">continue</span>
            path<span style="color:#f92672">.</span>append([row, i])
            self<span style="color:#f92672">.</span>dfs(row<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, n, path, ans)
            path<span style="color:#f92672">.</span>pop()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">attack</span>(self, path, row, i):
        <span style="color:#66d9ef">for</span> pair <span style="color:#f92672">in</span> path:
            <span style="color:#66d9ef">if</span> pair[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> i:
                <span style="color:#66d9ef">return</span> True
            <span style="color:#66d9ef">elif</span> abs(row <span style="color:#f92672">-</span> pair[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">==</span> abs(i <span style="color:#f92672">-</span> pair[<span style="color:#ae81ff">1</span>]):
                <span style="color:#66d9ef">return</span> True
        <span style="color:#66d9ef">return</span> False

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">draw</span>(self, path, n):
        ans <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> pair <span style="color:#f92672">in</span> path:
            ans<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">*</span> pair[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;Q&#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">*</span> (n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>pair[<span style="color:#ae81ff">1</span>]))

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="52-n-queens-ii">52 - N-Queens II</h2>
<p><a href="https://leetcode.com/problems/n-queens-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.

Given an integer n, return the number of distinct solutions to the n-queens puzzle.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">totalNQueens</span>(self, n):
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        self<span style="color:#f92672">.</span>dfs(<span style="color:#ae81ff">0</span>, n, [])
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, row, n, path):
        <span style="color:#66d9ef">if</span> row <span style="color:#f92672">==</span> n <span style="color:#f92672">and</span> len(path) <span style="color:#f92672">==</span> n:
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>attack(path, row, i):
                <span style="color:#66d9ef">continue</span>
            path<span style="color:#f92672">.</span>append([row, i])
            self<span style="color:#f92672">.</span>dfs(row<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, n, path)
            path<span style="color:#f92672">.</span>pop()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">attack</span>(self, path, row, i):
        <span style="color:#66d9ef">for</span> pair <span style="color:#f92672">in</span> path:
            <span style="color:#66d9ef">if</span> pair[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> i:
                <span style="color:#66d9ef">return</span> True
            <span style="color:#66d9ef">elif</span> abs(row <span style="color:#f92672">-</span> pair[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">==</span> abs(i <span style="color:#f92672">-</span> pair[<span style="color:#ae81ff">1</span>]):
                <span style="color:#66d9ef">return</span> True
        <span style="color:#66d9ef">return</span> False
</code></pre></div><h2 id="77-combinations">77 - Combinations</h2>
<p><a href="https://leetcode.com/problems/combination-sum-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Share
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

Example:

Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combine</span>(self, n: int, k: int) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(<span style="color:#ae81ff">1</span>, n, k, [], ans)
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, index, n, k, path, ans):
        <span style="color:#66d9ef">if</span> k <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            ans<span style="color:#f92672">.</span>append(list(path))
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            path<span style="color:#f92672">.</span>append(i)
            self<span style="color:#f92672">.</span>dfs(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, n, k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, path, ans)
            path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="90-subsets-ii">90 - Subsets II</h2>
<p><a href="https://leetcode.com/problems/subsets-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">subsetsWithDup</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        ans <span style="color:#f92672">=</span> []
        marked <span style="color:#f92672">=</span> [False] <span style="color:#f92672">*</span> len(nums)

        self<span style="color:#f92672">.</span>dfs(sorted(nums), <span style="color:#ae81ff">0</span>, [], ans, marked)

        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, nums, index, path, ans, marked):
        ans<span style="color:#f92672">.</span>append(list(path))
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index, len(nums)):
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> nums[i] <span style="color:#f92672">==</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> marked[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                <span style="color:#66d9ef">continue</span>

            marked[i] <span style="color:#f92672">=</span> True
            path<span style="color:#f92672">.</span>append(nums[i])
            self<span style="color:#f92672">.</span>dfs(nums, i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, path, ans, marked)
            path<span style="color:#f92672">.</span>pop()
            marked[i] <span style="color:#f92672">=</span> False
</code></pre></div><h2 id="100-same-tree">100 - Same Tree</h2>
<p><a href="https://leetcode.com/problems/same-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given two binary trees, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

Example 1:

Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
Example 2:

Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
Example 3:

Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isSameTree</span>(self, p: TreeNode, q: TreeNode) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">if</span> p <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> q:
            <span style="color:#66d9ef">return</span> False
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> p <span style="color:#f92672">and</span> q:
            <span style="color:#66d9ef">return</span> False
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> p <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> q:
            <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">if</span> p<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> q<span style="color:#f92672">.</span>val:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>isSameTree(p<span style="color:#f92672">.</span>left, q<span style="color:#f92672">.</span>left) <span style="color:#f92672">and</span> self<span style="color:#f92672">.</span>isSameTree(p<span style="color:#f92672">.</span>right, q<span style="color:#f92672">.</span>right)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> False
</code></pre></div><h2 id="112-path-sum">112 - Path Sum</h2>
<p><a href="https://leetcode.com/problems/path-sum/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Definition for a binary tree node.</span>
<span style="color:#75715e"># class TreeNode:</span>
<span style="color:#75715e">#     def __init__(self, val=0, left=None, right=None):</span>
<span style="color:#75715e">#         self.val = val</span>
<span style="color:#75715e">#         self.left = left</span>
<span style="color:#75715e">#         self.right = right</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hasPathSum</span>(self, root: TreeNode, sum: int) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">if</span> sum <span style="color:#f92672">-</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left:
            <span style="color:#66d9ef">return</span> True
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>hasPathSum(root<span style="color:#f92672">.</span>left, sum <span style="color:#f92672">-</span> root<span style="color:#f92672">.</span>val) <span style="color:#f92672">or</span> self<span style="color:#f92672">.</span>hasPathSum(root<span style="color:#f92672">.</span>right, sum<span style="color:#f92672">-</span>root<span style="color:#f92672">.</span>val)
</code></pre></div><h2 id="113-path-sum-ii">113 - Path Sum II</h2>
<p><a href="https://leetcode.com/problems/path-sum-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree and a sum, find all root-to-leaf paths where each path&#39;s sum equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">pathSum</span>(self, root: TreeNode, sum: int) <span style="color:#f92672">-&gt;</span> List[List[int]]:

        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(root, sum, [], ans)
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, root, sum, path, ans):

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span>

        path<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>val)
        <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> sum <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left:
            ans<span style="color:#f92672">.</span>append(list(path))
        self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>left, sum <span style="color:#f92672">-</span> root<span style="color:#f92672">.</span>val, path, ans)
        self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>right, sum <span style="color:#f92672">-</span> root<span style="color:#f92672">.</span>val, path, ans)
        path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="118-pascal-s-triangle">118 - Pascal&rsquo;s Triangle</h2>
<p><a href="https://leetcode.com/problems/pascals-triangle/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-negative integer numRows, generate the first numRows of Pascal&#39;s triangle.

Example:

Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate</span>(self, numRows: int) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        ans <span style="color:#f92672">=</span> []

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, numRows<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            level <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> i

            <span style="color:#66d9ef">if</span> ans:
                <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
                    level[j] <span style="color:#f92672">=</span> ans[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> ans[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]

            ans<span style="color:#f92672">.</span>append(level)

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="54-spiral-matrix">54 - Spiral Matrix</h2>
<p><a href="https://leetcode.com/problems/spiral-matrix/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example 1:

Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
Example 2:

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
</code></pre></div><h3 id="solution">Solution</h3>
<p>Clockwise turn with help of step and direction array</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">step = [[0, 1], [1, 0], [0, -1], [-1, 0]]
di = 0

i, i = i + step[di][0], j + step[di][1]

Clockwise Turn:

di = (di + 1) % 4
i, j = i+step[di][0], j + step[di][1]
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">spiralOrder</span>(self, matrix: List[List[int]]) <span style="color:#f92672">-&gt;</span> List[int]:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix:
            <span style="color:#66d9ef">return</span> []
        i <span style="color:#f92672">=</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        m <span style="color:#f92672">=</span> len(matrix)
        n <span style="color:#f92672">=</span> len(matrix[<span style="color:#ae81ff">0</span>])
        marked <span style="color:#f92672">=</span> [[False] <span style="color:#f92672">*</span> n <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> matrix]
        step <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]]
        i <span style="color:#f92672">=</span> j <span style="color:#f92672">=</span> di <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        ans <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(m<span style="color:#f92672">*</span>n):
            ans<span style="color:#f92672">.</span>append(matrix[i][j])
            marked[i][j] <span style="color:#f92672">=</span> True
            ni, nj <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> step[di][<span style="color:#ae81ff">0</span>], j <span style="color:#f92672">+</span> step[di][<span style="color:#ae81ff">1</span>]

            <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> ni <span style="color:#f92672">&lt;</span> m <span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> nj <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> marked[ni][nj]:
                i, j <span style="color:#f92672">=</span> ni, nj
            <span style="color:#66d9ef">else</span>:
                di <span style="color:#f92672">=</span> (di <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>
                i, j <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span>step[di][<span style="color:#ae81ff">0</span>], j <span style="color:#f92672">+</span> step[di][<span style="color:#ae81ff">1</span>]

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="58-length-of-last-word">58 - Length of Last Word</h2>
<p><a href="https://leetcode.com/problems/length-of-last-word/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string s consists of upper/lower-case alphabets and empty space characters &#39; &#39;, return the length of last word (last word means the last appearing word if we loop from left to right) in the string.

If the last word does not exist, return 0.

Note: A word is defined as a maximal substring consisting of non-space characters only.

Example:

Input: &#34;Hello World&#34;
Output: 5
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lengthOfLastWord</span>(self, s: str) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> s<span style="color:#f92672">.</span>split():
            <span style="color:#66d9ef">return</span> len(s<span style="color:#f92672">.</span>split()[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h2 id="59-spiral-matrix-ii">59 - Spiral Matrix II</h2>
<p><a href="https://leetcode.com/problems/spiral-matrix-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

Example:

Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generateMatrix</span>(self, n: int) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        matrix <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
        step <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]]
        i <span style="color:#f92672">=</span> j <span style="color:#f92672">=</span> di <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">*</span> n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            matrix[i][j] <span style="color:#f92672">=</span> x

            ni <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> step[di][<span style="color:#ae81ff">0</span>]
            nj <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> step[di][<span style="color:#ae81ff">1</span>]

            <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> ni <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">and</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> nj <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> matrix[ni][nj]:
                i, j <span style="color:#f92672">=</span> ni, nj
            <span style="color:#66d9ef">else</span>:
                di <span style="color:#f92672">=</span> (di <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">4</span>
                i, j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> step[di][<span style="color:#ae81ff">0</span>], j <span style="color:#f92672">+</span> step[di][<span style="color:#ae81ff">1</span>]

        <span style="color:#66d9ef">return</span> matrix
</code></pre></div><h2 id="61-rotate-list">61 - Rotate List</h2>
<p><a href="https://leetcode.com/problems/rotate-list/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a linked list, rotate the list to the right by k places, where k is non-negative.

Example 1:

Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
Explanation:
rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL

Example 2:

Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4
Output: 2-&gt;0-&gt;1-&gt;NULL
Explanation:
rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL
rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL
rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL
rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL
</code></pre></div><h3 id="solution">Solution</h3>
<p>Note: k may be larger than the total count of nodes. We sould preprocess k first</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Definition for singly-linked list.</span>
<span style="color:#75715e"># class ListNode:</span>
<span style="color:#75715e">#     def __init__(self, val=0, next=None):</span>
<span style="color:#75715e">#         self.val = val</span>
<span style="color:#75715e">#         self.next = next</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rotateRight</span>(self, head: ListNode, k: int) <span style="color:#f92672">-&gt;</span> ListNode:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> head <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> k:
            <span style="color:#66d9ef">return</span> head

        first <span style="color:#f92672">=</span> second <span style="color:#f92672">=</span> head

        count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">while</span> first:
            count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            first <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span>next

        k <span style="color:#f92672">=</span> k <span style="color:#f92672">%</span> count
        first <span style="color:#f92672">=</span> head

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(k):
            first <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span>next

        <span style="color:#66d9ef">while</span> first<span style="color:#f92672">.</span>next:
            first <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span>next
            second <span style="color:#f92672">=</span> second<span style="color:#f92672">.</span>next

        first<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> head
        head <span style="color:#f92672">=</span> second<span style="color:#f92672">.</span>next
        second<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> None

        <span style="color:#66d9ef">return</span> head
</code></pre></div><h2 id="63-unique-paths-ii">63 - Unique Paths II</h2>
<p><a href="https://leetcode.com/problems/unique-paths-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).

Now consider if some obstacles are added to the grids. How many unique paths would there be?

An obstacle and empty space is marked as 1 and 0 respectively in the grid.

Note: m and n will be at most 100.

Example 1:

Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -&gt; Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right -&gt; Right
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">uniquePathsWithObstacles</span>(self, obstacleGrid: List[List[int]]) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> obstacleGrid:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        m, n <span style="color:#f92672">=</span> len(obstacleGrid), len(obstacleGrid[<span style="color:#ae81ff">0</span>])

        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]

        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(m):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> obstacleGrid[i][j]:
                    dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> dp[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="74-search-a-2d-matrix">74 - Search a 2D Matrix</h2>
<p><a href="https://leetcode.com/problems/search-a-2d-matrix/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
Example 1:

Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true
Example 2:

Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">searchMatrix</span>(self, matrix: List[List[int]], target: int) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> matrix[<span style="color:#ae81ff">0</span>]:
            <span style="color:#66d9ef">return</span> False

        rl, rr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, len(matrix) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        cl, cr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, len(matrix[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">while</span> rl <span style="color:#f92672">&lt;=</span> rr:
            mid <span style="color:#f92672">=</span> (rl <span style="color:#f92672">+</span> rr) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">if</span> target <span style="color:#f92672">&lt;</span> matrix[mid][<span style="color:#ae81ff">0</span>]:
                rr <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> target <span style="color:#f92672">&gt;</span> matrix[mid][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                rl <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                rl <span style="color:#f92672">=</span> mid
                <span style="color:#66d9ef">break</span>

        <span style="color:#66d9ef">if</span> rl <span style="color:#f92672">&gt;</span> rr:
            <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">while</span> cl <span style="color:#f92672">&lt;=</span> cr:
            mid <span style="color:#f92672">=</span> (cl <span style="color:#f92672">+</span> cr) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>

            <span style="color:#66d9ef">if</span> target <span style="color:#f92672">&lt;</span> matrix[rl][mid]:
                cr <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> target <span style="color:#f92672">&gt;</span> matrix[rl][mid]:
                cl <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">return</span> False
</code></pre></div><h2 id="162-find-peak-element">162 - Find Peak Element</h2>
<p><a href="https://leetcode.com/problems/find-peak-element/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A peak element is an element that is greater than its neighbors.

Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that nums[-1] = nums[n] = -∞.

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5
Explanation: Your function can return either index number 1 where the peak element is 2,
             or index number 5 where the peak element is 6.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findPeakElement</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">if</span> nums[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> nums[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">1</span>

        l <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        r <span style="color:#f92672">=</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>

        <span style="color:#66d9ef">while</span> l <span style="color:#f92672">&lt;=</span> r:
            mid <span style="color:#f92672">=</span> (r <span style="color:#f92672">+</span> l) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">if</span> nums[mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> nums[mid] <span style="color:#f92672">&gt;</span> nums[mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]:
                <span style="color:#66d9ef">return</span> mid
            <span style="color:#66d9ef">elif</span> nums[mid] <span style="color:#f92672">&lt;=</span> nums[mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]:
                l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">if</span> nums[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;</span> nums[<span style="color:#ae81ff">1</span>]:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">elif</span> nums[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> nums[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]:
            <span style="color:#66d9ef">return</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="83-remove-duplicates-from-sorted-list">83 - Remove Duplicates from Sorted List</h2>
<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a sorted linked list, delete all duplicates such that each element appear only once.

Example 1:

Input: 1-&gt;1-&gt;2
Output: 1-&gt;2
Example 2:

Input: 1-&gt;1-&gt;2-&gt;3-&gt;3
Output: 1-&gt;2-&gt;3
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">deleteDuplicates</span>(self, head: ListNode) <span style="color:#f92672">-&gt;</span> ListNode:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> head <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> head<span style="color:#f92672">.</span>next:
            <span style="color:#66d9ef">return</span> head

        first <span style="color:#f92672">=</span> head
        second <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span>next

        <span style="color:#66d9ef">while</span> second:
            <span style="color:#66d9ef">if</span> first<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> second<span style="color:#f92672">.</span>val:
                first<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> second<span style="color:#f92672">.</span>next
                second <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span>next
            <span style="color:#66d9ef">else</span>:
                first, second <span style="color:#f92672">=</span> second, second<span style="color:#f92672">.</span>next

        <span style="color:#66d9ef">return</span> head
</code></pre></div><h2 id="95-unique-binary-search-trees-ii">95 - Unique Binary Search Trees II</h2>
<p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an integer n, generate all structurally unique BST&#39;s (binary search trees) that store values 1 ... n.

Example:

Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST&#39;s shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generateTrees</span>(self, n: int) <span style="color:#f92672">-&gt;</span> List[TreeNode]:
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> []
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>helper(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">helper</span>(self, start, end):
        <span style="color:#66d9ef">if</span> start <span style="color:#f92672">&gt;=</span> end:
            <span style="color:#66d9ef">return</span> [None]
        res <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(start, end):
            <span style="color:#66d9ef">for</span> left <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>helper(start, i):
                <span style="color:#66d9ef">for</span> right <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>helper(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, end):
                    node <span style="color:#f92672">=</span> TreeNode(i)
                    node<span style="color:#f92672">.</span>left, node<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> left, right
                    res<span style="color:#f92672">.</span>append(node)
        <span style="color:#66d9ef">return</span> res
</code></pre></div><h2 id="222-count-complete-tree-nodes">222 - Count Complete Tree Nodes</h2>
<p><a href="https://leetcode.com/problems/count-complete-tree-nodes/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a complete binary tree, count the number of nodes.

Note:

Definition of a complete binary tree from Wikipedia:
In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.

Example:

Input:
    1
   / \
  2   3
 / \  /
4  5 6

Output: 6
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countNodes</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        rd <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>right)
        ld <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>left)

        <span style="color:#66d9ef">if</span> rd <span style="color:#f92672">==</span> ld:
            <span style="color:#66d9ef">return</span> pow(<span style="color:#ae81ff">2</span>, ld) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>countNodes(root<span style="color:#f92672">.</span>right)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> pow(<span style="color:#ae81ff">2</span>, rd) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>countNodes(root<span style="color:#f92672">.</span>left)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">height</span>(self, root):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>left)
</code></pre></div><h2 id="130-surrounded-regions">130 - Surrounded Regions</h2>
<p><a href="https://leetcode.com/explore/featured/card/june-leetcoding-challenge/541/week-3-june-15th-june-21st/3363/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;.

A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region.

Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
Explanation:

Surrounded regions shouldn’t be on the border, which means that any &#39;O&#39; on the border of the board are not flipped to &#39;X&#39;.
Any &#39;O&#39; that is not on the border and it is not connected to an &#39;O&#39; on the border will be flipped to &#39;X&#39;.
Two cells are connected if they are adjacent cells connected horizontally or vertically.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solve</span>(self, board: List[List[str]]) <span style="color:#f92672">-&gt;</span> None:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Do not return anything, modify board in-place instead.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> board <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> board[<span style="color:#ae81ff">0</span>]:
            <span style="color:#66d9ef">return</span>

        marked <span style="color:#f92672">=</span> [[False] <span style="color:#f92672">*</span> len(board[<span style="color:#ae81ff">0</span>]) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> board]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> [<span style="color:#ae81ff">0</span>, len(board)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(board[<span style="color:#ae81ff">0</span>])):
                <span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;O&#39;</span>:
                    self<span style="color:#f92672">.</span>color(board, i, j, <span style="color:#e6db74">&#39;O&#39;</span>, <span style="color:#e6db74">&#39;S&#39;</span>)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(board)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> [<span style="color:#ae81ff">0</span>, len(board[<span style="color:#ae81ff">0</span>])<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                <span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;O&#39;</span>:
                    self<span style="color:#f92672">.</span>color(board, i, j, <span style="color:#e6db74">&#39;O&#39;</span>, <span style="color:#e6db74">&#39;S&#39;</span>)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(board)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(board[<span style="color:#ae81ff">0</span>])):
                board[i][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;OX&#39;</span>[board[i][j] <span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;S&#39;</span>]


    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">color</span>(self, board, i, j, target, symbol):
        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;=</span> len(board) <span style="color:#f92672">or</span> j <span style="color:#f92672">&gt;=</span> len(board[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">or</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">==</span> target:
            board[i][j] <span style="color:#f92672">=</span> symbol
            <span style="color:#66d9ef">for</span> v, w <span style="color:#f92672">in</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]]:
                self<span style="color:#f92672">.</span>color(board, i<span style="color:#f92672">+</span>v, j<span style="color:#f92672">+</span>w, target, symbol)
</code></pre></div><h2 id="129-sum-root-to-leaf-numbers">129 - Sum Root to Leaf Numbers</h2>
<p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

Note: A leaf is a node with no children.

Example:

Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1-&gt;2 represents the number 12.
The root-to-leaf path 1-&gt;3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:

Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.
The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.
The root-to-leaf path 4-&gt;0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Definition for a binary tree node.</span>
<span style="color:#75715e"># class TreeNode:</span>
<span style="color:#75715e">#     def __init__(self, val=0, left=None, right=None):</span>
<span style="color:#75715e">#         self.val = val</span>
<span style="color:#75715e">#         self.left = left</span>
<span style="color:#75715e">#         self.right = right</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sumNumbers</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        self<span style="color:#f92672">.</span>dfs(root, [])
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, root, path):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left:
            path<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>val)
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">+=</span> int(<span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join([str(i) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> path]))
            path<span style="color:#f92672">.</span>pop()
            <span style="color:#66d9ef">return</span>

        path<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>val)
        self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>left, path)
        self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>right, path)
        path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="988-smallest-string-starting-from-leaf">988 - Smallest String Starting From Leaf</h2>
<p><a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given the root of a binary tree, each node has a value from 0 to 25 representing the letters &#39;a&#39; to &#39;z&#39;: a value of 0 represents &#39;a&#39;, a value of 1 represents &#39;b&#39;, and so on.

Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root.

(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, &#34;ab&#34; is lexicographically smaller than &#34;aba&#34;.  A leaf of a node is a node that has no children.

Example 1:

Input: [0,1,2,3,4,3,4]
Output: &#34;dba&#34;

Example 2:

Input: [25,1,3,1,3,0,2]
Output: &#34;adz&#34;
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">smallestFromLeaf</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> str:
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;~&#34;</span>
        self<span style="color:#f92672">.</span>dfs(root, [])
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, root, path):

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span>

        path<span style="color:#f92672">.</span>append(chr(root<span style="color:#f92672">.</span>val<span style="color:#f92672">+</span><span style="color:#ae81ff">97</span>))

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right:
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> min(self<span style="color:#f92672">.</span>ans, <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(reversed(path)))

        self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>left, path)
        self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>right, path)
        path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="303-range-sum-query-immutable">303 - Range Sum Query - Immutable</h2>
<p><a href="https://leetcode.com/problems/range-sum-query-immutable/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.

Example:
Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -&gt; 1
sumRange(2, 5) -&gt; -1
sumRange(0, 5) -&gt; -3
Note:
You may assume that the array does not change.
There are many calls to sumRange function.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NumArray</span>:
    <span style="color:#66d9ef">def</span> __init__(self, nums: List[int]):
        self<span style="color:#f92672">.</span>dp <span style="color:#f92672">=</span> list(nums)
        self<span style="color:#f92672">.</span>dp<span style="color:#f92672">.</span>insert(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)):
            self<span style="color:#f92672">.</span>dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> self<span style="color:#f92672">.</span>dp[i]

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sumRange</span>(self, i: int, j: int) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>dp[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>dp[i]
</code></pre></div><h2 id="264-ugly-number-ii">264 - Ugly Number II</h2>
<p><a href="https://leetcode.com/problems/ugly-number-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example:

Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
Note:

1 is typically treated as an ugly number.
n does not exceed 1690.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    ugly <span style="color:#f92672">=</span> sorted(<span style="color:#ae81ff">2</span><span style="color:#f92672">**</span>a <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">**</span>b <span style="color:#f92672">*</span> <span style="color:#ae81ff">5</span><span style="color:#f92672">**</span>c <span style="color:#66d9ef">for</span> a <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">32</span>) <span style="color:#66d9ef">for</span> b <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">32</span>) <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">32</span>))
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nthUglyNumber</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ugly[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="263-ugly-number">263 - Ugly Number</h2>
<p><a href="https://leetcode.com/problems/ugly-number-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write a program to check whether a given number is an ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example 1:

Input: 6
Output: true
Explanation: 6 = 2 × 3

Example 2:

Input: 8
Output: true
Explanation: 8 = 2 × 2 × 2

Example 3:

Input: 14
Output: false
Explanation: 14 is not ugly since it includes another prime factor 7.
Note:

1 is typically treated as an ugly number.
Input is within the 32-bit signed integer range: [−231,  231 − 1].
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isUgly</span>(self, num: int) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">if</span> num <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">while</span> num <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>:
            tmp <span style="color:#f92672">=</span> num
            <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> [<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>]:
                <span style="color:#66d9ef">if</span> num <span style="color:#f92672">%</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                    num <span style="color:#f92672">//=</span> n
            <span style="color:#66d9ef">if</span> tmp <span style="color:#f92672">==</span> num:
                <span style="color:#66d9ef">return</span> False
        <span style="color:#66d9ef">return</span> True
</code></pre></div><h2 id="332-reconstruct-itinerary">332 - Reconstruct Itinerary</h2>
<p><a href="https://leetcode.com/problems/reconstruct-itinerary/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.

Note:

If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&#34;JFK&#34;, &#34;LGA&#34;] has a smaller lexical order than [&#34;JFK&#34;, &#34;LGB&#34;].
All airports are represented by three capital letters (IATA code).
You may assume all tickets form at least one valid itinerary.
One must use all the tickets once and only once.

Example 1:

Input: [[&#34;MUC&#34;, &#34;LHR&#34;], [&#34;JFK&#34;, &#34;MUC&#34;], [&#34;SFO&#34;, &#34;SJC&#34;], [&#34;LHR&#34;, &#34;SFO&#34;]]
Output: [&#34;JFK&#34;, &#34;MUC&#34;, &#34;LHR&#34;, &#34;SFO&#34;, &#34;SJC&#34;]

Example 2:

Input: [[&#34;JFK&#34;,&#34;SFO&#34;],[&#34;JFK&#34;,&#34;ATL&#34;],[&#34;SFO&#34;,&#34;ATL&#34;],[&#34;ATL&#34;,&#34;JFK&#34;],[&#34;ATL&#34;,&#34;SFO&#34;]]
Output: [&#34;JFK&#34;,&#34;ATL&#34;,&#34;JFK&#34;,&#34;SFO&#34;,&#34;ATL&#34;,&#34;SFO&#34;]
Explanation: Another possible reconstruction is [&#34;JFK&#34;,&#34;SFO&#34;,&#34;ATL&#34;,&#34;JFK&#34;,&#34;ATL&#34;,&#34;SFO&#34;].
             But it is larger in lexical order.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Eulerian Path: a path in graph that visits every edge exactly once.</p>
<p>Eulerian Circuit is an Eulerian Path which starts and ends on the same vertex.</p>
<p>Hierholzer&rsquo;s algorithm:</p>
<p>Modify the graph dfs to backtrack the vertices if there is no other unvisited edges of that vertice.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">while</span> edges[vertice]:
    dfs(edges[vertice]<span style="color:#f92672">.</span>pop())
path<span style="color:#f92672">.</span>append(vertice)
</code></pre></div><p>For this problem, we have to notice the lexical order for choices during dfs.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findItinerary</span>(self, tickets: List[List[str]]) <span style="color:#f92672">-&gt;</span> List[str]:
        edges <span style="color:#f92672">=</span> defaultdict(list)

        <span style="color:#66d9ef">for</span> v, w <span style="color:#f92672">in</span> sorted(tickets)[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
            edges[v] <span style="color:#f92672">+=</span> [w]
        path <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(<span style="color:#e6db74">&#34;JFK&#34;</span>, edges, path)
        <span style="color:#66d9ef">return</span> path[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, vertice, edges, path):
        <span style="color:#66d9ef">while</span>(edges[vertice]):
            self<span style="color:#f92672">.</span>dfs(edges[vertice]<span style="color:#f92672">.</span>pop(), edges, path)
        path<span style="color:#f92672">.</span>append(vertice)
</code></pre></div><h2 id="212-word-search-ii">212 - Word Search II</h2>
<p><a href="https://leetcode.com/problems/word-search-ii">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, where &#34;adjacent&#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

Example:

Input:
board = [
  [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],
  [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],
  [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],
  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]
]
words = [&#34;oath&#34;,&#34;pea&#34;,&#34;eat&#34;,&#34;rain&#34;]

Output: [&#34;eat&#34;,&#34;oath&#34;]


Note:

All inputs are consist of lowercase letters a-z.
The values of words are distinct.
</code></pre></div><h3 id="solution">Solution</h3>
<p>DFS the matrix.</p>
<p>To break the dfs earlier, a Trie data structure is introduced to check wether the path is a valid combination</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TrieNode</span>:
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>children <span style="color:#f92672">=</span> defaultdict(TrieNode)
        self<span style="color:#f92672">.</span>isWord <span style="color:#f92672">=</span> False

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span>:
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>root <span style="color:#f92672">=</span> TrieNode()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(self, word):
        node <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>root
        <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> word:
            node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>children[w]
        node<span style="color:#f92672">.</span>isWord <span style="color:#f92672">=</span> True

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findWords</span>(self, board: List[List[str]], words: List[str]) <span style="color:#f92672">-&gt;</span> List[str]:
        trie <span style="color:#f92672">=</span> Trie()
        node <span style="color:#f92672">=</span> trie<span style="color:#f92672">.</span>root
        <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> words:
            trie<span style="color:#f92672">.</span>insert(w)
        ans <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(board)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(board[<span style="color:#ae81ff">0</span>])):
                self<span style="color:#f92672">.</span>dfs(board, i, j, node, <span style="color:#e6db74">&#34;&#34;</span>, ans)
        <span style="color:#66d9ef">return</span> ans


    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, board, i, j, node, path, ans):
        <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>isWord:
            ans<span style="color:#f92672">.</span>append(path)
            node<span style="color:#f92672">.</span>isWord <span style="color:#f92672">=</span> False

        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">&gt;=</span> len(board) <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">&gt;=</span> len(board[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">or</span> board[i][j] <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> node<span style="color:#f92672">.</span>children:
            <span style="color:#66d9ef">return</span>

        val <span style="color:#f92672">=</span> board[i][j]
        board[i][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;#&#34;</span>
        <span style="color:#66d9ef">for</span> pair <span style="color:#f92672">in</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]]:
            self<span style="color:#f92672">.</span>dfs(board, i<span style="color:#f92672">+</span>pair[<span style="color:#ae81ff">0</span>], j<span style="color:#f92672">+</span>pair[<span style="color:#ae81ff">1</span>], node<span style="color:#f92672">.</span>children[val], path<span style="color:#f92672">+</span>val, ans)
        board[i][j] <span style="color:#f92672">=</span> val
</code></pre></div><h2 id="441-arranging-coins">441 - Arranging Coins</h2>
<p><a href="https://leetcode.com/problems/arranging-coins/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.

Given n, find the total number of full staircase rows that can be formed.

n is a non-negative integer and fits within the range of a 32-bit signed integer.

Example 1:

n = 5

The coins can form the following rows:
¤
¤ ¤
¤ ¤

Because the 3rd row is incomplete, we return 2.
Example 2:

n = 8

The coins can form the following rows:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

Because the 4th row is incomplete, we return 3.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">arrangeCoins</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">while</span> n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
            k <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            n <span style="color:#f92672">-=</span> k

        <span style="color:#66d9ef">return</span> k <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> n <span style="color:#66d9ef">else</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="107-binary-tree-level-order-traversal-ii">107 - Binary Tree Level Order Traversal II</h2>
<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">levelOrderBottom</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> []
        queue <span style="color:#f92672">=</span> [root]
        stack <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">while</span> queue:
            next_queue <span style="color:#f92672">=</span> []
            tmp <span style="color:#f92672">=</span> []
            <span style="color:#66d9ef">while</span> queue:
                n <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>)
                tmp<span style="color:#f92672">.</span>append(n<span style="color:#f92672">.</span>val)
                <span style="color:#66d9ef">if</span> n<span style="color:#f92672">.</span>left:
                    next_queue<span style="color:#f92672">.</span>append(n<span style="color:#f92672">.</span>left)
                <span style="color:#66d9ef">if</span> n<span style="color:#f92672">.</span>right:
                    next_queue<span style="color:#f92672">.</span>append(n<span style="color:#f92672">.</span>right)
            stack<span style="color:#f92672">.</span>append(tmp[:])
            queue <span style="color:#f92672">=</span> next_queue[:]

        <span style="color:#66d9ef">return</span> stack[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="463-island-perimeter">463 - Island Perimeter</h2>
<p><a href="https://leetcode.com/problems/island-perimeter/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.

Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).

The island doesn&#39;t have &#34;lakes&#34; (water inside that isn&#39;t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don&#39;t exceed 100. Determine the perimeter of the island.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">islandPerimeter</span>(self, grid: List[List[int]]) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> grid <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> grid[<span style="color:#ae81ff">0</span>]:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(grid)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(grid[<span style="color:#ae81ff">0</span>])):
                <span style="color:#66d9ef">if</span> grid[i][j]:
                    <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>dfs(grid, i, j)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, grid, i, j):
        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">&gt;=</span> len(grid) <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">&gt;=</span> len(grid[<span style="color:#ae81ff">0</span>]):
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">if</span> grid[i][j] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">if</span> grid[i][j]:
            grid[i][j] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>dfs(grid, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, j) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>dfs(
                grid, i, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>dfs(grid, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>dfs(
                    grid, i, j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="695-max-area-of-island">695 - Max Area of Island</h2>
<p><a href="https://leetcode.com/problems/max-area-of-island/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-empty 2D array grid of 0&#39;s and 1&#39;s, an island is a group of 1&#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)

Example 1:

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.

Example 2:

[[0,0,0,0,0,0,0,0]]
Given the above grid, return 0.
Note: The length of each dimension in the given grid does not exceed 50.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxAreaOfIsland</span>(self, grid: List[List[int]]) <span style="color:#f92672">-&gt;</span> int:

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> grid <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> grid[<span style="color:#ae81ff">0</span>]:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(grid)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(grid[<span style="color:#ae81ff">0</span>])):
                <span style="color:#66d9ef">if</span> grid[i][j] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                    ans <span style="color:#f92672">=</span> max(ans, self<span style="color:#f92672">.</span>dfs(grid, i, j))
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, grid, i, j):

        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">&gt;=</span> len(grid) <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">&gt;=</span> len(grid[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> grid[i][j]:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        grid[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        count <span style="color:#f92672">+=</span> self<span style="color:#f92672">.</span>dfs(grid, i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, j)
        count <span style="color:#f92672">+=</span> self<span style="color:#f92672">.</span>dfs(grid, i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, j)
        count <span style="color:#f92672">+=</span> self<span style="color:#f92672">.</span>dfs(grid, i, j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
        count <span style="color:#f92672">+=</span> self<span style="color:#f92672">.</span>dfs(grid, i, j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> count
</code></pre></div><h2 id="15-3sum">15 - 3SUM</h2>
<p><a href="https://leetcode.com/problems/3sum/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">threeSum</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>:
            <span style="color:#66d9ef">return</span> []
        ans <span style="color:#f92672">=</span> []
        nums<span style="color:#f92672">.</span>sort()
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(nums)<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>):
            <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                <span style="color:#66d9ef">break</span>
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> nums[i]:
                <span style="color:#66d9ef">continue</span>
            left, right <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, len(nums)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

            <span style="color:#66d9ef">while</span> right <span style="color:#f92672">&gt;</span> left:
                s <span style="color:#f92672">=</span> nums[left] <span style="color:#f92672">+</span> nums[right] <span style="color:#f92672">+</span> nums[i]
                <span style="color:#66d9ef">if</span> s <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                    ans<span style="color:#f92672">.</span>append([nums[i], nums[left], nums[right]])
                    left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                    right <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                    <span style="color:#66d9ef">while</span> right <span style="color:#f92672">&gt;</span> left <span style="color:#f92672">and</span> nums[left] <span style="color:#f92672">==</span> nums[left<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                        left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                    <span style="color:#66d9ef">while</span> right <span style="color:#f92672">&gt;</span> left <span style="color:#f92672">and</span> nums[right] <span style="color:#f92672">==</span> nums[right<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]:
                        right <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">elif</span> s <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
                    left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    right <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="10-regular-expression-matching">10 - Regular Expression Matching</h2>
<p><a href="https://leetcode.com/problems/regular-expression-matching/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.

&#39;.&#39; Matches any single character.
&#39;*&#39; Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = &#34;aa&#34;
p = &#34;a&#34;
Output: false
Explanation: &#34;a&#34; does not match the entire string &#34;aa&#34;.

Example 2:

Input:
s = &#34;aa&#34;
p = &#34;a*&#34;
Output: true
Explanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &#34;aa&#34;.

Example 3:

Input:
s = &#34;ab&#34;
p = &#34;.*&#34;
Output: true
Explanation: &#34;.*&#34; means &#34;zero or more (*) of any character (.)&#34;.

Example 4:

Input:
s = &#34;aab&#34;
p = &#34;c*a*b&#34;
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &#34;aab&#34;.

Example 5:

Input:
s = &#34;mississippi&#34;
p = &#34;mis*is*p*.&#34;
Output: false
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isMatch</span>(self, s: str, p: str) <span style="color:#f92672">-&gt;</span> bool:

        dp <span style="color:#f92672">=</span> [[False] <span style="color:#f92672">*</span> (len(s)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(len(p)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]

        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> True

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(p)):
            <span style="color:#66d9ef">if</span> p[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;*&#34;</span> <span style="color:#f92672">and</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]:
                dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> True

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(p)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(s)):
                <span style="color:#66d9ef">if</span> p[i] <span style="color:#f92672">==</span> s[j]:
                    dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[i][j]
                <span style="color:#66d9ef">elif</span> p[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span>:
                    dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[i][j]
                <span style="color:#66d9ef">elif</span> p[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span>:
                    <span style="color:#66d9ef">if</span> p[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> s[j] <span style="color:#f92672">and</span> p[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span>:
                        dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
                    <span style="color:#66d9ef">else</span>:
                        dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> dp[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">or</span> dp[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">or</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="37-sudoku-solver">37 - Sudoku Solver</h2>
<p><a href="https://leetcode.com/problems/sudoku-solver/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write a program to solve a Sudoku puzzle by filling the empty cells.

A sudoku solution must satisfy all of the following rules:

Each of the digits 1-9 must occur exactly once in each row.
Each of the digits 1-9 must occur exactly once in each column.
Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
Empty cells are indicated by the character &#39;.&#39;.

Note:

The given board contain only digits 1-9 and the character &#39;.&#39;.
You may assume that the given Sudoku puzzle will have a single unique solution.
The given board size is always 9x9.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solveSudoku</span>(self, board: List[List[str]]) <span style="color:#f92672">-&gt;</span> None:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Do not return anything, modify board in-place instead.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>finish <span style="color:#f92672">=</span> False
        self<span style="color:#f92672">.</span>solve(board, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solve</span>(self, board, i, j):
        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;=</span> len(board):
            self<span style="color:#f92672">.</span>finish <span style="color:#f92672">=</span> True
            <span style="color:#66d9ef">return</span>
        next_i, next_j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> (j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">9</span>, (j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">9</span>
        <span style="color:#66d9ef">if</span> board[i][j] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;.&#39;</span>:
            <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>):
                <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>is_safe(board, i, j, str(n)):
                    board[i][j] <span style="color:#f92672">=</span> str(n)
                    self<span style="color:#f92672">.</span>solve(board, next_i, next_j)
                    <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>finish:
                        <span style="color:#66d9ef">return</span>
                    board[i][j] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>
        <span style="color:#66d9ef">else</span>:
            self<span style="color:#f92672">.</span>solve(board, next_i, next_j)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_safe</span>(self, board, i, j, n):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>is_safe_vertical(
            board, i, j, n) <span style="color:#f92672">and</span> self<span style="color:#f92672">.</span>is_safe_horizontal(
                board, i, j, n) <span style="color:#f92672">and</span> self<span style="color:#f92672">.</span>is_safe_sub(board, i, j, n)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_safe_vertical</span>(self, board, i, j, n):
        <span style="color:#66d9ef">return</span> n <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> [a[j] <span style="color:#66d9ef">for</span> a <span style="color:#f92672">in</span> board]

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_safe_horizontal</span>(self, board, i, j, n):
        <span style="color:#66d9ef">return</span> n <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> board[i]

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_safe_sub</span>(self, board, i, j, n):
        p1 <span style="color:#f92672">=</span> i <span style="color:#f92672">//</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>
        p2 <span style="color:#f92672">=</span> j <span style="color:#f92672">//</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">3</span>
        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(p1, p1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>):
            <span style="color:#66d9ef">for</span> y <span style="color:#f92672">in</span> range(p2, p2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>):
                <span style="color:#66d9ef">if</span> board[x][y] <span style="color:#f92672">==</span> n:
                    <span style="color:#66d9ef">return</span> False
        <span style="color:#66d9ef">return</span> True
</code></pre></div><h2 id="36-valid-sudoku">36 - Valid Sudoku</h2>
<p><a href="https://leetcode.com/problems/valid-sudoku/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isValidSudoku</span>(self, board: List[List[str]]) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> board:
            nums <span style="color:#f92672">=</span> [x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> row <span style="color:#66d9ef">if</span> x <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span> ]
            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>notValid(nums):
                <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(board[<span style="color:#ae81ff">0</span>])):
            col <span style="color:#f92672">=</span> [row[i] <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> board]
            nums <span style="color:#f92672">=</span> [x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> col <span style="color:#66d9ef">if</span> x <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span> ]
            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>notValid(nums):
                <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>]:
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>]:
                nums <span style="color:#f92672">=</span> [x <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> board[i:i<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>] <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> row[j:j<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>] <span style="color:#66d9ef">if</span> x <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span>]
                <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>notValid(nums):
                    <span style="color:#66d9ef">return</span> False
        <span style="color:#66d9ef">return</span> True

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">notValid</span>(self, nums):
        <span style="color:#66d9ef">return</span> len(set(nums)) <span style="color:#f92672">!=</span> len(nums)
</code></pre></div><h2 id="190-reverse-bits">190 - Reverse Bits</h2>
<p><a href="https://leetcode.com/problems/reverse-bits/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Reverse bits of a given 32 bits unsigned integer.

Example 1:

Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.

Example 2:

Input: 11111111111111111111111111111101
Output: 10111111111111111111111111111111
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.

Note:

Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2&#39;s complement notation. Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-reverse-bit-one-by-one">Solution 1: Reverse bit one by one</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reverseBits</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        shift <span style="color:#f92672">=</span> <span style="color:#ae81ff">31</span>
        <span style="color:#66d9ef">while</span> n:
            res <span style="color:#f92672">+=</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&lt;&lt;</span> shift
            n <span style="color:#f92672">=</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>
            shift <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> res
</code></pre></div><h4 id="solution-2-reverse-bit-with-masks">Solution 2: Reverse bit with masks</h4>
<ol>
<li>First we swith first 16 bits and last 16 bits</li>
<li>Repeat this operation in each half part. For example switch the first 8 bits and last 8 bits in the left 16 bits. Do the same in the right one</li>
<li>Until only switch one bit</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reverseBits</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        n <span style="color:#f92672">=</span> (n <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">16</span> <span style="color:#f92672">|</span> n <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">16</span>)
        n <span style="color:#f92672">=</span> ((n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff00ff00</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span> <span style="color:#f92672">|</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x00ff00ff</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>)
        n <span style="color:#f92672">=</span> ((n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xf0f0f0f0</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">|</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x0f0f0f0f</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">4</span>)
        n <span style="color:#f92672">=</span> ((n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xcccccccc</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x33333333</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">2</span>)
        n <span style="color:#f92672">=</span> ((n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xaaaaaaaa</span>) <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> (n <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x55555555</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> n
</code></pre></div><h2 id="461-hamming-distance">461 - Hamming Distance</h2>
<p><a href="https://leetcode.com/problems/hamming-distance/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, calculate the Hamming distance.

Note:
0 ≤ x, y &lt; 231.

Example:

Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.
Accepted
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1">Solution 1:</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hammingDistance</span>(self, x: int, y: int) <span style="color:#f92672">-&gt;</span> int:
        z <span style="color:#f92672">=</span> x <span style="color:#f92672">^</span> y
        s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">while</span> z:
            s <span style="color:#f92672">+=</span> z <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>
            z <span style="color:#f92672">=</span> z <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> s
</code></pre></div><h4 id="solution-2-t-and--t-1">Solution 2: t &amp; (t - 1)</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hammingDistance</span>(self, x: int, y: int) <span style="color:#f92672">-&gt;</span> int:
        z <span style="color:#f92672">=</span> x <span style="color:#f92672">^</span> y
        s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">while</span> z:

            s <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            z <span style="color:#f92672">=</span> z <span style="color:#f92672">&amp;</span> (z <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">return</span> s
</code></pre></div><h2 id="32-longest-valid-parentheses">32 - Longest Valid Parentheses</h2>
<p><a href="https://leetcode.com/problems/longest-valid-parentheses">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, find the length of the longest valid (well-formed) parentheses substring.

Example 1:

Input: &#34;(()&#34;
Output: 2
Explanation: The longest valid parentheses substring is &#34;()&#34;

Example 2:

Input: &#34;)()())&#34;
Output: 4
Explanation: The longest valid parentheses substring is &#34;()()&#34;
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestValidParentheses</span>(self, s: str) <span style="color:#f92672">-&gt;</span> int:
        stack <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s)):
            <span style="color:#66d9ef">if</span> s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span>:
                stack<span style="color:#f92672">.</span>append(i)
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">if</span> stack:
                    stack<span style="color:#f92672">.</span>pop()
                <span style="color:#66d9ef">if</span> stack:
                    ans <span style="color:#f92672">=</span> max(ans, i <span style="color:#f92672">-</span> stack[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
                <span style="color:#66d9ef">else</span>:
                    stack<span style="color:#f92672">.</span>append(i)
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="71-simplify-path">71 - Simplify Path</h2>
<p><a href="https://leetcode.com/problems/simplify-path/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.

In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level.

Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.

Example 1:

Input: &#34;/home/&#34;
Output: &#34;/home&#34;
Explanation: Note that there is no trailing slash after the last directory name.

Example 2:

Input: &#34;/../&#34;
Output: &#34;/&#34;
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.

Example 3:

Input: &#34;/home//foo/&#34;
Output: &#34;/home/foo&#34;
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.

Example 4:

Input: &#34;/a/./b/../../c/&#34;
Output: &#34;/c&#34;

Example 5:

Input: &#34;/a/../../b/../c//.//&#34;
Output: &#34;/c&#34;

Example 6:

Input: &#34;/a//b////c/d//././/..&#34;
Output: &#34;/a/b/c&#34;
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">simplifyPath</span>(self, path: str) <span style="color:#f92672">-&gt;</span> str:
        stack <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> path<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;/&#39;</span>):
            <span style="color:#66d9ef">if</span> p <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;..&#39;</span>:
                <span style="color:#66d9ef">if</span> stack:
                    stack<span style="color:#f92672">.</span>pop()
            <span style="color:#66d9ef">elif</span> p <span style="color:#f92672">and</span> p <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;.&#39;</span>:
                stack<span style="color:#f92672">.</span>append(p)

        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;/&#39;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;/&#34;</span><span style="color:#f92672">.</span>join(stack)
</code></pre></div><h2 id="73-set-matrix-zeroes">73 - Set Matrix Zeroes</h2>
<p><a href="https://leetcode.com/problems/set-matrix-zeroes/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Example 1:

Input:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]

Example 2:

Input:
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output:
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
Follow up:

A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">setZeroes</span>(self, matrix: List[List[int]]) <span style="color:#f92672">-&gt;</span> None:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Do not return anything, modify matrix in-place instead.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        col_zero <span style="color:#f92672">=</span> False

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(matrix)):
            <span style="color:#66d9ef">if</span> matrix[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                col_zero <span style="color:#f92672">=</span> True
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(matrix[<span style="color:#ae81ff">0</span>])):
                <span style="color:#66d9ef">if</span> matrix[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                    matrix[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> matrix[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(matrix)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(matrix[<span style="color:#ae81ff">0</span>])):
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> matrix[i][<span style="color:#ae81ff">0</span>]:
                    matrix[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">if</span> matrix[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(matrix[<span style="color:#ae81ff">0</span>])):
                matrix[<span style="color:#ae81ff">0</span>][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">if</span> col_zero:
            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(matrix)):
                matrix[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h2 id="80-remove-duplicates-from-sorted-array-ii">80 - Remove Duplicates from Sorted Array II</h2>
<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn&#39;t matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn&#39;t matter what values are set beyond the returned length.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Keep a pointer to copy the value from behind.</p>
<p>Very interesting solution: n &gt; nums[i-k], where k = 2</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">removeDuplicates</span>(self, nums):
        i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        k <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
        <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> nums:
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">or</span> n <span style="color:#f92672">&gt;</span> nums[i<span style="color:#f92672">-</span>k]:
                nums[i] <span style="color:#f92672">=</span> n
                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> i
</code></pre></div><h2 id="81-search-in-rotated-sorted-array-ii">81 - Search in Rotated Sorted Array II</h2>
<p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).

You are given a target value to search. If found in the array return true, otherwise return false.

Example 1:

Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:

Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
Follow up:

This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.
Would this affect the run-time complexity? How and why?
</code></pre></div><h3 id="solution">Solution</h3>
<p>Note:</p>
<p>Consider the problem in two part:</p>
<ol>
<li>when the left part is in order</li>
<li>when the right part is in order</li>
</ol>
<p>Important: How to guarentee the left part is in order when there is duplicates in the array:
We can use a <code>while</code> to eliminate the duplicates if nums[left] == nums[mid]</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">search</span>(self, nums: List[int], target: int) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> False

        left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        right <span style="color:#f92672">=</span> len(nums) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">while</span> left <span style="color:#f92672">&lt;</span> right:
            mid <span style="color:#f92672">=</span> (left <span style="color:#f92672">+</span> right) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>

            <span style="color:#66d9ef">if</span> nums[mid] <span style="color:#f92672">==</span> target:
                <span style="color:#66d9ef">return</span> True

            <span style="color:#66d9ef">while</span> left <span style="color:#f92672">&lt;</span> mid <span style="color:#f92672">and</span> nums[left] <span style="color:#f92672">==</span> nums[mid]:
                left <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

            <span style="color:#66d9ef">if</span> nums[mid] <span style="color:#f92672">&gt;=</span> nums[left]:
                <span style="color:#66d9ef">if</span> nums[mid] <span style="color:#f92672">&gt;</span> target <span style="color:#f92672">&gt;=</span> nums[left]:
                    right <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">if</span> nums[mid] <span style="color:#f92672">&lt;</span> target <span style="color:#f92672">&lt;=</span> nums[right]:
                    left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    right <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">print</span>(left, right)

        <span style="color:#66d9ef">return</span> target <span style="color:#f92672">==</span> nums[left]
</code></pre></div><h2 id="191-number-of-1-bits">191 - Number of 1 Bits</h2>
<p><a href="https://leetcode.com/problems/number-of-1-bits/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write a function that takes an unsigned integer and return the number of &#39;1&#39; bits it has (also known as the Hamming weight).

Example 1:

Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three &#39;1&#39; bits.

Example 2:

Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one &#39;1&#39; bit.

Example 3:

Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one &#39;1&#39; bits.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hammingWeight</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">while</span> n:
            ans <span style="color:#f92672">+=</span> n <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>
            n <span style="color:#f92672">//=</span> <span style="color:#ae81ff">2</span>

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="82-remove-duplicates-from-sorted-list-ii">82 - Remove Duplicates from Sorted List II</h2>
<p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

Return the linked list sorted as well.

Example 1:

Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
Output: 1-&gt;2-&gt;5
Example 2:

Input: 1-&gt;1-&gt;1-&gt;2-&gt;3
Output: 2-&gt;3
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">deleteDuplicates</span>(self, head: ListNode) <span style="color:#f92672">-&gt;</span> ListNode:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> head <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> head<span style="color:#f92672">.</span>next:
            <span style="color:#66d9ef">return</span> head
        extra <span style="color:#f92672">=</span> ListNode(None)

        extra<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> head
        pre <span style="color:#f92672">=</span> extra

        <span style="color:#66d9ef">while</span> head <span style="color:#f92672">and</span> head<span style="color:#f92672">.</span>next:
            <span style="color:#66d9ef">if</span> head<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> head<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>val:
                <span style="color:#66d9ef">while</span> head <span style="color:#f92672">and</span> head<span style="color:#f92672">.</span>next <span style="color:#f92672">and</span> head<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> head<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>val:
                    head <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span>next

                head <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span>next
                pre<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> head
            <span style="color:#66d9ef">else</span>:
                pre <span style="color:#f92672">=</span> head
                head <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span>next

        <span style="color:#66d9ef">return</span> extra<span style="color:#f92672">.</span>next
</code></pre></div><h2 id="240-search-a-2d-matrix-ii">240 - Search a 2D Matrix II</h2>
<p><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.

Example:

Consider the following matrix:

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
Given target = 5, return true.

Given target = 20, return false.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1">Solution 1</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">searchMatrix</span>(self, matrix, target):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        :type matrix: List[List[int]]
</span><span style="color:#e6db74">        :type target: int
</span><span style="color:#e6db74">        :rtype: bool
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> matrix[<span style="color:#ae81ff">0</span>]:
            <span style="color:#66d9ef">return</span> False

        j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> matrix:
            <span style="color:#66d9ef">if</span> row[j] <span style="color:#f92672">&gt;</span> target:
                <span style="color:#66d9ef">while</span> row[j] <span style="color:#f92672">&gt;</span> target:
                    j <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                    <span style="color:#66d9ef">if</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
                        <span style="color:#66d9ef">return</span> False


            <span style="color:#66d9ef">elif</span> row[j] <span style="color:#f92672">&lt;</span> target:
                <span style="color:#66d9ef">while</span> row[j] <span style="color:#f92672">&lt;</span> target:
                    j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                    <span style="color:#66d9ef">if</span> j <span style="color:#f92672">==</span> len(matrix[<span style="color:#ae81ff">0</span>]):
                        j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
                        <span style="color:#66d9ef">break</span>


            <span style="color:#66d9ef">if</span> row[j] <span style="color:#f92672">==</span> target:
                <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">return</span> False
</code></pre></div><h4 id="solution-2-like-a-binary-tree">Solution 2: Like a binary tree</h4>
<p>Start from upper right corner.</p>
<p>If matrix[i][j] &gt; target: col - 1</p>
<p>if matrix[i][j] &lt; target: row + 1</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">searchMatrix</span>(self, matrix, target):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> matrix[<span style="color:#ae81ff">0</span>]:
            <span style="color:#66d9ef">return</span> False

        i, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, len(matrix[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> len(matrix) <span style="color:#f92672">and</span> j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> :

            <span style="color:#66d9ef">if</span> matrix[i][j] <span style="color:#f92672">==</span> target:
                <span style="color:#66d9ef">return</span> True
            <span style="color:#66d9ef">elif</span> matrix[i][j] <span style="color:#f92672">&gt;</span> target:
                j <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> False
</code></pre></div><h2 id="1103-distribute-candies-to-people">1103 - Distribute Candies to People</h2>
<p><a href="https://leetcode.com/problems/distribute-candies-to-people">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">We distribute some number of candies, to a row of n = num_people people in the following way:

We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person.

Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person.

This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.  The last person will receive all of our remaining candies (not necessarily one more than the previous gift).

Return an array (of length num_people and sum candies) that represents the final distribution of candies.

Example 1:

Input: candies = 7, num_people = 4
Output: [1,2,3,1]
Explanation:
On the first turn, ans[0] += 1, and the array is [1,0,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0,0].
On the third turn, ans[2] += 3, and the array is [1,2,3,0].
On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].

Example 2:

Input: candies = 10, num_people = 3
Output: [5,2,3]
Explanation:
On the first turn, ans[0] += 1, and the array is [1,0,0].
On the second turn, ans[1] += 2, and the array is [1,2,0].
On the third turn, ans[2] += 3, and the array is [1,2,3].
On the fourth turn, ans[0] += 4, and the final array is [5,2,3].
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">distributeCandies</span>(self, candies: int, num_people: int) <span style="color:#f92672">-&gt;</span> List[int]:
        i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        ans <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> num_people
        <span style="color:#66d9ef">while</span> candies <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
            ans[(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">%</span> num_people] <span style="color:#f92672">+=</span> min(candies, i)
            candies <span style="color:#f92672">-=</span> i
            i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="148-sort-list">148 - Sort List</h2>
<p><a href="https://leetcode.com/problems/sort-list/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Sort a linked list in O(n log n) time using constant space complexity.

Example 1:

Input: 4-&gt;2-&gt;1-&gt;3
Output: 1-&gt;2-&gt;3-&gt;4
Example 2:

Input: -1-&gt;5-&gt;3-&gt;4-&gt;0
Output: -1-&gt;0-&gt;3-&gt;4-&gt;5
</code></pre></div><h3 id="solution">Solution</h3>
<p>Merge Sort</p>
<ol>
<li>Slow-Fast-Pointer to split the list into half. Do not forget slow.next = None</li>
<li>Sort two part recursively and merge together</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sortList</span>(self, head: ListNode) <span style="color:#f92672">-&gt;</span> ListNode:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> head <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> head<span style="color:#f92672">.</span>next:
            <span style="color:#66d9ef">return</span> head

        <span style="color:#75715e"># split in half</span>
        fast <span style="color:#f92672">=</span> slow <span style="color:#f92672">=</span> head
        <span style="color:#66d9ef">while</span> fast<span style="color:#f92672">.</span>next <span style="color:#f92672">and</span> fast<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next:
            fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next
            slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">.</span>next

        second <span style="color:#f92672">=</span> slow<span style="color:#f92672">.</span>next
        slow<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> None

        first <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>sortList(head)
        second <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>sortList(second)

        <span style="color:#75715e"># merge</span>
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>merge(first, second)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">merge</span>(self, p1, p2):
        p <span style="color:#f92672">=</span> dummy <span style="color:#f92672">=</span> ListNode(<span style="color:#ae81ff">0</span>)

        <span style="color:#66d9ef">while</span> p1 <span style="color:#f92672">and</span> p2:
            <span style="color:#66d9ef">if</span> p1<span style="color:#f92672">.</span>val <span style="color:#f92672">&lt;</span> p2<span style="color:#f92672">.</span>val:
                p<span style="color:#f92672">.</span>next, p1 <span style="color:#f92672">=</span> p1, p1<span style="color:#f92672">.</span>next
            <span style="color:#66d9ef">else</span>:
                p<span style="color:#f92672">.</span>next, p2 <span style="color:#f92672">=</span> p2, p2<span style="color:#f92672">.</span>next
            p <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>next

        p<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> p1 <span style="color:#f92672">or</span> p2

        <span style="color:#66d9ef">return</span> dummy<span style="color:#f92672">.</span>next
</code></pre></div><h2 id="142-reorder-list">142 - Reorder List</h2>
<p><a href="https://leetcode.com/problems/reorder-list/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a singly linked list L: L0→L1→…→Ln-1→Ln,
reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…

You may not modify the values in the list&#39;s nodes, only nodes itself may be changed.

Example 1:

Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.
Example 2:

Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reorderList</span>(self, head: ListNode) <span style="color:#f92672">-&gt;</span> None:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> head <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> head<span style="color:#f92672">.</span>next:
            <span style="color:#66d9ef">return</span>
        fast <span style="color:#f92672">=</span> slow <span style="color:#f92672">=</span> head

        <span style="color:#66d9ef">while</span> fast<span style="color:#f92672">.</span>next <span style="color:#f92672">and</span> fast<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next:
            fast <span style="color:#f92672">=</span> fast<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next
            slow <span style="color:#f92672">=</span> slow<span style="color:#f92672">.</span>next

        p1, p2 <span style="color:#f92672">=</span> slow, slow<span style="color:#f92672">.</span>next
        slow<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> None

        <span style="color:#66d9ef">while</span> p2:
            p2<span style="color:#f92672">.</span>next, p2, p1 <span style="color:#f92672">=</span> p1, p2<span style="color:#f92672">.</span>next, p2

        first <span style="color:#f92672">=</span> head
        tail <span style="color:#f92672">=</span> p1

        <span style="color:#66d9ef">while</span> tail <span style="color:#f92672">and</span> first:

            first<span style="color:#f92672">.</span>next, tail<span style="color:#f92672">.</span>next, first, tail <span style="color:#f92672">=</span> tail, first<span style="color:#f92672">.</span>next, first<span style="color:#f92672">.</span>next, tail<span style="color:#f92672">.</span>next
</code></pre></div><h2 id="967-numbers-with-same-consecutive-differences">967 - Numbers With Same Consecutive Differences</h2>
<p><a href="https://leetcode.com/problems/numbers-with-same-consecutive-differences/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Return all non-negative integers of length N such that the absolute difference between every two consecutive digits is K.

Note that every number in the answer must not have leading zeros except for the number 0 itself. For example, 01 has one leading zero and is invalid, but 0 is valid.

You may return the answer in any order.

Example 1:

Input: N = 3, K = 7
Output: [181,292,707,818,929]
Explanation: Note that 070 is not a valid number, because it has leading zeroes.
Example 2:

Input: N = 2, K = 1
Output: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]
</code></pre></div><h3 id="solution">Solution</h3>
<p>It is a simple queue problem.</p>
<p>Two corner cases to notice:</p>
<ol>
<li>remember to include 0 in the answers if the N == 1</li>
<li>if K == 0, do not add +K, -K twice. They have the same value.</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numsSameConsecDiff</span>(self, N: int, K: int) <span style="color:#f92672">-&gt;</span> List[int]:
        ans <span style="color:#f92672">=</span> [i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">10</span>)]

        <span style="color:#66d9ef">if</span> N <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> ans

        digits <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">**</span> (N<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">while</span> ans[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">/</span> digits <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>:
            cur <span style="color:#f92672">=</span> ans<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>)
            last_digit <span style="color:#f92672">=</span> cur <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>
            <span style="color:#66d9ef">if</span> K <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                ans<span style="color:#f92672">.</span>append(cur <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> last_digit)
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">if</span> last_digit <span style="color:#f92672">+</span> K <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>:
                    ans<span style="color:#f92672">.</span>append(cur <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> last_digit <span style="color:#f92672">+</span> K)
                <span style="color:#66d9ef">if</span> last_digit <span style="color:#f92672">-</span> K <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
                    ans<span style="color:#f92672">.</span>append(cur <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> last_digit <span style="color:#f92672">-</span> K)
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="97-interleaving-string">97 - Interleaving String</h2>
<p><a href="https://leetcode.com/problems/interleaving-string/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.

Example 1:

Input: s1 = &#34;aabcc&#34;, s2 = &#34;dbbca&#34;, s3 = &#34;aadbbcbcac&#34;
Output: true
Example 2:

Input: s1 = &#34;aabcc&#34;, s2 = &#34;dbbca&#34;, s3 = &#34;aadbbbaccc&#34;
Output: false
</code></pre></div><h3 id="solution">Solution</h3>
<p>DP problem.</p>
<p>Imagin you have a matrix with s1 as its row and s2 as its column.</p>
<p>You have to find a path from upper left corner to bottom right corner, which consisits the s3.</p>
<p>So when you walk the path, you have two options:</p>
<ol>
<li>you come from left. dp[i][j] = dp[i][j-1] and s1[j-1] == s3[i+j-1]</li>
<li>you come from above. dp[i][j] = dp[i][j-1] and s2[i-1] == s3[i+j-1]</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isInterleave</span>(self, s1: str, s2: str, s3: str) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">if</span> len(s1) <span style="color:#f92672">+</span> len(s2) <span style="color:#f92672">!=</span> len(s3):
            <span style="color:#66d9ef">return</span> False
        dp <span style="color:#f92672">=</span> [[False] <span style="color:#f92672">*</span> (len(s1)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(len(s2)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s2)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(s1)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> i <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> j:
                    dp[i][j] <span style="color:#f92672">=</span> True
                <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> i:
                    dp[i][j] <span style="color:#f92672">=</span> dp[<span style="color:#ae81ff">0</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> s1[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> s3[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> j:
                    dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">and</span> s2[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> s3[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#66d9ef">else</span>:
                    dp[i][j] <span style="color:#f92672">=</span> (dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">and</span> s2[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> s3[i<span style="color:#f92672">+</span>j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">or</span> (dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> s1[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> s3[i<span style="color:#f92672">+</span>j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="108-convert-sorted-array-to-binary-search-tree">108 - Convert Sorted Array to Binary Search Tree</h2>
<p><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:

Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sortedArrayToBST</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> TreeNode:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> None

        mid <span style="color:#f92672">=</span> len(nums)<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>

        root <span style="color:#f92672">=</span> TreeNode(nums[mid])
        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>sortedArrayToBST(nums[:mid])
        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>sortedArrayToBST(nums[mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:])

        <span style="color:#66d9ef">return</span> root
</code></pre></div><h2 id="109-convert-sorted-list-to-binary-search-tree">109 - Convert Sorted List to Binary Search Tree</h2>
<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sortedListToBST</span>(self, head: ListNode) <span style="color:#f92672">-&gt;</span> TreeNode:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> head:
            <span style="color:#66d9ef">return</span> None
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> head<span style="color:#f92672">.</span>next:
            <span style="color:#66d9ef">return</span> TreeNode(head<span style="color:#f92672">.</span>val)

        pre, slow, fast <span style="color:#f92672">=</span> None, head, head

        <span style="color:#66d9ef">while</span> fast <span style="color:#f92672">and</span> fast<span style="color:#f92672">.</span>next:
            pre, slow, fast <span style="color:#f92672">=</span> slow, slow<span style="color:#f92672">.</span>next, fast<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next

        pre<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> None
        root <span style="color:#f92672">=</span> TreeNode(slow<span style="color:#f92672">.</span>val)
        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>sortedListToBST(head)
        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>sortedListToBST(slow<span style="color:#f92672">.</span>next)

        <span style="color:#66d9ef">return</span> root
</code></pre></div><h2 id="110-balanced-binary-tree">110 - Balanced Binary Tree</h2>
<p><a href="https://leetcode.com/problems/balanced-binary-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

Example 1:

Given the following tree [3,9,20,null,null,15,7]:

    3
   / \
  9  20
    /  \
   15   7
Return true.

Example 2:

Given the following tree [1,2,2,3,3,null,null,4,4]:

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
Return false.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-multiple-pass">Solution 1: multiple pass</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isBalanced</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> True

        hr <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>right)
        hl <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>left)

        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>isBalanced(root<span style="color:#f92672">.</span>right) <span style="color:#f92672">and</span> self<span style="color:#f92672">.</span>isBalanced(
            root<span style="color:#f92672">.</span>left) <span style="color:#f92672">and</span> abs(hr <span style="color:#f92672">-</span> hl) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">height</span>(self, root):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> max(self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>right), self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>left))
</code></pre></div><p>This method has to calculate the height mutiple times, which costs a lot of time.</p>
<h4 id="solution-2-one-pass">Solution 2: one pass</h4>
<p>It is a dfs method, which only go over all nodes one time.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isBalanced</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>height(root) <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">height</span>(self, root):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        lh <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>right)
        <span style="color:#66d9ef">if</span> lh <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        rh <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>height(root<span style="color:#f92672">.</span>left)
        <span style="color:#66d9ef">if</span> rh <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">if</span> abs(lh <span style="color:#f92672">-</span> rh) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> max(lh, rh) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="111-minimum-depth-of-binary-tree">111 - Minimum Depth of Binary Tree</h2>
<p><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its minimum depth = 2.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minDepth</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>minDepth(root<span style="color:#f92672">.</span>left) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>minDepth(root<span style="color:#f92672">.</span>right) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> min(self<span style="color:#f92672">.</span>minDepth(root<span style="color:#f92672">.</span>right), self<span style="color:#f92672">.</span>minDepth(root<span style="color:#f92672">.</span>left)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minDepth</span>(self, root):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root: <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        dl <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>minDepth(root<span style="color:#f92672">.</span>left)
        dr <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>minDepth(root<span style="color:#f92672">.</span>right)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> (min(dl, dr) <span style="color:#f92672">or</span> max(dl, dr))
</code></pre></div><h2 id="824-goat-latin">824 - Goat Latin</h2>
<p><a href="https://leetcode.com/problems/goat-latin/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.

We would like to convert the sentence to &#34;Goat Latin&#34; (a made-up language similar to Pig Latin.)

The rules of Goat Latin are as follows:

If a word begins with a vowel (a, e, i, o, or u), append &#34;ma&#34; to the end of the word.
For example, the word &#39;apple&#39; becomes &#39;applema&#39;.

If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add &#34;ma&#34;.
For example, the word &#34;goat&#34; becomes &#34;oatgma&#34;.

Add one letter &#39;a&#39; to the end of each word per its word index in the sentence, starting with 1.
For example, the first word gets &#34;a&#34; added to the end, the second word gets &#34;aa&#34; added to the end and so on.
Return the final sentence representing the conversion from S to Goat Latin.



Example 1:

Input: &#34;I speak Goat Latin&#34;
Output: &#34;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&#34;
Example 2:

Input: &#34;The quick brown fox jumped over the lazy dog&#34;
Output: &#34;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&#34;


Notes:

S contains only uppercase, lowercase and spaces. Exactly one space between each word.
1 &lt;= S.length &lt;= 150.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Interesting one-liner</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">toGoatLatin</span>(self, S: str) <span style="color:#f92672">-&gt;</span> str:
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39; &#39;</span><span style="color:#f92672">.</span>join([(<span style="color:#66d9ef">lambda</span> w: w[<span style="color:#ae81ff">1</span>:]<span style="color:#f92672">+</span>w[<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">if</span> w[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> <span style="color:#e6db74">&#39;aeiouAEIOU&#39;</span> <span style="color:#66d9ef">else</span> w)(w) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;ma&#39;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;a&#39;</span> <span style="color:#f92672">*</span> i <span style="color:#66d9ef">for</span> i, w <span style="color:#f92672">in</span> enumerate(S<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39; &#39;</span>), <span style="color:#ae81ff">1</span>)])
</code></pre></div><h2 id="114-flatten-binary-tree-to-linked-list">114 - Flatten Binary Tree to Linked List</h2>
<p><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, flatten it to a linked list in-place.

For example, given the following tree:

    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre></div><h3 id="solution">Solution</h3>
<ol>
<li>Traverse the tree in reverse preorder, the opposite of root-left-right.</li>
<li>Save the root, and use it in the upper level.</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">flatten</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> None:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Do not return anything, modify root in-place instead.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>pre <span style="color:#f92672">=</span> None
        self<span style="color:#f92672">.</span>dfs(root)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, root):

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span>

        self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>right)
        self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>left)

        root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>pre
        self<span style="color:#f92672">.</span>pre <span style="color:#f92672">=</span> root
        root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> None
</code></pre></div><h2 id="368-largest-divisible-subset">368 - Largest Divisible Subset</h2>
<p><a href="https://leetcode.com/problems/largest-divisible-subset/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies:

Si % Sj = 0 or Sj % Si = 0.

If there are multiple solutions, return any subset is fine.

Example 1:

Input: [1,2,3]
Output: [1,2] (of course, [1,3] will also be ok)

Example 2:

Input: [1,2,4,8]
Output: [1,2,4,8]
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-dp">Solution 1: DP</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">largestDivisibleSubset</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> List[int]:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nums:
            <span style="color:#66d9ef">return</span> nums
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> len(nums)
        pre <span style="color:#f92672">=</span> [i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums))]
        nums<span style="color:#f92672">.</span>sort()

        max_i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(dp)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i):
                <span style="color:#66d9ef">if</span> nums[i] <span style="color:#f92672">%</span> nums[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> dp[j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> dp[i]:
                    dp[i] <span style="color:#f92672">=</span> dp[j] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    pre[i] <span style="color:#f92672">=</span> j

                <span style="color:#66d9ef">if</span> dp[i] <span style="color:#f92672">&gt;</span> dp[max_i]:
                    max_i <span style="color:#f92672">=</span> i

        ans <span style="color:#f92672">=</span> []
        i <span style="color:#f92672">=</span> max_i
        <span style="color:#66d9ef">while</span> pre[i] <span style="color:#f92672">!=</span> i:
            ans<span style="color:#f92672">.</span>append(nums[i])
            i <span style="color:#f92672">=</span> pre[i]
        ans<span style="color:#f92672">.</span>append(nums[i])

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h4 id="solution-2-hash">Solution 2: Hash</h4>
<ol>
<li>Sort the numbers</li>
<li>Store the answers for every number while go through the numbers</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">largestDivisibleSubset</span>(self, nums):
        S <span style="color:#f92672">=</span> {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>: set()}
        H <span style="color:#f92672">=</span> {}
        <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> sorted(nums):
            H[n] <span style="color:#f92672">=</span> max((H[d] <span style="color:#66d9ef">for</span> d <span style="color:#f92672">in</span> S <span style="color:#66d9ef">if</span> x <span style="color:#f92672">%</span> d <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>), key<span style="color:#f92672">=</span>len) <span style="color:#f92672">|</span> {n}
        <span style="color:#66d9ef">return</span> list(max(S<span style="color:#f92672">.</span>values(), key<span style="color:#f92672">=</span>len))
</code></pre></div><h2 id="784-letter-case-permutation">784 - Letter Case Permutation</h2>
<p><a href="https://leetcode.com/problems/letter-case-permutation/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string.

Return a list of all possible strings we could create. You can return the output  in any order.



Example 1:

Input: S = &#34;a1b2&#34;
Output: [&#34;a1b2&#34;,&#34;a1B2&#34;,&#34;A1b2&#34;,&#34;A1B2&#34;]
Example 2:

Input: S = &#34;3z4&#34;
Output: [&#34;3z4&#34;,&#34;3Z4&#34;]
Example 3:

Input: S = &#34;12345&#34;
Output: [&#34;12345&#34;]
Example 4:

Input: S = &#34;0&#34;
Output: [&#34;0&#34;]


Constraints:

S will be a string with length between 1 and 12.
S will consist only of letters or digits.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">letterCasePermutation</span>(self, S: str) <span style="color:#f92672">-&gt;</span> List[str]:
        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(S, <span style="color:#ae81ff">0</span>, ans, [])
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, S, i, ans, path):
        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> len(S):
            ans<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(path))
            <span style="color:#66d9ef">return</span>

        self<span style="color:#f92672">.</span>dfs(S, i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, ans, path <span style="color:#f92672">+</span> [S[i]])

        <span style="color:#66d9ef">if</span> S[i]<span style="color:#f92672">.</span>isalpha():
            self<span style="color:#f92672">.</span>dfs(S, i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, ans, path <span style="color:#f92672">+</span> [S[i]<span style="color:#f92672">.</span>swapcase()])
</code></pre></div><h2 id="1079-letter-tile-possibilities">1079 - Letter Tile Possibilities</h2>
<p><a href="https://leetcode.com/problems/letter-tile-possibilities/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You have n  tiles, where each tile has one letter tiles[i] printed on it.

Return the number of possible non-empty sequences of letters you can make using the letters printed on those tiles.



Example 1:

Input: tiles = &#34;AAB&#34;
Output: 8
Explanation: The possible sequences are &#34;A&#34;, &#34;B&#34;, &#34;AA&#34;, &#34;AB&#34;, &#34;BA&#34;, &#34;AAB&#34;, &#34;ABA&#34;, &#34;BAA&#34;.
Example 2:

Input: tiles = &#34;AAABBC&#34;
Output: 188
Example 3:

Input: tiles = &#34;V&#34;
Output: 1


Constraints:

1 &lt;= tiles.length &lt;= 7
tiles consists of uppercase English letters.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numTilePossibilities</span>(self, tiles: str) <span style="color:#f92672">-&gt;</span> int:
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        mark <span style="color:#f92672">=</span> [False] <span style="color:#f92672">*</span> len(tiles)
        self<span style="color:#f92672">.</span>dfs(sorted(tiles), mark)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, tiles, mark):
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(tiles)):
            <span style="color:#66d9ef">if</span> mark[i] <span style="color:#f92672">or</span> (i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> tiles[i] <span style="color:#f92672">==</span> tiles[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> mark[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]):
                <span style="color:#66d9ef">continue</span>
            mark[i] <span style="color:#f92672">=</span> True
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            self<span style="color:#f92672">.</span>dfs(tiles, mark)
            mark[i] <span style="color:#f92672">=</span> False
</code></pre></div><h2 id="516-longest-palindromic-subsequence">516 - Longest Palindromic Subsequence</h2>
<p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string s, find the longest palindromic subsequence&#39;s length in s. You may assume that the maximum length of s is 1000.

Example 1:
Input:

&#34;bbbab&#34;
Output:
4
One possible longest palindromic subsequence is &#34;bbbb&#34;.


Example 2:
Input:

&#34;cbbd&#34;
Output:
2
One possible longest palindromic subsequence is &#34;bb&#34;.


Constraints:

1 &lt;= s.length &lt;= 1000
s consists only of lowercase English letters.
</code></pre></div><h3 id="solution">Solution</h3>
<p>DP problem.</p>
<p>dp[i][j] represents the max value for substring from j to i.</p>
<p>Transition:</p>
<p>if s[i] == s[j]: dp[i][j] = dp[i-1][j+1] + 2
else: dp[i][j] = max(dp[i-1][j] + dp[i][j+1])</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestPalindromeSubseq</span>(self, s: str) <span style="color:#f92672">-&gt;</span> int:
        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> len(s) <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s))]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(s)):
            dp[i][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> s[i] <span style="color:#f92672">==</span> s[j]:
                    dp[i][j] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>
                <span style="color:#66d9ef">else</span>:
                    dp[i][j] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j], dp[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])
        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#66d9ef">if</span> s <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h2 id="1032-stream-of-characters">1032 - Stream of Characters</h2>
<p><a href="https://leetcode.com/problems/stream-of-characters/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Implement the StreamChecker class as follows:

StreamChecker(words): Constructor, init the data structure with the given words.
query(letter): returns true if and only if for some k &gt;= 1, the last k characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list.


Example:

StreamChecker streamChecker = new StreamChecker([&#34;cd&#34;,&#34;f&#34;,&#34;kl&#34;]); // init the dictionary.
streamChecker.query(&#39;a&#39;);          // return false
streamChecker.query(&#39;b&#39;);          // return false
streamChecker.query(&#39;c&#39;);          // return false
streamChecker.query(&#39;d&#39;);          // return true, because &#39;cd&#39; is in the wordlist
streamChecker.query(&#39;e&#39;);          // return false
streamChecker.query(&#39;f&#39;);          // return true, because &#39;f&#39; is in the wordlist
streamChecker.query(&#39;g&#39;);          // return false
streamChecker.query(&#39;h&#39;);          // return false
streamChecker.query(&#39;i&#39;);          // return false
streamChecker.query(&#39;j&#39;);          // return false
streamChecker.query(&#39;k&#39;);          // return false
streamChecker.query(&#39;l&#39;);          // return true, because &#39;kl&#39; is in the wordlist


Note:

1 &lt;= words.length &lt;= 2000
1 &lt;= words[i].length &lt;= 2000
Words will only consist of lowercase English letters.
Queries will only consist of lowercase English letters.
The number of queries is at most 40000.
</code></pre></div><h3 id="solution">Solution</h3>
<p>It&rsquo;s clearly a trie problem. But how to optimize it?</p>
<p>We must keep trace of the stream, and try to search the every pattern in the trace.
But that would be LTE.</p>
<p>In order not to loop through every starting point of the trace, we do it reversely, so we only need to start from the beginning once and stop for the existing word.</p>
<p>For example:</p>
<p>[&ldquo;dlab&rdquo;, &ldquo;xlab&rdquo;]</p>
<p>Create a reversed trie [&ldquo;bald&rdquo;, &ldquo;balx&rdquo;]</p>
<p>trace = &ldquo;&rdquo;, max length of trace = 4, because, all words in the trie are not longer than 4.</p>
<p>&ldquo;b&rdquo;: trace = &ldquo;b&rdquo;, search for &ldquo;b&rdquo; in the trie, False
&ldquo;a&rdquo;: trace = &ldquo;ba&rdquo;, search for &ldquo;ba&rdquo; in the trie, False
&ldquo;l&rdquo;: trace = &ldquo;bal&rdquo;, search for &ldquo;bal&rdquo; in the trie, False
&ldquo;d&rdquo;: trace = &ldquo;bald&rdquo;,  search for &ldquo;bald&rdquo; in the trie, True
&ldquo;x&rdquo;: trace = &ldquo;aldx&rdquo;, search for &ldquo;aldx&rdquo; in the trie, False</p>
<p>Steps:</p>
<ol>
<li>create the trie with reversed words</li>
<li>keep the track of the stream with a max possible length</li>
<li>search the track of the stream in the &ldquo;reversed&rdquo; trie.</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StreamChecker</span>:

    <span style="color:#66d9ef">def</span> __init__(self, words: List[str]):
        self<span style="color:#f92672">.</span>root <span style="color:#f92672">=</span> TrieNode()

        <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> words:
            x <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>root
            <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> reversed(w):
                <span style="color:#66d9ef">if</span> c <span style="color:#f92672">in</span> x<span style="color:#f92672">.</span>children:
                    x <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>children[c]
                <span style="color:#66d9ef">else</span>:
                    x<span style="color:#f92672">.</span>children[c] <span style="color:#f92672">=</span> TrieNode()
                    x <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>children[c]
            x<span style="color:#f92672">.</span>is_word <span style="color:#f92672">=</span> True

        self<span style="color:#f92672">.</span>s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
        self<span style="color:#f92672">.</span>w <span style="color:#f92672">=</span> max(map(len, words))

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">query</span>(self, letter: str) <span style="color:#f92672">-&gt;</span> bool:

        self<span style="color:#f92672">.</span>s <span style="color:#f92672">=</span> (letter<span style="color:#f92672">+</span>self<span style="color:#f92672">.</span>s)[:self<span style="color:#f92672">.</span>w]
        x <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>root
        res <span style="color:#f92672">=</span> False

        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>s:
            <span style="color:#66d9ef">if</span> c <span style="color:#f92672">in</span> x<span style="color:#f92672">.</span>children:
                x <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>children[c]
                <span style="color:#66d9ef">if</span> x<span style="color:#f92672">.</span>is_word:
                    <span style="color:#66d9ef">return</span> True
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">return</span> res


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TrieNode</span>:
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>children <span style="color:#f92672">=</span> {}
        self<span style="color:#f92672">.</span>is_word <span style="color:#f92672">=</span> False
</code></pre></div><p>Simplified Version</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> collections
<span style="color:#f92672">from</span> functools <span style="color:#f92672">import</span> reduce

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StreamChecker</span>:
    <span style="color:#66d9ef">def</span> __init__(self, words):
        T <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span>: collections<span style="color:#f92672">.</span>defaultdict(T)
        self<span style="color:#f92672">.</span>trie <span style="color:#f92672">=</span> T()
        <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> words: reduce(dict<span style="color:#f92672">.</span>__getitem__, w[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], self<span style="color:#f92672">.</span>trie)[<span style="color:#e6db74">&#34;#&#34;</span>] <span style="color:#f92672">=</span> True
        self<span style="color:#f92672">.</span>s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
        self<span style="color:#f92672">.</span>w <span style="color:#f92672">=</span> max(map(len, words))

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">query</span>(self, letter):
        self<span style="color:#f92672">.</span>s <span style="color:#f92672">=</span> (letter <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>s)[:self<span style="color:#f92672">.</span>w]
        cur <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>trie
        <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>s:
            <span style="color:#66d9ef">if</span> c <span style="color:#f92672">in</span> cur:
                cur <span style="color:#f92672">=</span> cur[c]
                <span style="color:#66d9ef">if</span> c[<span style="color:#e6db74">&#34;#&#34;</span>] <span style="color:#f92672">==</span> True:
                    <span style="color:#66d9ef">return</span> True
            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">break</span>

        <span style="color:#66d9ef">return</span> False
</code></pre></div><h2 id="199-binary-tree-right-side-view">199 - Binary Tree Right Side View</h2>
<p><a href="https://leetcode.com/problems/binary-tree-right-side-view/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

Example:

Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:

   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---
</code></pre></div><h3 id="solution">Solution</h3>
<p>Comprare the depth. DFS.</p>
<p>Keep track of the current depth.
And the length of current answer is the previous depth.</p>
<p>Traverse right to left</p>
<p>If current_depth &gt; previous depth, then it appears in the right view.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rightSideView</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> List[int]:
        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span><span style="color:#66d9ef">print</span>(root, ans, <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">print</span>(self, root, ans, depth):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">if</span> depth <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> len(ans): ans<span style="color:#f92672">.</span>append(root<span style="color:#f92672">.</span>val)

        self<span style="color:#f92672">.</span><span style="color:#66d9ef">print</span>(root<span style="color:#f92672">.</span>right, ans, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
        self<span style="color:#f92672">.</span><span style="color:#66d9ef">print</span>(root<span style="color:#f92672">.</span>left, ans, depth<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</code></pre></div><h2 id="1219-path-with-maximum-gold">1219 - Path with Maximum Gold</h2>
<p><a href="https://leetcode.com/problems/path-with-maximum-gold/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">In a gold mine grid of size m * n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.

Return the maximum amount of gold you can collect under the conditions:

Every time you are located in a cell you will collect all the gold in that cell.
From your position you can walk one step to the left, right, up or down.
You can&#39;t visit the same cell more than once.
Never visit a cell with 0 gold.
You can start and stop collecting gold from any position in the grid that has some gold.


Example 1:

Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
Output: 24
Explanation:
[[0,6,0],
 [5,8,7],
 [0,9,0]]
Path to get the maximum gold, 9 -&gt; 8 -&gt; 7.
Example 2:

Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
Output: 28
Explanation:
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
Path to get the maximum gold, 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getMaximumGold</span>(self, grid: List[List[int]]) <span style="color:#f92672">-&gt;</span> int:
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        mark <span style="color:#f92672">=</span> [[False] <span style="color:#f92672">*</span> len(grid[<span style="color:#ae81ff">0</span>]) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> grid]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(grid)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(grid[<span style="color:#ae81ff">0</span>])):
                self<span style="color:#f92672">.</span>dfs(grid, i, j, mark, <span style="color:#ae81ff">0</span>)

        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, grid, i, j, mark, gold):

        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">==</span> len(grid) <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">==</span> len(grid[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">or</span> mark[i][j] <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> grid[i][j]:
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> max(self<span style="color:#f92672">.</span>ans, gold)
            <span style="color:#66d9ef">return</span>

        mark[i][j] <span style="color:#f92672">=</span> True

        <span style="color:#66d9ef">for</span> di, dj <span style="color:#f92672">in</span> [[<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]:
            self<span style="color:#f92672">.</span>dfs(grid, i<span style="color:#f92672">+</span>di, j<span style="color:#f92672">+</span>dj, mark, gold<span style="color:#f92672">+</span>grid[i][j])

        mark[i][j] <span style="color:#f92672">=</span> False
</code></pre></div><h2 id="404-sum-of-left-leaves">404 - Sum of Left Leaves</h2>
<p><a href="https://leetcode.com/problems/sum-of-left-leaves/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Find the sum of all left leaves in a given binary tree.

Example:

    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sumOfLeftLeaves</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>dfs(root, <span style="color:#ae81ff">0</span>, False)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, root, presum, isLeft):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">and</span> isLeft:
            <span style="color:#66d9ef">return</span> presum <span style="color:#f92672">+</span> root<span style="color:#f92672">.</span>val
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>left, presum, True) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>dfs(root<span style="color:#f92672">.</span>right, presum, False)
</code></pre></div><h2 id="131-palindrome-partitioning">131 - Palindrome Partitioning</h2>
<p><a href="https://leetcode.com/problems/palindrome-partitioning/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: &#34;aab&#34;
Output:
[
  [&#34;aa&#34;,&#34;b&#34;],
  [&#34;a&#34;,&#34;a&#34;,&#34;b&#34;]
]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">partition</span>(self, s: str) <span style="color:#f92672">-&gt;</span> List[List[str]]:
        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(s, <span style="color:#ae81ff">0</span>, ans, [])
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, s, start, ans, path):

        <span style="color:#66d9ef">if</span> start <span style="color:#f92672">==</span> len(s):
            ans<span style="color:#f92672">.</span>append(path<span style="color:#f92672">.</span>copy())
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(start, len(s)):
            w <span style="color:#f92672">=</span> s[start:i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]
            <span style="color:#66d9ef">if</span> w <span style="color:#f92672">==</span> w[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                path<span style="color:#f92672">.</span>append(w)
                self<span style="color:#f92672">.</span>dfs(s, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, ans, path)
                path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="132-palindrome-partitioning-ii">132 - Palindrome Partitioning II</h2>
<p><a href="https://leetcode.com/problems/palindrome-partitioning-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string s, partition s such that every substring of the partition is a palindrome

Return the minimum cuts needed for a palindrome partitioning of s.

Example 1:

Input: s = &#34;aab&#34;
Output: 1
Explanation: The palindrome partitioning [&#34;aa&#34;,&#34;b&#34;] could be produced using 1 cut.
Example 2:

Input: s = &#34;a&#34;
Output: 0
Example 3:

Input: s = &#34;ab&#34;
Output: 1


Constraints:

1 &lt;= s.length &lt;= 2000
s consists of lower-case English letters only.
</code></pre></div><h3 id="solution">Solution</h3>
<p>If s[i:j+1] is a palindrome, and if we know s[0:i] has a minCut of X, then we know minCut to for s[0:j+1] is not greater than X+1.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minCut</span>(self, s: str) <span style="color:#f92672">-&gt;</span> int:
        cut <span style="color:#f92672">=</span> [x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, len(s))]
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s)):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i, len(s)):
                <span style="color:#66d9ef">if</span> s[i:j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> s[i:j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                    cut[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> min(cut[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], cut[i]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">return</span> cut[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="983-minimum-cost-for-tickets">983 - Minimum Cost For Tickets</h2>
<p><a href="https://leetcode.com/problems/minimum-cost-for-tickets/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.

Train tickets are sold in 3 different ways:

a 1-day pass is sold for costs[0] dollars;
a 7-day pass is sold for costs[1] dollars;
a 30-day pass is sold for costs[2] dollars.
The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.

Return the minimum number of dollars you need to travel every day in the given list of days.



Example 1:

Input: days = [1,4,6,7,8,20], costs = [2,7,15]
Output: 11
Explanation:
For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total you spent $11 and covered all the days of your travel.
Example 2:

Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
Output: 17
Explanation:
For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total you spent $17 and covered all the days of your travel.
</code></pre></div><h3 id="solution">Solution</h3>
<p>DP problem. dp[i] represents the min cost for ith day.</p>
<p>We have four options for one day.</p>
<ol>
<li>
<p>We don&rsquo;t travel:
dp[i] = dp[i-1]</p>
</li>
<li>
<p>We have to travel:</p>
<p>a. buy 1-day ticket: dp[i] = dp[i-1] + costs[0]
b. buy 7-days ticket which can cover ith day: dp[i] = min(dp[i-1], dp[i-2], dp[i-3], &hellip; dp[i-7]) + costs[1]
c. buy 30-days ticket which can cover ith day: dp[i] = min(dp[i-1], dp[i-2], &hellip; dp[i-30]) + costs[2]</p>
</li>
</ol>
<p>Important is to know, the min cost is always increasing.</p>
<p>So min(dp[i-1], dp[i-2]&hellip; dp[i-7]) = dp[i-7]</p>
<p>dp[i] = min(dp[i-1] + costs[0], dp[i-7] + costs[0], dp[i-30] + costs[0])</p>
<p>Note that, i-7 and i-30 might smaller than 0 in the loop. Use max(0, i-7) to avoid that.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mincostTickets</span>(self, days: List[int], costs: List[int]) <span style="color:#f92672">-&gt;</span> int:
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (max(days)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(dp)):
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> days:
                dp[i] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
            <span style="color:#66d9ef">else</span>:
                dp[i] <span style="color:#f92672">=</span> min(dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>costs[<span style="color:#ae81ff">0</span>], dp[max(<span style="color:#ae81ff">0</span>, i<span style="color:#f92672">-</span><span style="color:#ae81ff">7</span>)] <span style="color:#f92672">+</span> costs[<span style="color:#ae81ff">1</span>], dp[max(<span style="color:#ae81ff">0</span>, i<span style="color:#f92672">-</span><span style="color:#ae81ff">30</span>)] <span style="color:#f92672">+</span> costs[<span style="color:#ae81ff">2</span>])

        <span style="color:#66d9ef">return</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</code></pre></div><h2 id="412-fizz-buzz">412 - Fizz Buzz</h2>
<p><a href="https://leetcode.com/problems/fizz-buzz/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Write a program that outputs the string representation of numbers from 1 to n.

But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.

Example:

n = 15,

Return:
[
    &#34;1&#34;,
    &#34;2&#34;,
    &#34;Fizz&#34;,
    &#34;4&#34;,
    &#34;Buzz&#34;,
    &#34;Fizz&#34;,
    &#34;7&#34;,
    &#34;8&#34;,
    &#34;Fizz&#34;,
    &#34;Buzz&#34;,
    &#34;11&#34;,
    &#34;Fizz&#34;,
    &#34;13&#34;,
    &#34;14&#34;,
    &#34;FizzBuzz&#34;
]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fizzBuzz</span>(self, n: int) <span style="color:#f92672">-&gt;</span> List[str]:
        ans <span style="color:#f92672">=</span> []

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span>:
                ans<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;FizzBuzz&#34;</span>)
            <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">5</span>:
                ans<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;Buzz&#34;</span>)
            <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">3</span>:
                ans<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;Fizz&#34;</span>)
            <span style="color:#66d9ef">else</span>:
                ans<span style="color:#f92672">.</span>append(str(i))

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="1286-iterator-for-combination">1286 - Iterator for Combination</h2>
<p><a href="https://leetcode.com/problems/iterator-for-combination/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Design an Iterator class, which has:

A constructor that takes a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments.
A function next() that returns the next combination of length combinationLength in lexicographical order.
A function hasNext() that returns True if and only if there exists a next combination.


Example:

CombinationIterator iterator = new CombinationIterator(&#34;abc&#34;, 2); // creates the iterator.

iterator.next(); // returns &#34;ab&#34;
iterator.hasNext(); // returns true
iterator.next(); // returns &#34;ac&#34;
iterator.hasNext(); // returns true
iterator.next(); // returns &#34;bc&#34;
iterator.hasNext(); // returns false


Constraints:

1 &lt;= combinationLength &lt;= characters.length &lt;= 15
There will be at most 10^4 function calls per test.
It&#39;s guaranteed that all calls of the function next are valid.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-dfs-to-generate-the-bit-mask">Solution 1: DFS to generate the bit mask</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CombinationIterator</span>:

    <span style="color:#66d9ef">def</span> __init__(self, characters: str, combinationLength: int):
        self<span style="color:#f92672">.</span>bitmasks <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>characters <span style="color:#f92672">=</span> characters
        self<span style="color:#f92672">.</span>combinationLength <span style="color:#f92672">=</span> combinationLength
        self<span style="color:#f92672">.</span>dfs(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, [])
        <span style="color:#66d9ef">print</span>(self<span style="color:#f92672">.</span>bitmasks)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">next</span>(self) <span style="color:#f92672">-&gt;</span> str:
        ans <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
        mask <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bitmasks<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(mask)):
            <span style="color:#66d9ef">if</span> mask[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>:
                ans <span style="color:#f92672">+=</span> self<span style="color:#f92672">.</span>characters[i]
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hasNext</span>(self) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>bitmasks <span style="color:#f92672">!=</span> []

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, count, index, path):

        <span style="color:#66d9ef">if</span> index <span style="color:#f92672">==</span> len(self<span style="color:#f92672">.</span>characters):
            <span style="color:#66d9ef">if</span> count <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>combinationLength:
                self<span style="color:#f92672">.</span>bitmasks<span style="color:#f92672">.</span>append(list(path))
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> [<span style="color:#e6db74">&#34;1&#34;</span>, <span style="color:#e6db74">&#34;0&#34;</span>]:
            <span style="color:#66d9ef">if</span> count <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>combinationLength <span style="color:#f92672">and</span> i <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>:
                <span style="color:#66d9ef">continue</span>

            path<span style="color:#f92672">.</span>append(i)
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>:
                self<span style="color:#f92672">.</span>dfs(count<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, path)
            <span style="color:#66d9ef">else</span>:
                self<span style="color:#f92672">.</span>dfs(count, index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, path)

            path<span style="color:#f92672">.</span>pop()
</code></pre></div><h4 id="solution-2-generate-the-bismask-iteratively">Solution 2: Generate the bismask iteratively</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CombinationIterator</span>:
    <span style="color:#66d9ef">def</span> __init__(self, characters: str, combinationLength: int):
        self<span style="color:#f92672">.</span>characters <span style="color:#f92672">=</span> characters
        self<span style="color:#f92672">.</span>combinationLength <span style="color:#f92672">=</span> combinationLength
        self<span style="color:#f92672">.</span>bitmasks <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> mask <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> len(characters)):
            <span style="color:#66d9ef">if</span> bin(mask)<span style="color:#f92672">.</span>count(<span style="color:#e6db74">&#39;1&#39;</span>) <span style="color:#f92672">==</span> self<span style="color:#f92672">.</span>combinationLength:
                res <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
                <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(characters)):
                    res <span style="color:#f92672">=</span> str(mask<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">+</span> res
                    mask <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>
                self<span style="color:#f92672">.</span>bitmasks<span style="color:#f92672">.</span>append(res)
        self<span style="color:#f92672">.</span>bitmasks <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bitmasks[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]


    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">next</span>(self) <span style="color:#f92672">-&gt;</span> str:
        ans <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
        mask <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bitmasks<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(mask)):
            <span style="color:#66d9ef">if</span> mask[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;1&#34;</span>:
                ans <span style="color:#f92672">+=</span> self<span style="color:#f92672">.</span>characters[i]
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hasNext</span>(self) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>bitmasks <span style="color:#f92672">!=</span> []
</code></pre></div><h2 id="93-restore-ip-addresses">93 - Restore IP Addresses</h2>
<p><a href="https://leetcode.com/problems/restore-ip-addresses/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string s containing only digits. Return all possible valid IP addresses that can be obtained from s. You can return them in any order.

A valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single points and cannot have leading zeros. For example, &#34;0.1.2.201&#34; and &#34;192.168.1.1&#34; are valid IP addresses and &#34;0.011.255.245&#34;, &#34;192.168.1.312&#34; and &#34;192.168@1.1&#34; are invalid IP addresses.



Example 1:

Input: s = &#34;25525511135&#34;
Output: [&#34;255.255.11.135&#34;,&#34;255.255.111.35&#34;]
Example 2:

Input: s = &#34;0000&#34;
Output: [&#34;0.0.0.0&#34;]
Example 3:

Input: s = &#34;1111&#34;
Output: [&#34;1.1.1.1&#34;]
Example 4:

Input: s = &#34;010010&#34;
Output: [&#34;0.10.0.10&#34;,&#34;0.100.1.0&#34;]
Example 5:

Input: s = &#34;101023&#34;
Output: [&#34;1.0.10.23&#34;,&#34;1.0.102.3&#34;,&#34;10.1.0.23&#34;,&#34;10.10.2.3&#34;,&#34;101.0.2.3&#34;]


Constraints:

0 &lt;= s.length &lt;= 3000
s consists of digits only.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">restoreIpAddresses</span>(self, s: str) <span style="color:#f92672">-&gt;</span> List[str]:
        <span style="color:#66d9ef">if</span> len(s) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">12</span>:
            <span style="color:#66d9ef">return</span> []

        ans <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(s, <span style="color:#ae81ff">0</span>, ans, [])
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, s, start, ans, path):
        <span style="color:#66d9ef">if</span> start <span style="color:#f92672">&gt;=</span> len(s):
            <span style="color:#66d9ef">if</span> len(path) <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>:
                ans<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;.&#34;</span><span style="color:#f92672">.</span>join(path))
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(start, min(len(s), start<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>)):
            number <span style="color:#f92672">=</span> s[start:i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
            <span style="color:#66d9ef">if</span> len(number) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> number[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;0&#34;</span>:
                <span style="color:#66d9ef">continue</span>

            <span style="color:#66d9ef">if</span> int(number) <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">255</span>:
                path<span style="color:#f92672">.</span>append(number)
                self<span style="color:#f92672">.</span>dfs(s, i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, ans, path)
                path<span style="color:#f92672">.</span>pop()
</code></pre></div><h2 id="436-find-right-interval">436 - Find Right Interval</h2>
<p><a href="https://leetcode.com/problems/find-right-interval/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the &#34;right&#34; of i.

For any interval i, you need to store the minimum interval j&#39;s index, which means that the interval j has the minimum start point to build the &#34;right&#34; relationship for interval i. If the interval j doesn&#39;t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array.

Note:

You may assume the interval&#39;s end point is always bigger than its start point.
You may assume none of these intervals have the same start point.


Example 1:

Input: [ [1,2] ]

Output: [-1]

Explanation: There is only one interval in the collection, so it outputs -1.


Example 2:

Input: [ [3,4], [2,3], [1,2] ]

Output: [-1, 0, 1]

Explanation: There is no satisfied &#34;right&#34; interval for [3,4].
For [2,3], the interval [3,4] has minimum-&#34;right&#34; start point;
For [1,2], the interval [2,3] has minimum-&#34;right&#34; start point.


Example 3:

Input: [ [1,4], [2,3], [3,4] ]

Output: [-1, 2, -1]

Explanation: There is no satisfied &#34;right&#34; interval for [1,4] and [3,4].
For [2,3], the interval [3,4] has minimum-&#34;right&#34; start point.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findRightInterval</span>(self, intervals: List[List[int]]) <span style="color:#f92672">-&gt;</span> List[int]:
        starts <span style="color:#f92672">=</span> sorted([[a[<span style="color:#ae81ff">0</span>], i] <span style="color:#66d9ef">for</span> i, a <span style="color:#f92672">in</span> enumerate(intervals)]) <span style="color:#f92672">+</span> [[float(<span style="color:#e6db74">&#39;inf&#39;</span>), <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]
        <span style="color:#66d9ef">return</span> [starts[bisect<span style="color:#f92672">.</span>bisect(starts, [x[<span style="color:#ae81ff">1</span>]])][<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> intervals]
</code></pre></div><h2 id="980-unique-paths-iii">980 - Unique Paths III</h2>
<p><a href="https://leetcode.com/problems/unique-paths-iii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">On a 2-dimensional grid, there are 4 types of squares:

1 represents the starting square.  There is exactly one starting square.
2 represents the ending square.  There is exactly one ending square.
0 represents empty squares we can walk over.
-1 represents obstacles that we cannot walk over.
Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.



Example 1:

Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
Output: 2
Explanation: We have the following two paths:
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
Example 2:

Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]
Output: 4
Explanation: We have the following four paths:
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
Example 3:

Input: [[0,1],[2,0]]
Output: 0
Explanation:
There is no path that walks over every empty square exactly once.
Note that the starting and ending square can be anywhere in the grid.


Note:

1 &lt;= grid.length * grid[0].length &lt;= 20
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">uniquePathsIII</span>(self, grid: List[List[int]]) <span style="color:#f92672">-&gt;</span> int:
        count <span style="color:#f92672">=</span> len([x <span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> grid <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> r <span style="color:#66d9ef">if</span> x <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>
        start <span style="color:#f92672">=</span> [[i,j] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(grid)) <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(len(grid[<span style="color:#ae81ff">0</span>])) <span style="color:#66d9ef">if</span> grid[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        self<span style="color:#f92672">.</span>dfs(grid, start[<span style="color:#ae81ff">0</span>], start[<span style="color:#ae81ff">1</span>], <span style="color:#ae81ff">0</span>, count)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, grid, i, j, curCount, count):

        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> i <span style="color:#f92672">&gt;=</span> len(grid) <span style="color:#f92672">or</span> j <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> j <span style="color:#f92672">&gt;=</span> len(grid[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">or</span> grid[i][j] <span style="color:#f92672">in</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">100</span>]:
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">if</span> curCount <span style="color:#f92672">==</span> count<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> grid[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">return</span>
        <span style="color:#66d9ef">elif</span> grid[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
            <span style="color:#66d9ef">return</span>

        x <span style="color:#f92672">=</span> grid[i][j]
        grid[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
        <span style="color:#66d9ef">for</span> di, dj <span style="color:#f92672">in</span> [[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>], [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>]]:
            self<span style="color:#f92672">.</span>dfs(grid, i<span style="color:#f92672">+</span>di, j<span style="color:#f92672">+</span>dj, curCount<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, count)

        grid[i][j] <span style="color:#f92672">=</span> x
</code></pre></div><h2 id="450-delete-node-in-a-bst">450 - Delete Node in a BST</h2>
<p><a href="https://leetcode.com/problems/delete-node-in-a-bst/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Design an Iterator class, which has:

A constructor that takes a string characters of sorted distinct lowercase English letters and a number combinationLength as arguments.
A function next() that returns the next combination of length combinationLength in lexicographical order.
A function hasNext() that returns True if and only if there exists a next combination.


Example:

CombinationIterator iterator = new CombinationIterator(&#34;abc&#34;, 2); // creates the iterator.

iterator.next(); // returns &#34;ab&#34;
iterator.hasNext(); // returns true
iterator.next(); // returns &#34;ac&#34;
iterator.hasNext(); // returns true
iterator.next(); // returns &#34;bc&#34;
iterator.hasNext(); // returns false


Constraints:

1 &lt;= combinationLength &lt;= characters.length &lt;= 15
There will be at most 10^4 function calls per test.
It&#39;s guaranteed that all calls of the function next are valid.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">deleteNode</span>(self, root: TreeNode, key: int) <span style="color:#f92672">-&gt;</span> TreeNode:

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> None

        <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">&gt;</span> key:
            root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>deleteNode(root<span style="color:#f92672">.</span>left, key)
        <span style="color:#66d9ef">elif</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">&lt;</span> key:
            root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>deleteNode(root<span style="color:#f92672">.</span>right, key)
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left:
                root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>right
            <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right:
                root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left
            <span style="color:#66d9ef">else</span>:
                node <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>getMin(root<span style="color:#f92672">.</span>right)
                node<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left
                root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>right

        <span style="color:#66d9ef">return</span> root

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getMin</span>(self, root):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> None

        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>getMin(root<span style="color:#f92672">.</span>left) <span style="color:#f92672">or</span> root
</code></pre></div><h2 id="526-beautiful-arrangement">526 - Beautiful Arrangement</h2>
<p><a href="https://leetcode.com/problems/beautiful-arrangement/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 &lt;= i &lt;= N) in this array:

The number at the ith position is divisible by i.
i is divisible by the number at the ith position.


Now given N, how many beautiful arrangements can you construct?

Example 1:

Input: 2
Output: 2
Explanation:

The first beautiful arrangement is [1, 2]:

Number at the 1st position (i=1) is 1, and 1 is divisible by i (i=1).

Number at the 2nd position (i=2) is 2, and 2 is divisible by i (i=2).

The second beautiful arrangement is [2, 1]:

Number at the 1st position (i=1) is 2, and 2 is divisible by i (i=1).

Number at the 2nd position (i=2) is 1, and i (i=2) is divisible by 1.


Note:

N is a positive integer and will not exceed 15.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">countArrangement</span>(self, N: int) <span style="color:#f92672">-&gt;</span> int:
        self<span style="color:#f92672">.</span>ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        self<span style="color:#f92672">.</span>mark <span style="color:#f92672">=</span> [False <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]
        self<span style="color:#f92672">.</span>dfs(N, self<span style="color:#f92672">.</span>mark, [])
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, N, mark, path):
        <span style="color:#66d9ef">if</span> len(path) <span style="color:#f92672">==</span> N:
            self<span style="color:#f92672">.</span>ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, N<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            index <span style="color:#f92672">=</span> len(path) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">if</span> mark[n] <span style="color:#f92672">or</span> (n <span style="color:#f92672">%</span> index <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> index <span style="color:#f92672">%</span> n <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>):
                <span style="color:#66d9ef">continue</span>
            mark[n] <span style="color:#f92672">=</span> True
            self<span style="color:#f92672">.</span>dfs(N, self<span style="color:#f92672">.</span>mark, path <span style="color:#f92672">+</span> [n])
            mark[n] <span style="color:#f92672">=</span> False
</code></pre></div><h2 id="354-russian-doll-envelopes">354 - Russian Doll Envelopes</h2>
<p><a href="https://leetcode.com/problems/russian-doll-envelopes/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.

What is the maximum number of envelopes can you Russian doll? (put one inside other)

Note:
Rotation is not allowed.

Example:

Input: [[5,4],[6,4],[6,7],[2,3]]
Output: 3
Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxEnvelopes</span>(self, envelopes: List[List[int]]) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> envelopes:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        heights <span style="color:#f92672">=</span> [env[<span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">for</span> env <span style="color:#f92672">in</span> sorted(envelopes, key <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> x: [x[<span style="color:#ae81ff">0</span>], <span style="color:#f92672">-</span>x[<span style="color:#ae81ff">1</span>]])]
        <span style="color:#66d9ef">print</span>(heights)
        dp <span style="color:#f92672">=</span> [heights[<span style="color:#ae81ff">0</span>]]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(heights)):
            <span style="color:#66d9ef">if</span> heights[i] <span style="color:#f92672">&gt;</span> dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                dp<span style="color:#f92672">.</span>append(heights[i])
            <span style="color:#66d9ef">else</span>:
                l <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bs(dp, heights[i])

                dp[l] <span style="color:#f92672">=</span> heights[i]
        <span style="color:#66d9ef">return</span> len(dp)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bs</span>(self, dp, target):
        r <span style="color:#f92672">=</span> len(dp) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">while</span> l <span style="color:#f92672">&lt;=</span> r:
            mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">if</span> dp[mid] <span style="color:#f92672">&gt;</span> target:
                r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> dp[mid] <span style="color:#f92672">&lt;</span> target:
                l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

            <span style="color:#66d9ef">else</span>:
                <span style="color:#66d9ef">return</span> mid
        <span style="color:#66d9ef">return</span> l
</code></pre></div><h2 id="403-frog-jump">403 - Frog Jump</h2>
<p><a href="https://leetcode.com/problems/frog-jump/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.

Given a list of stones&#39; positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.

If the frog&#39;s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.

Note:

The number of stones is ≥ 2 and is &lt; 1,100.
Each stone&#39;s position will be a non-negative integer &lt; 231.
The first stone&#39;s position is always 0.
Example 1:

[0,1,3,5,6,8,12,17]

There are a total of 8 stones.
The first stone at the 0th unit, second stone at the 1st unit,
third stone at the 3rd unit, and so on...
The last stone at the 17th unit.

Return true. The frog can jump to the last stone by jumping
1 unit to the 2nd stone, then 2 units to the 3rd stone, then
2 units to the 4th stone, then 3 units to the 6th stone,
4 units to the 7th stone, and 5 units to the 8th stone.
Example 2:

[0,1,2,3,4,8,9,11]

Return false. There is no way to jump to the last stone as
the gap between the 5th and 6th stone is too large.
</code></pre></div><h3 id="solution">Solution</h3>
<p>DP problem.</p>
<p>states:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">dp[i][0]: k-1 steps
dp[i][1]: k steps
dp[i][2]: k+1 steps
</code></pre></div><p>Transitions:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">for k in [-1, 0, 1]:
  dp[i+step][k+1] = max(dp[i+step][k+1], dp[i][j]+k)
</code></pre></div><p>Note: It has to use max function in the  transition, because the later stones may update the jumps with lower distance.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canCross</span>(self, stones: List[int]) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">if</span> len(stones) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>:
            <span style="color:#66d9ef">return</span> True

        dp <span style="color:#f92672">=</span> defaultdict(<span style="color:#66d9ef">lambda</span>: [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>])
        dp[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> stones[<span style="color:#ae81ff">1</span>:]:
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
                <span style="color:#66d9ef">if</span> dp[i][j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
                    <span style="color:#66d9ef">continue</span>
                <span style="color:#66d9ef">for</span> k <span style="color:#f92672">in</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]:
                    step <span style="color:#f92672">=</span> dp[i][j] <span style="color:#f92672">+</span> k
                    <span style="color:#66d9ef">if</span> i<span style="color:#f92672">+</span>step <span style="color:#f92672">==</span> stones[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                        <span style="color:#66d9ef">return</span> True
                    <span style="color:#66d9ef">elif</span> step <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> i <span style="color:#f92672">+</span> step <span style="color:#f92672">&lt;</span> stones[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                        dp[i<span style="color:#f92672">+</span>step][k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(dp[i<span style="color:#f92672">+</span>step][k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], dp[i][j]<span style="color:#f92672">+</span>k)

        <span style="color:#66d9ef">return</span> False
</code></pre></div><h2 id="376-wiggle-subsequence">376 - Wiggle Subsequence</h2>
<p><a href="https://leetcode.com/problems/wiggle-subsequence/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.

For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.

Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.

Example 1:

Input: [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence.
Example 2:

Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].
Example 3:

Input: [1,2,3,4,5,6,7,8,9]
Output: 2
Follow up:
Can you do it in O(n) time?
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wiggleMaxLength</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> len(nums) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>:
            <span style="color:#66d9ef">return</span> len(nums)

        first_diff <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> len(nums)
        ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> first_diff <span style="color:#f92672">in</span> [<span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
            dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> len(nums)
            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, len(nums)):
                <span style="color:#66d9ef">if</span> first_diff <span style="color:#f92672">*</span> (nums[i] <span style="color:#f92672">-</span> nums[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                    dp[i] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
                    first_diff <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
                <span style="color:#66d9ef">else</span>:
                    dp[i] <span style="color:#f92672">=</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

            ret <span style="color:#f92672">=</span> max(ret, max(dp))

        <span style="color:#66d9ef">return</span> ret
</code></pre></div><h2 id="86-partition-list">86 - Partition List</h2>
<p><a href="https://leetcode.com/problems/partition-list/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

Example:

Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3
Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-two-dummy-pointers">Solution 1: Two Dummy Pointers</h4>
<p>Simple version: just create two list, and append them in the end</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">partition</span>(self, head: ListNode, x: int) <span style="color:#f92672">-&gt;</span> ListNode:
        p1 <span style="color:#f92672">=</span> l1 <span style="color:#f92672">=</span> ListNode(<span style="color:#ae81ff">0</span>)
        p2 <span style="color:#f92672">=</span> l2 <span style="color:#f92672">=</span> ListNode(<span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">while</span> head:
            <span style="color:#66d9ef">if</span> head<span style="color:#f92672">.</span>val <span style="color:#f92672">&lt;</span> x:
                p1<span style="color:#f92672">.</span>next, p1 <span style="color:#f92672">=</span> head, head
            <span style="color:#66d9ef">else</span>:
                p2<span style="color:#f92672">.</span>next, p2 <span style="color:#f92672">=</span> head, head
            head<span style="color:#f92672">.</span>next, head <span style="color:#f92672">=</span> None, head<span style="color:#f92672">.</span>next

        p1<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> l2<span style="color:#f92672">.</span>next
        <span style="color:#66d9ef">return</span> l1<span style="color:#f92672">.</span>next
</code></pre></div><h4 id="solution-2-in-place">Solution 2: In place</h4>
<p>Inplace swap with Two pointers:</p>
<p>p1: mark the end of smaller part</p>
<p>p2: go forward to find the smaller one and swap with p1.next</p>
<p>Addtional prev pointer for the swap.</p>
<ol>
<li>Use a dummy node to make it possible to swap the smaller one to the head</li>
<li>Note the case when p1 == prev, no need to swap, just move p1 forward</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">partition</span>(self, head: ListNode, x: int) <span style="color:#f92672">-&gt;</span> ListNode:
        head <span style="color:#f92672">=</span> ListNode(<span style="color:#ae81ff">0</span>, head)

        p1, prev, p2 <span style="color:#f92672">=</span> head, head, head<span style="color:#f92672">.</span>next

        <span style="color:#66d9ef">while</span> p2:
            <span style="color:#66d9ef">if</span> p2<span style="color:#f92672">.</span>val <span style="color:#f92672">&lt;</span> x:
                <span style="color:#66d9ef">if</span> p1 <span style="color:#f92672">==</span> prev:
                    prev, p2 <span style="color:#f92672">=</span> p2, p2<span style="color:#f92672">.</span>next
                <span style="color:#66d9ef">else</span>:
                    p1<span style="color:#f92672">.</span>next, p2<span style="color:#f92672">.</span>next, p2, prev<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> p2, p1<span style="color:#f92672">.</span>next, p2<span style="color:#f92672">.</span>next, p2<span style="color:#f92672">.</span>next
                p1 <span style="color:#f92672">=</span> p1<span style="color:#f92672">.</span>next
            <span style="color:#66d9ef">else</span>:
                prev, p2 <span style="color:#f92672">=</span> p2, p2<span style="color:#f92672">.</span>next

        <span style="color:#66d9ef">return</span> head<span style="color:#f92672">.</span>next
</code></pre></div><h2 id="378-kth-smallest-element-in-a-sorted-matrix">378 - Kth Smallest Element in a Sorted Matrix</h2>
<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.

Note that it is the kth smallest element in the sorted order, not the kth distinct element.

Example:

matrix = [
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
],
k = 8,

return 13.
</code></pre></div><h3 id="solution">Solution</h3>
<h4 id="solution-1-heap-with-marker">Solution 1: Heap with marker</h4>
<p>Maintain a heap, pop the first one, and push the right one and lower one into the heap.</p>
<p>But we need a mark matrix to tell if the one to be pushed was not visited before,
since it may have been in the heap when we push the lower one, and now we come to this one from left to right.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kthSmallest</span>(self, matrix: List[List[int]], k: int) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> matrix <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> matrix[<span style="color:#ae81ff">0</span>]:
            <span style="color:#66d9ef">return</span> None
        n <span style="color:#f92672">=</span> len(matrix)
        heap <span style="color:#f92672">=</span> []
        heapq<span style="color:#f92672">.</span>heapify(heap)
        heapq<span style="color:#f92672">.</span>heappush(heap, (matrix[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>], [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>]))
        mark <span style="color:#f92672">=</span> [[False] <span style="color:#f92672">*</span> n <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
        <span style="color:#66d9ef">while</span> k <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
            ret <span style="color:#f92672">=</span> heapq<span style="color:#f92672">.</span>heappop(heap)
            i, j <span style="color:#f92672">=</span> ret[<span style="color:#ae81ff">1</span>]
            <span style="color:#66d9ef">if</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> mark[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j]:
                heapq<span style="color:#f92672">.</span>heappush(heap, (matrix[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j], [i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, j]))
                mark[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">=</span> True
            <span style="color:#66d9ef">if</span> j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> mark[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]:
                heapq<span style="color:#f92672">.</span>heappush(heap, (matrix[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], [i, j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]))
                mark[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> True
            k <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> ret[<span style="color:#ae81ff">0</span>]
</code></pre></div><h4 id="solution-2-heap-without-marker">Solution 2: Heap without marker</h4>
<p>We can eliminate the marker by push the first column into the heap at once. Then we only need to traverse from left to right.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kthSmallest</span>(self, matrix: List[List[int]], k: int) <span style="color:#f92672">-&gt;</span> int:
        n <span style="color:#f92672">=</span> len(matrix)
        heap <span style="color:#f92672">=</span> [(row[<span style="color:#ae81ff">0</span>], index, <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">for</span> index, row <span style="color:#f92672">in</span> enumerate(matrix)]
        heapify(heap)
        <span style="color:#66d9ef">while</span> k <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
            ret, i, j <span style="color:#f92672">=</span> heapq<span style="color:#f92672">.</span>heappop(heap)
            <span style="color:#66d9ef">if</span> j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> n:
                heappush(heap, (matrix[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>], i, j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))
            k <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> ret
</code></pre></div><h4 id="solution-3-binary-search">Solution 3: Binary Search</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">kthSmallest</span>(self, matrix):
        lo, hi <span style="color:#f92672">=</span> len(matrix), len(matrix[<span style="color:#ae81ff">0</span>])
        <span style="color:#66d9ef">while</span> lo <span style="color:#f92672">&lt;</span> hi:
            mid <span style="color:#f92672">=</span> (lo<span style="color:#f92672">+</span>hi)<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>
            <span style="color:#66d9ef">if</span> sum(bisect<span style="color:#f92672">.</span>bisect_right(matrix[row], mid) <span style="color:#66d9ef">for</span> row <span style="color:#f92672">in</span> matrix) <span style="color:#f92672">&lt;</span> k:
                lo <span style="color:#f92672">=</span> mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                hi <span style="color:#f92672">=</span> mid
</code></pre></div><h2 id="115-distinct-subsequences">115 - Distinct Subsequences</h2>
<p><a href="https://leetcode.com/problems/distinct-subsequences/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given two strings s and t, return the number of distinct subsequences of s which equals t.

A string&#39;s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., &#34;ACE&#34; is a subsequence of &#34;ABCDE&#34; while &#34;AEC&#34; is not).

It&#39;s guaranteed the answer fits on a 32-bit signed integer.



Example 1:

Input: s = &#34;rabbbit&#34;, t = &#34;rabbit&#34;
Output: 3
Explanation:
As shown below, there are 3 ways you can generate &#34;rabbit&#34; from S.
rabbbit
rabbbit
rabbbit
Example 2:

Input: s = &#34;babgbag&#34;, t = &#34;bag&#34;
Output: 5
Explanation:
As shown below, there are 5 ways you can generate &#34;bag&#34; from S.
babgbag
babgbag
babgbag
babgbag
babgbag
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numDistinct</span>(self, s: str, t: str) <span style="color:#f92672">-&gt;</span> int:
        m, n <span style="color:#f92672">=</span> len(s), len(t)
        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            dp[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> s[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> t[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                    dp[i][j] <span style="color:#f92672">=</span> dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#66d9ef">else</span>:
                    dp[i][j] <span style="color:#f92672">=</span> dp[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]

        <span style="color:#66d9ef">return</span> dp[n][m]
</code></pre></div><h2 id="1392-longest-happy-prefix">1392 - Longest Happy Prefix</h2>
<p><a href="https://leetcode.com/problems/longest-happy-prefix/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).

Given a string s. Return the longest happy prefix of s .

Return an empty string if no such prefix exists.



Example 1:

Input: s = &#34;level&#34;
Output: &#34;l&#34;
Explanation: s contains 4 prefix excluding itself (&#34;l&#34;, &#34;le&#34;, &#34;lev&#34;, &#34;leve&#34;), and suffix (&#34;l&#34;, &#34;el&#34;, &#34;vel&#34;, &#34;evel&#34;). The largest prefix which is also suffix is given by &#34;l&#34;.
Example 2:

Input: s = &#34;ababab&#34;
Output: &#34;abab&#34;
Explanation: &#34;abab&#34; is the largest prefix which is also suffix. They can overlap in the original string.
Example 3:

Input: s = &#34;leetcodeleet&#34;
Output: &#34;leet&#34;
Example 4:

Input: s = &#34;a&#34;
Output: &#34;&#34;


Constraints:

1 &lt;= s.length &lt;= 10^5
s contains only lowercase English letters.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestPrefix</span>(self, s: str) <span style="color:#f92672">-&gt;</span> str:
        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> len(s)
        j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">while</span> i <span style="color:#f92672">&lt;</span> len(s):
            <span style="color:#66d9ef">if</span> s[i] <span style="color:#f92672">==</span> s[j]:
                j <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                dp[i] <span style="color:#f92672">=</span> j
            <span style="color:#66d9ef">elif</span> j <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
                j <span style="color:#f92672">=</span> dp[j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                i <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
            i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> s[:dp[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]]
</code></pre></div><h2 id="395-longest-substring-with-at-least-k-repeating-characters">395 - Longest Substring with At Least K Repeating Characters</h2>
<p><a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.

Example 1:

Input:
s = &#34;aaabb&#34;, k = 3

Output:
3

The longest substring is &#34;aaa&#34;, as &#39;a&#39; is repeated 3 times.
Example 2:

Input:
s = &#34;ababbc&#34;, k = 2

Output:
5

The longest substring is &#34;ababb&#34;, as &#39;a&#39; is repeated 2 times and &#39;b&#39; is repeated 3 times
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestSubstring</span>(self, s: str, k: int) <span style="color:#f92672">-&gt;</span> int:
        c <span style="color:#f92672">=</span> Counter(s)
        <span style="color:#66d9ef">for</span> i, v <span style="color:#f92672">in</span> c<span style="color:#f92672">.</span>items():
            <span style="color:#66d9ef">if</span> v <span style="color:#f92672">&lt;</span> k:
                <span style="color:#66d9ef">return</span> max(self<span style="color:#f92672">.</span>longestSubstring(x, k) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> s<span style="color:#f92672">.</span>split(i))
        <span style="color:#66d9ef">return</span> len(s)
</code></pre></div><h2 id="127-word-ladder">127 - Word Ladder</h2>
<p><a href="https://leetcode.com/problems/word-ladder/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given two words (beginWord and endWord), and a dictionary&#39;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time.
Each transformed word must exist in the word list.
Note:

Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:

Input:
beginWord = &#34;hit&#34;,
endWord = &#34;cog&#34;,
wordList = [&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;lot&#34;,&#34;log&#34;,&#34;cog&#34;]

Output: 5

Explanation: As one shortest transformation is &#34;hit&#34; -&gt; &#34;hot&#34; -&gt; &#34;dot&#34; -&gt; &#34;dog&#34; -&gt; &#34;cog&#34;,
return its length 5.
Example 2:

Input:
beginWord = &#34;hit&#34;
endWord = &#34;cog&#34;
wordList = [&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;lot&#34;,&#34;log&#34;]

Output: 0

Explanation: The endWord &#34;cog&#34; is not in wordList, therefore no possible transformation.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ladderLength</span>(self, beginWord: str, endWord: str, wordList: List[str]) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> endWord <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> wordList:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>

        h <span style="color:#f92672">=</span> Counter(set(wordList))

        queue <span style="color:#f92672">=</span> [beginWord]
        ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">while</span> queue:
            tmp <span style="color:#f92672">=</span> []
            <span style="color:#66d9ef">while</span> queue:
                w <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>pop()
                <span style="color:#66d9ef">if</span> w <span style="color:#f92672">==</span> endWord:
                    <span style="color:#66d9ef">return</span> ret

                <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(w)):
                    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">26</span>):
                        to <span style="color:#f92672">=</span> w[:i] <span style="color:#f92672">+</span> chr(ord(<span style="color:#e6db74">&#39;a&#39;</span>) <span style="color:#f92672">+</span> j) <span style="color:#f92672">+</span> w[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]
                        <span style="color:#66d9ef">if</span> to <span style="color:#f92672">!=</span> w <span style="color:#f92672">and</span> h[to]:
                            tmp<span style="color:#f92672">.</span>append(to)
                            h[to] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
            ret <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            queue <span style="color:#f92672">=</span> tmp
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h2 id="126-word-ladder-ii">126 - Word Ladder II</h2>
<p><a href="https://leetcode.com/problems/word-ladder-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given two words (beginWord and endWord), and a dictionary&#39;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:

Only one letter can be changed at a time
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return an empty list if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:

Input:
beginWord = &#34;hit&#34;,
endWord = &#34;cog&#34;,
wordList = [&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;lot&#34;,&#34;log&#34;,&#34;cog&#34;]

Output:
[
  [&#34;hit&#34;,&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;cog&#34;],
  [&#34;hit&#34;,&#34;hot&#34;,&#34;lot&#34;,&#34;log&#34;,&#34;cog&#34;]
]
Example 2:

Input:
beginWord = &#34;hit&#34;
endWord = &#34;cog&#34;
wordList = [&#34;hot&#34;,&#34;dot&#34;,&#34;dog&#34;,&#34;lot&#34;,&#34;log&#34;]

Output: []

Explanation: The endWord &#34;cog&#34; is not in wordList, therefore no possible transformation.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findLadders</span>(self, beginWord: str, endWord: str, wordList: List[str]):
        <span style="color:#66d9ef">if</span> endWord <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> wordList:
            <span style="color:#66d9ef">return</span> []

        h <span style="color:#f92672">=</span> Counter(set(wordList))
        paths <span style="color:#f92672">=</span> defaultdict(set)
        queue <span style="color:#f92672">=</span> [beginWord]
        h[beginWord] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        levels <span style="color:#f92672">=</span> []
        seen <span style="color:#f92672">=</span> False
        <span style="color:#66d9ef">while</span> queue <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> seen:
            tmp <span style="color:#f92672">=</span> []
            <span style="color:#66d9ef">while</span> queue:
                w <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span>pop()
                <span style="color:#66d9ef">if</span> w <span style="color:#f92672">==</span> endWord:
                    seen <span style="color:#f92672">=</span> True
                <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(w)):
                    <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">26</span>):
                        to <span style="color:#f92672">=</span> w[:i] <span style="color:#f92672">+</span> chr(ord(<span style="color:#e6db74">&#39;a&#39;</span>) <span style="color:#f92672">+</span> j) <span style="color:#f92672">+</span> w[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:]
                        <span style="color:#66d9ef">if</span> to <span style="color:#f92672">!=</span> w <span style="color:#f92672">and</span> h[to]:
                            tmp<span style="color:#f92672">.</span>append(to)
                            paths[w]<span style="color:#f92672">.</span>add(to)
            <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> tmp:
                h[t] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

            levels<span style="color:#f92672">.</span>append(list(tmp))
            queue <span style="color:#f92672">=</span> tmp

        ret <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(beginWord, endWord, paths, [], ret)
        <span style="color:#66d9ef">return</span> ret

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, beginWord, endWord, paths, path, ret):
        <span style="color:#66d9ef">if</span> beginWord <span style="color:#f92672">==</span> endWord:
            ret<span style="color:#f92672">.</span>append(path<span style="color:#f92672">+</span>[beginWord])
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> paths[beginWord]:
            self<span style="color:#f92672">.</span>dfs(x, endWord, paths, path<span style="color:#f92672">+</span>[beginWord], ret)
</code></pre></div><h2 id="257-binary-tree-paths">257 - Binary Tree Paths</h2>
<p><a href="https://leetcode.com/problems/binary-tree-paths/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">iven a binary tree, return all root-to-leaf paths.

Note: A leaf is a node with no children.

Example:

Input:

   1
 /   \
2     3
 \
  5

Output: [&#34;1-&gt;2-&gt;5&#34;, &#34;1-&gt;3&#34;]

Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">binaryTreePaths</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> List[str]:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> []

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>right <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> root<span style="color:#f92672">.</span>left:
            <span style="color:#66d9ef">return</span> [str(root<span style="color:#f92672">.</span>val)]

        paths <span style="color:#f92672">=</span> [str(root<span style="color:#f92672">.</span>val) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;-&gt;&#34;</span> <span style="color:#f92672">+</span> s <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>binaryTreePaths(root<span style="color:#f92672">.</span>right) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>binaryTreePaths(root<span style="color:#f92672">.</span>left)]
        <span style="color:#66d9ef">return</span> paths
</code></pre></div><h2 id="691-stickers-to-spell-word">691 - Stickers to Spell Word</h2>
<p><a href="https://leetcode.com/problems/stickers-to-spell-word/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">We are given N different types of stickers. Each sticker has a lowercase English word on it.

You would like to spell out the given target string by cutting individual letters from your collection of stickers and rearranging them.

You can use each sticker more than once if you want, and you have infinite quantities of each sticker.

What is the minimum number of stickers that you need to spell out the target? If the task is impossible, return -1.

Example 1:

Input:

[&#34;with&#34;, &#34;example&#34;, &#34;science&#34;], &#34;thehat&#34;
Output:

3
Explanation:

We can use 2 &#34;with&#34; stickers, and 1 &#34;example&#34; sticker.
After cutting and rearrange the letters of those stickers, we can form the target &#34;thehat&#34;.
Also, this is the minimum number of stickers necessary to form the target string.
Example 2:

Input:

[&#34;notice&#34;, &#34;possible&#34;], &#34;basicbasic&#34;
Output:

-1
Explanation:

We can&#39;t form the target &#34;basicbasic&#34; from cutting letters from the given stickers.
Note:

stickers has length in the range [1, 50].
stickers consists of lowercase English words (without apostrophes).
target has length in the range [1, 15], and consists of lowercase English letters.
In all test cases, all words were chosen randomly from the 1000 most common US English words, and the target was chosen as a concatenation of two random words.
The time limit may be more challenging than usual. It is expected that a 50 sticker test case can be solved within 35ms on average.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minStickers</span>(self, stickers: List[str], target: str) <span style="color:#f92672">-&gt;</span> int:
        self<span style="color:#f92672">.</span>ret <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#34;inf&#34;</span>)
        self<span style="color:#f92672">.</span>stickers <span style="color:#f92672">=</span> stickers
        self<span style="color:#f92672">.</span>dfs([], target, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ret <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>ret <span style="color:#f92672">&lt;</span> float(<span style="color:#e6db74">&#34;inf&#34;</span>) <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, pool, target, index, num_s):
        <span style="color:#66d9ef">if</span> num_s <span style="color:#f92672">&gt;=</span> self<span style="color:#f92672">.</span>ret:
            <span style="color:#66d9ef">return</span>
        <span style="color:#66d9ef">if</span> index <span style="color:#f92672">&gt;=</span> len(target):
            self<span style="color:#f92672">.</span>ret <span style="color:#f92672">=</span> num_s
            <span style="color:#66d9ef">return</span>
        <span style="color:#66d9ef">if</span> target[index] <span style="color:#f92672">in</span> pool:
            pool<span style="color:#f92672">.</span>remove(target[index])
            self<span style="color:#f92672">.</span>dfs(pool, target, index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, num_s)
            pool<span style="color:#f92672">.</span>append(target[index])
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>stickers:
                <span style="color:#66d9ef">if</span> target[index] <span style="color:#f92672">in</span> w:
                    new_chars <span style="color:#f92672">=</span> list(w)
                    new_chars<span style="color:#f92672">.</span>remove(target[index])
                    self<span style="color:#f92672">.</span>dfs(pool <span style="color:#f92672">+</span> new_chars, target, index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, num_s<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</code></pre></div><h2 id="797-all-paths-from-source-to-target">797 - All Paths From Source to Target</h2>
<p><a href="https://leetcode.com/problems/all-paths-from-source-to-target/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1, and return them in any order.

The graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">allPathsSourceTarget</span>(self, graph: List[List[int]]) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        ret <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dfs(graph, <span style="color:#ae81ff">0</span>, [<span style="color:#ae81ff">0</span>], ret)
        <span style="color:#66d9ef">return</span> ret

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, graph, source, path, ret):

        <span style="color:#66d9ef">if</span> source <span style="color:#f92672">==</span> len(graph) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>:
            ret<span style="color:#f92672">.</span>append(list(path))

        <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> graph[source]:
            self<span style="color:#f92672">.</span>dfs(graph, w, path<span style="color:#f92672">+</span>[w], ret)
</code></pre></div><h2 id="464-can-i-win">464 - Can I Win</h2>
<p><a href="https://leetcode.com/problems/can-i-win/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">In the &#34;100 game&#34; two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.

What if we change the game so that players cannot re-use integers?

For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt;= 100.

Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise return false. Assume both players play optimally.



Example 1:

Input: maxChoosableInteger = 10, desiredTotal = 11
Output: false
Explanation:
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.
Example 2:

Input: maxChoosableInteger = 10, desiredTotal = 0
Output: true
Example 3:

Input: maxChoosableInteger = 10, desiredTotal = 1
Output: true


Constraints:

1 &lt;= maxChoosableInteger &lt;= 20
0 &lt;= desiredTotal &lt;= 300
</code></pre></div><h3 id="solution">Solution</h3>
<p>DFS</p>
<p>Maintain a hashmap, use unchosen numbers as key,</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canIWin</span>(self, maxChoosableInteger: int, desiredTotal: int) <span style="color:#f92672">-&gt;</span> bool:
        h <span style="color:#f92672">=</span> {}
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canIWinRec</span>(numbers, desiredTotal):
            <span style="color:#66d9ef">if</span> numbers[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;=</span> desiredTotal:
                <span style="color:#66d9ef">return</span> True

            k <span style="color:#f92672">=</span> tuple(numbers)
            <span style="color:#66d9ef">if</span> k <span style="color:#f92672">in</span> h:
                <span style="color:#66d9ef">return</span> h[k]

            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(numbers)):
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> canIWinRec(numbers[:i] <span style="color:#f92672">+</span> numbers[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:], desiredTotal <span style="color:#f92672">-</span> numbers[i]):
                    h[k] <span style="color:#f92672">=</span> True
                    <span style="color:#66d9ef">return</span> True

            h[k] <span style="color:#f92672">=</span> False
            <span style="color:#66d9ef">return</span> False

        summed <span style="color:#f92672">=</span> (maxChoosableInteger <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> maxChoosableInteger <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>

        <span style="color:#66d9ef">if</span> summed <span style="color:#f92672">&lt;</span> desiredTotal:
            <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">if</span> summed <span style="color:#f92672">==</span> desiredTotal:
            <span style="color:#66d9ef">return</span> maxChoosableInteger <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span>

        numbers <span style="color:#f92672">=</span> list(range(<span style="color:#ae81ff">1</span>, maxChoosableInteger<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>))
        <span style="color:#66d9ef">return</span> canIWinRec(numbers, desiredTotal)
</code></pre></div><h2 id="116-populating-next-right-pointers-in-each-node">116 - Populating Next Right Pointers in Each Node</h2>
<p><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Follow up:

You may only use constant extra space.
Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.
</code></pre></div><h3 id="solution">Solution</h3>
<p>Constant Space</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">connect</span>(self, root: <span style="color:#e6db74">&#39;Node&#39;</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#39;Node&#39;</span>:
        node <span style="color:#f92672">=</span> root
        <span style="color:#66d9ef">while</span> node:
            next_level <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>left
            <span style="color:#66d9ef">while</span> node <span style="color:#f92672">and</span> node<span style="color:#f92672">.</span>left:
                node<span style="color:#f92672">.</span>left<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>right
                node<span style="color:#f92672">.</span>right<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>next <span style="color:#f92672">and</span> node<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>left
                node <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span>next
            node <span style="color:#f92672">=</span> next_level
        <span style="color:#66d9ef">return</span> root
</code></pre></div><h2 id="295-find-median-from-data-stream">295 - Find Median from Data Stream</h2>
<p><a href="https://leetcode.com/problems/find-median-from-data-stream/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.

For example,
[2,3,4], the median is 3

[2,3], the median is (2 + 3) / 2 = 2.5

Design a data structure that supports the following two operations:

void addNum(int num) - Add a integer number from the data stream to the data structure.
double findMedian() - Return the median of all elements so far.


Example:

addNum(1)
addNum(2)
findMedian() -&gt; 1.5
addNum(3)
findMedian() -&gt; 2


Follow up:

If all integer numbers from the stream are between 0 and 100, how would you optimize it?
If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?
</code></pre></div><h3 id="solution">Solution</h3>
<p>Two heaps, one for smaller half, one for larger half.</p>
<p>Follow ups:</p>
<ol>
<li>Keep a array for counting the numbers. Go through the array to find the median. It&rsquo;s O(1).</li>
<li>If 99% of all integer is between 0 and 100, keep the array. We need only count the ones over 100 and less than 0. Use the counts and the array to find the median</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MedianFinder</span>:

    <span style="color:#66d9ef">def</span> __init__(self):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        initialize your data structure here.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>small <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>large <span style="color:#f92672">=</span> []

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">addNum</span>(self, num: int) <span style="color:#f92672">-&gt;</span> None:
        heappush(self<span style="color:#f92672">.</span>small, <span style="color:#f92672">-</span>heappushpop(self<span style="color:#f92672">.</span>large, num))
        <span style="color:#66d9ef">if</span> len(self<span style="color:#f92672">.</span>large) <span style="color:#f92672">&lt;</span> len(self<span style="color:#f92672">.</span>small):
            heappush(self<span style="color:#f92672">.</span>large, <span style="color:#f92672">-</span>heappop(self<span style="color:#f92672">.</span>small))


    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findMedian</span>(self) <span style="color:#f92672">-&gt;</span> float:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>large:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">if</span> len(self<span style="color:#f92672">.</span>large) <span style="color:#f92672">&gt;</span> len(self<span style="color:#f92672">.</span>small):
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>large[<span style="color:#ae81ff">0</span>]
        <span style="color:#66d9ef">return</span> (self<span style="color:#f92672">.</span>large[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>small[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
</code></pre></div><h2 id="996-number-of-squareful-arrays">996 - Number of Squareful Arrays</h2>
<p><a href="https://leetcode.com/problems/number-of-squareful-arrays/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.

Return the number of permutations of A that are squareful.  Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].



Example 1:

Input: [1,17,8]
Output: 2
Explanation:
[1,8,17] and [17,8,1] are the valid permutations.
Example 2:

Input: [2,2,2]
Output: 1


Note:

1 &lt;= A.length &lt;= 12
0 &lt;= A[i] &lt;= 1e9
</code></pre></div><h3 id="solution">Solution</h3>
<p>Simple DFS</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numSquarefulPerms</span>(self, A: List[int]) <span style="color:#f92672">-&gt;</span> int:
        self<span style="color:#f92672">.</span>h <span style="color:#f92672">=</span> defaultdict(bool)

        mark <span style="color:#f92672">=</span> [False] <span style="color:#f92672">*</span> len(A)
        self<span style="color:#f92672">.</span>ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        self<span style="color:#f92672">.</span>dfs(sorted(A), [], mark)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ret

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, A, path, mark):

        <span style="color:#66d9ef">if</span> len(path) <span style="color:#f92672">==</span> len(A):
            self<span style="color:#f92672">.</span>ret <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i, v <span style="color:#f92672">in</span> enumerate(A):
            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> A[i] <span style="color:#f92672">==</span> A[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">and</span> <span style="color:#f92672">not</span> mark[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]) <span style="color:#f92672">or</span> mark[i]:
                <span style="color:#66d9ef">continue</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> path <span style="color:#f92672">or</span> self<span style="color:#f92672">.</span>isSquare(path[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>v):
                mark[i] <span style="color:#f92672">=</span> True
                self<span style="color:#f92672">.</span>dfs(A, path<span style="color:#f92672">+</span>[v], mark)
                mark[i] <span style="color:#f92672">=</span> False

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isSquare</span>(self, num):
        <span style="color:#66d9ef">return</span> True <span style="color:#66d9ef">if</span> int((num<span style="color:#f92672">**</span><span style="color:#ae81ff">0.5</span>))<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> num <span style="color:#66d9ef">else</span> False
</code></pre></div><h2 id="842-split-array-into-fibonacci-sequence">842 - Split Array into Fibonacci Sequence</h2>
<p><a href="https://leetcode.com/problems/split-array-into-fibonacci-sequence/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a string S of digits, such as S = &#34;123456579&#34;, we can split it into a Fibonacci-like sequence [123, 456, 579].

Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:

0 &lt;= F[i] &lt;= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type);
F.length &gt;= 3;
and F[i] + F[i+1] = F[i+2] for all 0 &lt;= i &lt; F.length - 2.
Also, note that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.

Return any Fibonacci-like sequence split from S, or return [] if it cannot be done.

Example 1:

Input: &#34;123456579&#34;
Output: [123,456,579]
Example 2:

Input: &#34;11235813&#34;
Output: [1,1,2,3,5,8,13]
Example 3:

Input: &#34;112358130&#34;
Output: []
Explanation: The task is impossible.
Example 4:

Input: &#34;0123&#34;
Output: []
Explanation: Leading zeroes are not allowed, so &#34;01&#34;, &#34;2&#34;, &#34;3&#34; is not valid.
Example 5:

Input: &#34;1101111&#34;
Output: [110, 1, 111]
Explanation: The output [11, 0, 11, 11] would also be accepted.
Note:

1 &lt;= S.length &lt;= 200
S contains only digits.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">splitIntoFibonacci</span>(self, S: str) <span style="color:#f92672">-&gt;</span> List[int]:
        self<span style="color:#f92672">.</span>upper_bound <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">**</span><span style="color:#ae81ff">31</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
        self<span style="color:#f92672">.</span>ret <span style="color:#f92672">=</span> []

        self<span style="color:#f92672">.</span>dfs(S, <span style="color:#ae81ff">0</span>, [], [])

        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>ret

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, S, index, ret, path):
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>ret:
            <span style="color:#66d9ef">return</span>

        <span style="color:#66d9ef">if</span> index <span style="color:#f92672">==</span> len(S) <span style="color:#f92672">and</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(map(str, ret)) <span style="color:#f92672">==</span> S <span style="color:#f92672">and</span> len(ret) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>:
            self<span style="color:#f92672">.</span>ret <span style="color:#f92672">=</span> list(ret)
            <span style="color:#66d9ef">return</span>
        <span style="color:#66d9ef">elif</span> index <span style="color:#f92672">==</span> len(S):
            <span style="color:#66d9ef">return</span>

        path<span style="color:#f92672">.</span>append(S[index])

        n <span style="color:#f92672">=</span> int(<span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(path))
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>isFibonacci(ret, n):
            self<span style="color:#f92672">.</span>dfs(S, index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, ret<span style="color:#f92672">+</span>[n], [])

        self<span style="color:#f92672">.</span>dfs(S, index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, ret, path)
        path<span style="color:#f92672">.</span>pop()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">isFibonacci</span>(self, sequence, number):
        <span style="color:#66d9ef">if</span> number <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> number <span style="color:#f92672">&gt;</span> self<span style="color:#f92672">.</span>upper_bound:
            <span style="color:#66d9ef">return</span> False

        <span style="color:#66d9ef">if</span> len(sequence) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>:
            <span style="color:#66d9ef">return</span> True

        <span style="color:#66d9ef">return</span> True <span style="color:#66d9ef">if</span> number <span style="color:#f92672">==</span> sequence[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> sequence[<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>] <span style="color:#66d9ef">else</span> False
</code></pre></div><h2 id="486-predict-the-winner">486 - Predict the Winner</h2>
<p><a href="https://leetcode.com/problems/predict-the-winner/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on.
Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.

Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.

Example 1:

Input: [1, 5, 2]
Output: False
Explanation: Initially, player 1 can choose between 1 and 2.
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2).
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5.
Hence, player 1 will never be the winner and you need to return False.


Example 2:

Input: [1, 5, 233, 7]
Output: True
Explanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.


Constraints:

1 &lt;= length of the array &lt;= 20.
Any scores in the given array are non-negative integers and will not exceed 10,000,000.
If the scores of both players are equal, then player 1 is still the winner.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">PredictTheWinner</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> bool:
        dp <span style="color:#f92672">=</span> {}
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getMaxDiff</span>(left, right):
            <span style="color:#66d9ef">if</span> (left, right) <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> dp:
                <span style="color:#66d9ef">if</span> left <span style="color:#f92672">==</span> right:
                    <span style="color:#66d9ef">return</span> nums[left]

                dp[left, right] <span style="color:#f92672">=</span> max(nums[left] <span style="color:#f92672">-</span> getMaxDiff(left<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, right), nums[right] <span style="color:#f92672">-</span> getMaxDiff(left, right<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
            <span style="color:#66d9ef">return</span> dp[left, right]

        <span style="color:#66d9ef">return</span> getMaxDiff(<span style="color:#ae81ff">0</span>, len(nums)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h2 id="556-next-greater-element-iii">556 - Next Greater Element III</h2>
<p><a href="https://leetcode.com/problems/next-greater-element-iii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.

Example 1:

Input: 12
Output: 21


Example 2:

Input: 21
Output: -1
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nextGreaterElement</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        s <span style="color:#f92672">=</span> list(str(n))

        first <span style="color:#f92672">=</span> len(s) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s)<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> s[i] <span style="color:#f92672">&lt;</span> s[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]:
                first <span style="color:#f92672">=</span> i
                <span style="color:#66d9ef">break</span>

        <span style="color:#66d9ef">if</span> first <span style="color:#f92672">==</span> len(s) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>

        second <span style="color:#f92672">=</span> first<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
        minimum <span style="color:#f92672">=</span> s[second]

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(first<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, len(s)):
            <span style="color:#66d9ef">if</span> s[i] <span style="color:#f92672">&lt;</span> minimum <span style="color:#f92672">and</span> s[i] <span style="color:#f92672">&gt;</span> s[first]:
                minumum <span style="color:#f92672">=</span> s[i]
                second <span style="color:#f92672">=</span> i

        s[first], s[second] <span style="color:#f92672">=</span> s[second], s[first]

        ret <span style="color:#f92672">=</span> int(<span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(s[:first<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> sorted(s[first<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>:])))
        <span style="color:#66d9ef">return</span> ret <span style="color:#66d9ef">if</span> ret <span style="color:#f92672">&lt;=</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">31</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="381-insert-delete-getrandom-o--1--duplicates-allowed">381 - Insert Delete GetRandom O(1) - Duplicates allowed</h2>
<p><a href="https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Design a data structure that supports all following operations in average O(1) time.

Note: Duplicate elements are allowed.
insert(val): Inserts an item val to the collection.
remove(val): Removes an item val from the collection if present.
getRandom: Returns a random element from current collection of elements. The probability of each element being returned is linearly related to the number of same value the collection contains.
Example:

// Init an empty collection.
RandomizedCollection collection = new RandomizedCollection();

// Inserts 1 to the collection. Returns true as the collection did not contain 1.
collection.insert(1);

// Inserts another 1 to the collection. Returns false as the collection contained 1. Collection now contains [1,1].
collection.insert(1);

// Inserts 2 to the collection, returns true. Collection now contains [1,1,2].
collection.insert(2);

// getRandom should return 1 with the probability 2/3, and returns 2 with the probability 1/3.
collection.getRandom();

// Removes 1 from the collection, returns true. Collection now contains [1,2].
collection.remove(1);

// getRandom should return 1 and 2 both equally likely.
collection.getRandom();
</code></pre></div><h3 id="solution">Solution</h3>
<p>Notes:</p>
<p>Remove is tricky.</p>
<ol>
<li>Find the index of the element to remove in Hash.</li>
<li>Replace the element with the last element in array, and pop the last one.</li>
<li>Don&rsquo;t forget to update the index of copied element in Hash.</li>
<li>You have to firstly add the new index and then delete. There is a corner case when there is only one element. If you delete it first and then add, the same index is added back to hash.</li>
</ol>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RandomizedCollection</span>:

    <span style="color:#66d9ef">def</span> __init__(self):
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Initialize your data structure here.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>list <span style="color:#f92672">=</span> []
        self<span style="color:#f92672">.</span>dict <span style="color:#f92672">=</span> defaultdict(set)

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insert</span>(self, val: int) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Inserts a value to the collection. Returns true if the collection did not already contain the specified element.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        self<span style="color:#f92672">.</span>list<span style="color:#f92672">.</span>append(val)
        <span style="color:#66d9ef">if</span> val <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>dict:
            ret <span style="color:#f92672">=</span> True
        <span style="color:#66d9ef">else</span>:
            ret <span style="color:#f92672">=</span> False
        self<span style="color:#f92672">.</span>dict[val]<span style="color:#f92672">.</span>add(len(self<span style="color:#f92672">.</span>list) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> ret


    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">remove</span>(self, val: int) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Removes a value from the collection. Returns true if the collection contained the specified element.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>dict[val]:
            rm_index <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>dict[val]<span style="color:#f92672">.</span>pop()
            last <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>list[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
            self<span style="color:#f92672">.</span>list[rm_index] <span style="color:#f92672">=</span> last
            self<span style="color:#f92672">.</span>dict[last]<span style="color:#f92672">.</span>add(rm_index)
            self<span style="color:#f92672">.</span>dict[last]<span style="color:#f92672">.</span>discard(len(self<span style="color:#f92672">.</span>list) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
            self<span style="color:#f92672">.</span>list<span style="color:#f92672">.</span>pop()
            <span style="color:#66d9ef">return</span> True
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> False

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getRandom</span>(self) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#e6db74">&#34;&#34;&#34;
</span><span style="color:#e6db74">        Get a random element from the collection.
</span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
        <span style="color:#66d9ef">return</span> random<span style="color:#f92672">.</span>choice(self<span style="color:#f92672">.</span>list)


<span style="color:#75715e"># Your RandomizedCollection object will be instantiated and called as such:</span>
<span style="color:#75715e"># obj = RandomizedCollection()</span>
<span style="color:#75715e"># param_1 = obj.insert(val)</span>
<span style="color:#75715e"># param_2 = obj.remove(val)</span>
<span style="color:#75715e"># param_3 = obj.getRandom()</span>
</code></pre></div><h2 id="134-gas-station">134 - Gas Station</h2>
<p><a href="https://leetcode.com/problems/gas-station/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">There are N gas stations along a circular route, where the amount of gas at station i is gas[i].

You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.

Note:

If there exists a solution, it is guaranteed to be unique.
Both input arrays are non-empty and have the same length.
Each element in the input arrays is a non-negative integer.
Example 1:

Input:
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
Example 2:

Input:
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can&#39;t start at station 0 or 1, as there is not enough gas to travel to the next station.
Let&#39;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can&#39;t travel around the circuit once no matter where you start.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">canCompleteCircuit</span>(self, gas: List[int], cost: List[int]) <span style="color:#f92672">-&gt;</span> int:
        start <span style="color:#f92672">=</span> gap <span style="color:#f92672">=</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(gas)):
            left <span style="color:#f92672">+=</span> gas[i] <span style="color:#f92672">-</span> cost[i]
            <span style="color:#66d9ef">if</span> left <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
                start <span style="color:#f92672">=</span> i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>
                gap <span style="color:#f92672">+=</span> left
                left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>

        <span style="color:#66d9ef">return</span> start <span style="color:#66d9ef">if</span> left<span style="color:#f92672">+</span>gap <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="135-candy">135 - Candy</h2>
<p><a href="https://leetcode.com/problems/candy/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">There are N children standing in a line. Each child is assigned a rating value.

You are giving candies to these children subjected to the following requirements:

Each child must have at least one candy.
Children with a higher rating get more candies than their neighbors.
What is the minimum candies you must give?

Example 1:

Input: [1,0,2]
Output: 5
Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.
Example 2:

Input: [1,2,2]
Output: 4
Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.
             The third child gets 1 candy because it satisfies the above two conditions.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">candy</span>(self, ratings: List[int]) <span style="color:#f92672">-&gt;</span> int:

        candy <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> len(ratings)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(candy)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> ratings[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> ratings[i]:
                candy[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> candy[i] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(candy)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            <span style="color:#66d9ef">if</span> ratings[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> ratings[i]:
                candy[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(candy[i]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, candy[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])

        <span style="color:#66d9ef">return</span> sum(candy)
</code></pre></div><h2 id="140-word-break-ii">140 - Word Break II</h2>
<p><a href="https://leetcode.com/problems/word-break-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input:
s = &#34;catsanddog&#34;
wordDict = [&#34;cat&#34;, &#34;cats&#34;, &#34;and&#34;, &#34;sand&#34;, &#34;dog&#34;]
Output:
[
  &#34;cats and dog&#34;,
  &#34;cat sand dog&#34;
]
Example 2:

Input:
s = &#34;pineapplepenapple&#34;
wordDict = [&#34;apple&#34;, &#34;pen&#34;, &#34;applepen&#34;, &#34;pine&#34;, &#34;pineapple&#34;]
Output:
[
  &#34;pine apple pen apple&#34;,
  &#34;pineapple pen apple&#34;,
  &#34;pine applepen apple&#34;
]
Explanation: Note that you are allowed to reuse a dictionary word.
Example 3:

Input:
s = &#34;catsandog&#34;
wordDict = [&#34;cats&#34;, &#34;dog&#34;, &#34;sand&#34;, &#34;and&#34;, &#34;cat&#34;]
Output:
[]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>(object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wordBreak</span>(self, s, wordDict):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>dfs(s, set(wordDict), <span style="color:#ae81ff">0</span>, {})

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, s, wordDict, start, memo):

        <span style="color:#66d9ef">if</span> start <span style="color:#f92672">&gt;=</span> len(s): <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#34;&#34;</span>]
        <span style="color:#66d9ef">if</span> start <span style="color:#f92672">in</span> memo: <span style="color:#66d9ef">return</span> memo[start]

        ans <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, len(s)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            w <span style="color:#f92672">=</span> s[start:i]
            <span style="color:#66d9ef">if</span> w <span style="color:#f92672">in</span> wordDict:
                ans <span style="color:#f92672">+=</span> [<span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">.</span>join([w, x]) <span style="color:#66d9ef">if</span> x <span style="color:#66d9ef">else</span> w <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>dfs(s, wordDict, i, memo)]

        memo[start] <span style="color:#f92672">=</span> ans
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="139-word-break">139 - Word Break</h2>
<p><a href="https://leetcode.com/problems/word-break-ii/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = &#34;leetcode&#34;, wordDict = [&#34;leet&#34;, &#34;code&#34;]
Output: true
Explanation: Return true because &#34;leetcode&#34; can be segmented as &#34;leet code&#34;.
Example 2:

Input: s = &#34;applepenapple&#34;, wordDict = [&#34;apple&#34;, &#34;pen&#34;]
Output: true
Explanation: Return true because &#34;applepenapple&#34; can be segmented as &#34;apple pen apple&#34;.
             Note that you are allowed to reuse a dictionary word.
Example 3:

Input: s = &#34;catsandog&#34;, wordDict = [&#34;cats&#34;, &#34;dog&#34;, &#34;sand&#34;, &#34;and&#34;, &#34;cat&#34;]
Output: false
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wordBreak</span>(self, s: str, wordDict: List[str]) <span style="color:#f92672">-&gt;</span> bool:
        memo <span style="color:#f92672">=</span> {}

        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(index):
            <span style="color:#66d9ef">if</span> index <span style="color:#f92672">in</span> memo: <span style="color:#66d9ef">return</span> memo[index]
            <span style="color:#66d9ef">if</span> index <span style="color:#f92672">&gt;=</span> len(s): <span style="color:#66d9ef">return</span> True

            ret <span style="color:#f92672">=</span> False
            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, len(s)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">if</span> s[index:i] <span style="color:#f92672">in</span> wordDict:
                    <span style="color:#66d9ef">if</span> dfs(i):
                        ret <span style="color:#f92672">=</span> True
                        <span style="color:#66d9ef">break</span>

            memo[index] <span style="color:#f92672">=</span> ret
            <span style="color:#66d9ef">return</span> ret

        <span style="color:#66d9ef">return</span> dfs(<span style="color:#ae81ff">0</span>)
</code></pre></div><h2 id="443-string-compression">443 - String Compression</h2>
<p><a href="https://leetcode.com/problems/string-compression/submissions/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given an array of characters chars, compress it using the following algorithm:

Begin with an empty string s. For each group of consecutive repeating characters in chars:

If the group&#39;s length is 1, append the character to s.
Otherwise, append the character followed by the group&#39;s length.
The compressed string s should not be returned separately, but instead be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.

After you are done modifying the input array, return the new length of the array.


Follow up:
Could you solve it using only O(1) extra space?



Example 1:

Input: chars = [&#34;a&#34;,&#34;a&#34;,&#34;b&#34;,&#34;b&#34;,&#34;c&#34;,&#34;c&#34;,&#34;c&#34;]
Output: Return 6, and the first 6 characters of the input array should be: [&#34;a&#34;,&#34;2&#34;,&#34;b&#34;,&#34;2&#34;,&#34;c&#34;,&#34;3&#34;]
Explanation: The groups are &#34;aa&#34;, &#34;bb&#34;, and &#34;ccc&#34;. This compresses to &#34;a2b2c3&#34;.
Example 2:

Input: chars = [&#34;a&#34;]
Output: Return 1, and the first character of the input array should be: [&#34;a&#34;]
Explanation: The only group is &#34;a&#34;, which remains uncompressed since it&#39;s a single character.
Example 3:

Input: chars = [&#34;a&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;,&#34;b&#34;]
Output: Return 4, and the first 4 characters of the input array should be: [&#34;a&#34;,&#34;b&#34;,&#34;1&#34;,&#34;2&#34;].
Explanation: The groups are &#34;a&#34; and &#34;bbbbbbbbbbbb&#34;. This compresses to &#34;ab12&#34;.
Example 4:

Input: chars = [&#34;a&#34;,&#34;a&#34;,&#34;a&#34;,&#34;b&#34;,&#34;b&#34;,&#34;a&#34;,&#34;a&#34;]
Output: Return 6, and the first 6 characters of the input array should be: [&#34;a&#34;,&#34;3&#34;,&#34;b&#34;,&#34;2&#34;,&#34;a&#34;,&#34;2&#34;].
Explanation: The groups are &#34;aaa&#34;, &#34;bb&#34;, and &#34;aa&#34;. This compresses to &#34;a3b2a2&#34;. Note that each group is independent even if two groups have the same character.


Constraints:

1 &lt;= chars.length &lt;= 2000
chars[i] is a lower-case English letter, upper-case English letter, digit, or symbol.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">compress</span>(self, chars: List[str]) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> len(chars) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>: <span style="color:#66d9ef">return</span> len(chars)

        read, write <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>
        count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">while</span> read <span style="color:#f92672">&lt;</span> len(chars):
            <span style="color:#66d9ef">if</span> chars[read] <span style="color:#f92672">==</span> chars[read<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]:
                count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">elif</span> count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>:
                chars[write] <span style="color:#f92672">=</span> chars[read<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> list(str(count)):
                    write <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                    chars[write] <span style="color:#f92672">=</span> s
                write <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
            <span style="color:#66d9ef">else</span>:
                chars[write] <span style="color:#f92672">=</span> chars[read<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
                write <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            read <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">if</span> count <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            chars[write] <span style="color:#f92672">=</span> chars[read<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
            write <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">else</span>:
            chars[write] <span style="color:#f92672">=</span> chars[read<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
            <span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> list(str(count)):
                write <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                chars[write] <span style="color:#f92672">=</span> s
            write <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">return</span> write
</code></pre></div><h2 id="30-substring-with-concatenation-of-all-words">30 - Substring with Concatenation of All Words</h2>
<p><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given a string s and an array of strings words of the same length. Return all starting indices of substring(s) in s that is a concatenation of each word in words exactly once, in any order, and without any intervening characters.

You can return the answer in any order.



Example 1:

Input: s = &#34;barfoothefoobarman&#34;, words = [&#34;foo&#34;,&#34;bar&#34;]
Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are &#34;barfoo&#34; and &#34;foobar&#34; respectively.
The output order does not matter, returning [9,0] is fine too.
Example 2:

Input: s = &#34;wordgoodgoodgoodbestword&#34;, words = [&#34;word&#34;,&#34;good&#34;,&#34;best&#34;,&#34;word&#34;]
Output: []
Example 3:

Input: s = &#34;barfoofoobarthefoobarman&#34;, words = [&#34;bar&#34;,&#34;foo&#34;,&#34;the&#34;]
Output: [6,9,12]
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findSubstring</span>(self, s: str, words: List[str]) <span style="color:#f92672">-&gt;</span> List[int]:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> s <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> words:
            <span style="color:#66d9ef">return</span> []
        length <span style="color:#f92672">=</span> len(words[<span style="color:#ae81ff">0</span>])
        total_words <span style="color:#f92672">=</span> len(words)
        words <span style="color:#f92672">=</span> Counter(words)
        ans <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(start, i, path):
            <span style="color:#66d9ef">if</span> len(path) <span style="color:#f92672">==</span> total_words:
                ans<span style="color:#f92672">.</span>append(start)
                <span style="color:#66d9ef">return</span>
            <span style="color:#66d9ef">if</span> i <span style="color:#f92672">&gt;=</span> len(s):
                <span style="color:#66d9ef">return</span>
            w <span style="color:#f92672">=</span> s[i:i<span style="color:#f92672">+</span>length]
            <span style="color:#66d9ef">if</span> words[w]:
                words[w] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
                dfs(start, i<span style="color:#f92672">+</span>length, path<span style="color:#f92672">+</span>[w])
                words[w] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(s)<span style="color:#f92672">-</span>length<span style="color:#f92672">*</span>total_words<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>):
            dfs(i, i, [])

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="1010-pairs-of-songs-with-total-durations-divisible-by-60">1010 - Pairs of Songs With Total Durations Divisible by 60</h2>
<p><a href="https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given a list of songs where the ith song has a duration of time[i] seconds.

Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &lt; j with (time[i] + time[j]) % 60 == 0.



Example 1:

Input: time = [30,20,150,100,40]
Output: 3
Explanation: Three pairs have a total duration divisible by 60:
(time[0] = 30, time[2] = 150): total duration 180
(time[1] = 20, time[3] = 100): total duration 120
(time[1] = 20, time[4] = 40): total duration 60
Example 2:

Input: time = [60,60,60]
Output: 3
Explanation: All three pairs have a total duration of 120, which is divisible by 60.


Constraints:

1 &lt;= time.length &lt;= 6 * 104
1 &lt;= time[i] &lt;= 500
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">numPairsDivisibleBy60</span>(self, time: List[int]) <span style="color:#f92672">-&gt;</span> int:
        counter <span style="color:#f92672">=</span> Counter()
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> time:
            ans <span style="color:#f92672">+=</span> counter[(<span style="color:#ae81ff">60</span> <span style="color:#f92672">-</span> t<span style="color:#f92672">%</span><span style="color:#ae81ff">60</span>)<span style="color:#f92672">%</span><span style="color:#ae81ff">60</span>]
            counter[t<span style="color:#f92672">%</span><span style="color:#ae81ff">60</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="235-lowest-common-ancestor-of-a-binary-search-tree">235 - Lowest Common Ancestor of a Binary Search Tree</h2>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(self, root: <span style="color:#e6db74">&#39;TreeNode&#39;</span>, p: <span style="color:#e6db74">&#39;TreeNode&#39;</span>, q: <span style="color:#e6db74">&#39;TreeNode&#39;</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#39;TreeNode&#39;</span>:
        <span style="color:#66d9ef">while</span> root <span style="color:#f92672">and</span> (p<span style="color:#f92672">.</span>val<span style="color:#f92672">-</span>root<span style="color:#f92672">.</span>val) <span style="color:#f92672">*</span> (q<span style="color:#f92672">.</span>val<span style="color:#f92672">-</span>root<span style="color:#f92672">.</span>val) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">if</span> p<span style="color:#f92672">.</span>val <span style="color:#f92672">-</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
                root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>left
            <span style="color:#66d9ef">else</span>:
                root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span>right
        <span style="color:#66d9ef">return</span> root
</code></pre></div><h2 id="701-insert-into-a-binary-search-tree">701 - Insert into a Binary Search Tree</h2>
<p><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.

Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">insertIntoBST</span>(self, root: TreeNode, val: int) <span style="color:#f92672">-&gt;</span> TreeNode:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> TreeNode(val)
        <span style="color:#66d9ef">if</span> val <span style="color:#f92672">&gt;</span> root<span style="color:#f92672">.</span>val:
            root<span style="color:#f92672">.</span>right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>insertIntoBST(root<span style="color:#f92672">.</span>right, val)
        <span style="color:#66d9ef">else</span>:
            root<span style="color:#f92672">.</span>left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>insertIntoBST(root<span style="color:#f92672">.</span>left, val)

        <span style="color:#66d9ef">return</span> root
</code></pre></div><h2 id="323-number-of-connected-components-in-an-undirected-graph">323 - Number of Connected Components in an Undirected Graph</h2>
<p><a href="https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph.
Example 1:
Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]]
     0          3
     |          |
     1 --- 2    4
Output: 2
Example 2:
Input: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]]
     0           4
     |           |
     1 --- 2 --- 3
Output:  1
Note:
You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> defaultdict

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>():
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">ConnectedComponents</span>(self, edges):
      graph <span style="color:#f92672">=</span> defaultdict(list)
      marked <span style="color:#f92672">=</span> {}
      <span style="color:#66d9ef">for</span> edge <span style="color:#f92672">in</span> edges:
          graph[edge[<span style="color:#ae81ff">0</span>]]<span style="color:#f92672">.</span>append(edge[<span style="color:#ae81ff">1</span>])
          graph[edge[<span style="color:#ae81ff">1</span>]]<span style="color:#f92672">.</span>append(edge[<span style="color:#ae81ff">0</span>])
          marked[edge[<span style="color:#ae81ff">0</span>]] <span style="color:#f92672">=</span> False
          marked[edge[<span style="color:#ae81ff">1</span>]] <span style="color:#f92672">=</span> False

      ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
      <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> graph<span style="color:#f92672">.</span>keys():
          <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> marked[v]:
              self<span style="color:#f92672">.</span>dfs(graph, v, marked)
              ans <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
      <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(self, graph, v, marked):
        marked[v] <span style="color:#f92672">=</span> True
        <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> graph[v]:
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> marked[w]:
                self<span style="color:#f92672">.</span>dfs(graph, w, marked)

<span style="color:#66d9ef">print</span>(Solution()<span style="color:#f92672">.</span>ConnectedComponents([[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]]))
</code></pre></div><h2 id="863-all-nodes-distance-k-in-binary-tree">863 - All Nodes Distance K in Binary Tree</h2>
<p><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">We are given a binary tree (with root node root), a target node, and an integer value K.

Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.



Example 1:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2

Output: [7,4,1]

Explanation:
The nodes that are a distance 2 from the target node (with value 5)
have values 7, 4, and 1.

Note:

1. The given tree is non-empty.
2. Each node in the tree has unique values 0 &lt;= node.val &lt;= 500.
3. The target node is a node in the tree.
4. 0 &lt;= K &lt;= 1000.
</code></pre></div><h3 id="solution">Solution</h3>
<p>BFS</p>
<ol>
<li>Build a graph. Connet the parent and child in both directions.</li>
<li>Start BFS search from the target value, with step of K.</li>
</ol>
<p>In K step, the element in the new level are the answer.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">distanceK</span>(self, root: TreeNode, target: TreeNode, K: int) <span style="color:#f92672">-&gt;</span> List[int]:

        graph <span style="color:#f92672">=</span> defaultdict(list)

        self<span style="color:#f92672">.</span>connect(graph, root, root<span style="color:#f92672">.</span>left)
        self<span style="color:#f92672">.</span>connect(graph, root, root<span style="color:#f92672">.</span>right)
        level <span style="color:#f92672">=</span> [target<span style="color:#f92672">.</span>val]
        marked <span style="color:#f92672">=</span> set(level)
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(K):
            new_level <span style="color:#f92672">=</span> []
            <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> level:
                <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> graph[x]:
                    <span style="color:#66d9ef">if</span> w <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> marked:
                        new_level<span style="color:#f92672">.</span>append(w)
            level <span style="color:#f92672">=</span> new_level
            marked <span style="color:#f92672">|=</span> set(new_level)

        <span style="color:#66d9ef">return</span> level

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">connect</span>(self, graph, parent, child):
        <span style="color:#66d9ef">if</span> parent <span style="color:#f92672">and</span> child:
            graph[parent<span style="color:#f92672">.</span>val]<span style="color:#f92672">.</span>append(child<span style="color:#f92672">.</span>val)
            graph[child<span style="color:#f92672">.</span>val]<span style="color:#f92672">.</span>append(parent<span style="color:#f92672">.</span>val)

            self<span style="color:#f92672">.</span>connect(graph, child, child<span style="color:#f92672">.</span>left)
            self<span style="color:#f92672">.</span>connect(graph, child, child<span style="color:#f92672">.</span>right)
</code></pre></div><h2 id="515-find-largest-value-in-each-tree-row">515 - Find Largest Value in Each Tree Row</h2>
<p><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">largestValues</span>(self, root: TreeNode) <span style="color:#f92672">-&gt;</span> List[int]:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> []
        ans <span style="color:#f92672">=</span> []
        level <span style="color:#f92672">=</span> [root]
        seen <span style="color:#f92672">=</span> set(level)

        <span style="color:#66d9ef">while</span> level:
            new_level <span style="color:#f92672">=</span> []
            max_val <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>float(<span style="color:#e6db74">&#39;inf&#39;</span>)
            <span style="color:#66d9ef">for</span> node <span style="color:#f92672">in</span> level:
                <span style="color:#66d9ef">if</span> node:
                    <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>left:
                        new_level<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>left)
                    <span style="color:#66d9ef">if</span> node<span style="color:#f92672">.</span>right:
                        new_level<span style="color:#f92672">.</span>append(node<span style="color:#f92672">.</span>right)
                    max_val <span style="color:#f92672">=</span> max(max_val, node<span style="color:#f92672">.</span>val)
            ans<span style="color:#f92672">.</span>append(max_val)
            level <span style="color:#f92672">=</span> new_level

        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="42-trapping-rain-water">42 - Trapping Rain Water</h2>
<p><a href="https://leetcode.com/problems/trapping-rain-water/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.


Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">trap</span>(self, height: List[int]) <span style="color:#f92672">-&gt;</span> int:
        ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        leftHeight <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>leftMaxHeight(height)
        rightHeight <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>rightMaxHeight(height)

        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(height)):
            max_bar <span style="color:#f92672">=</span> min(leftHeight[i], rightHeight[i])
            <span style="color:#66d9ef">if</span> max_bar <span style="color:#f92672">&gt;</span> height[i]:
                ans <span style="color:#f92672">+=</span> max_bar <span style="color:#f92672">-</span> height[i]
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">leftMaxHeight</span>(self, height):
        ans <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> len(height)
        max_left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(height)):
            ans[i] <span style="color:#f92672">=</span> max_left
            max_left <span style="color:#f92672">=</span> max(height[i], max_left)
        <span style="color:#66d9ef">return</span> ans

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rightMaxHeight</span>(self, height):
        ans <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> len(height)
        max_right <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(height)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
            ans[i] <span style="color:#f92672">=</span> max_right
            max_right <span style="color:#f92672">=</span> max(height[i], max_right)
        <span style="color:#66d9ef">return</span> ans
</code></pre></div><h2 id="236-lowest-common-ancestor-of-a-binary-tree">236 - Lowest Common Ancestor of a Binary Tree</h2>
<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">leetcode</a></p>
<h3 id="problem">Problem</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">lowestCommonAncestor</span>(self, root: <span style="color:#e6db74">&#39;TreeNode&#39;</span>, p: <span style="color:#e6db74">&#39;TreeNode&#39;</span>, q: <span style="color:#e6db74">&#39;TreeNode&#39;</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#e6db74">&#39;TreeNode&#39;</span>:
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> root:
            <span style="color:#66d9ef">return</span> None

        <span style="color:#66d9ef">if</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> p<span style="color:#f92672">.</span>val <span style="color:#f92672">or</span> root<span style="color:#f92672">.</span>val <span style="color:#f92672">==</span> q<span style="color:#f92672">.</span>val:
            <span style="color:#66d9ef">return</span> root

        left <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>lowestCommonAncestor(root<span style="color:#f92672">.</span>left, p, q)
        right <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>lowestCommonAncestor(root<span style="color:#f92672">.</span>right, p, q)

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> left:
            <span style="color:#66d9ef">return</span> right
        <span style="color:#66d9ef">elif</span> <span style="color:#f92672">not</span> right:
            <span style="color:#66d9ef">return</span> left
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> root
</code></pre></div>
</main>

  <footer>
  
  
  <hr/>
  © <a href="http://alfmunny.com">Alfmunny</a> 2019 &ndash; 2020| <a href="https://github.com/alfmunny">Github</a> | <a href="https://twitter.com/alfmunny">Twitter</a>
  
  </footer>
  </body>
</html>

