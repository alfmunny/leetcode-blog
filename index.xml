<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/</link>
    <description>Recent content on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Mar 2020 00:36:00 +0100</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>84 - Largest Rectangle in Histogram</title>
      <link>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</link>
      <pubDate>Mon, 23 Mar 2020 00:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</guid>
      <description>leetcode
Problem Given n non-negative integers representing the histogram&amp;#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Example: Input: [2,1,5,6,2,3] Output: 10 Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
The largest rectangle is shown in the shaded area, which has area = 10 unit.
Notes Main idea is to caculate both left edge and right edge for every entry in the array</description>
    </item>
    
    <item>
      <title>1306 - Jump Game III</title>
      <link>//alfmunny.com/leetcode-blog/posts/1306-jump-game-iii/</link>
      <pubDate>Sun, 22 Mar 2020 20:42:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1306-jump-game-iii/</guid>
      <description>leetcode
Problem Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0. Notice that you can not jump outside of the array at any time. Example 1: Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 index 5 -&amp;gt; index 6 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 2: Input: arr = [4,2,3,0,3,1,2], start = 0 Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 3: Input: arr = [3,0,2,1,2], start = 2 Output: false Explanation: There is no way to reach at index 1 with value 0.</description>
    </item>
    
    <item>
      <title>45 - Jump Game II</title>
      <link>//alfmunny.com/leetcode-blog/posts/45-jump-game-ii/</link>
      <pubDate>Sun, 22 Mar 2020 00:55:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/45-jump-game-ii/</guid>
      <description>leetcode
Problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</description>
    </item>
    
    <item>
      <title>62 - Unique Paths</title>
      <link>//alfmunny.com/leetcode-blog/posts/62-unique-paths/</link>
      <pubDate>Sat, 21 Mar 2020 22:34:22 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/62-unique-paths/</guid>
      <description>leetcode
Problem A robot is located at the top-left corner of a m x n grid (marked &amp;#39;Start&amp;#39; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;#39;Finish&amp;#39; in the diagram below). How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1.</description>
    </item>
    
    <item>
      <title>509 - Fibonacci Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/509-fibonacci-number/</link>
      <pubDate>Sat, 21 Mar 2020 22:31:20 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/509-fibonacci-number/</guid>
      <description>leetcode
Problem The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N &amp;gt; 1. Given N, calculate F(N). Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description>
    </item>
    
    <item>
      <title>91 - Decode Ways</title>
      <link>//alfmunny.com/leetcode-blog/posts/90-decode-ways/</link>
      <pubDate>Sat, 21 Mar 2020 22:28:56 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/90-decode-ways/</guid>
      <description>leetcode
Problem A message containing letters from A-Z is being encoded to numbers using the following mapping: &amp;#39;A&amp;#39; -&amp;gt; 1 &amp;#39;B&amp;#39; -&amp;gt; 2 ... &amp;#39;Z&amp;#39; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: &amp;#34;12&amp;#34; Output: 2 Explanation: It could be decoded as &amp;#34;AB&amp;#34; (1 2) or &amp;#34;L&amp;#34; (12). Example 2: Input: &amp;#34;226&amp;#34; Output: 3 Explanation: It could be decoded as &amp;#34;BZ&amp;#34; (2 26), &amp;#34;VF&amp;#34; (22 6), or &amp;#34;BBF&amp;#34; (2 2 6).</description>
    </item>
    
    <item>
      <title>70 - Climbing Stairs</title>
      <link>//alfmunny.com/leetcode-blog/posts/70-climbing-stairs/</link>
      <pubDate>Sat, 21 Mar 2020 22:25:51 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/70-climbing-stairs/</guid>
      <description>leetcode
Problem You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top.</description>
    </item>
    
    <item>
      <title>55 - Jump Game</title>
      <link>//alfmunny.com/leetcode-blog/posts/55-jump-game/</link>
      <pubDate>Sat, 21 Mar 2020 22:19:29 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/55-jump-game/</guid>
      <description>leetcode
Problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description>
    </item>
    
    <item>
      <title>53 - Maximum Subarray</title>
      <link>//alfmunny.com/leetcode-blog/posts/53-maximum-subarray/</link>
      <pubDate>Sat, 21 Mar 2020 22:16:34 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/53-maximum-subarray/</guid>
      <description>leetcode
Problem Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Notes Dynamic programming problem.
Use nums[i] always store the maximum sum.</description>
    </item>
    
    <item>
      <title>48 - Rotate Image</title>
      <link>//alfmunny.com/leetcode-blog/posts/48-rotate-image/</link>
      <pubDate>Sat, 21 Mar 2020 22:16:23 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/48-rotate-image/</guid>
      <description>leetcode
Problem You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2: Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] Notes Naive solution, to do it one by one.</description>
    </item>
    
    <item>
      <title>41 - First Missing Positive</title>
      <link>//alfmunny.com/leetcode-blog/posts/41-first-missing-positive/</link>
      <pubDate>Sat, 21 Mar 2020 16:29:53 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/41-first-missing-positive/</guid>
      <description>Problem Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Notes Run in O(n) time and uses constant extra space
  Say the length of the array is l, the number must be in 1&amp;hellip;l+1 (also l possible numbers)</description>
    </item>
    
    <item>
      <title>79 - Word Search</title>
      <link>//alfmunny.com/leetcode-blog/posts/79-word-search/</link>
      <pubDate>Sat, 14 Mar 2020 03:00:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/79-word-search/</guid>
      <description>leetcode
Problem Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;E&amp;#39;], [&amp;#39;S&amp;#39;,&amp;#39;F&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;S&amp;#39;], [&amp;#39;A&amp;#39;,&amp;#39;D&amp;#39;,&amp;#39;E&amp;#39;,&amp;#39;E&amp;#39;] ] Given word = &amp;#34;ABCCED&amp;#34;, return true. Given word = &amp;#34;SEE&amp;#34;, return true. Given word = &amp;#34;ABCB&amp;#34;, return false.</description>
    </item>
    
    <item>
      <title>78 - Subsets</title>
      <link>//alfmunny.com/leetcode-blog/posts/78-subsets/</link>
      <pubDate>Sat, 07 Mar 2020 23:59:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/78-subsets/</guid>
      <description>Problem leetcode
Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Notes Three strategies to solve a subset problem:
Recursion, Backtracking, Bitmask
Recursion Iterative version:
Start from empty array [[]]. Step 1: Take 1 into consideration, and add 1 to existing array [[], [1]] Step 2: Take 2 into consideration, and add 2 to existing array [[], [1], [2], [1, 2]] Step 3: Take 3 into consideration, and add 3 to existing array [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] DFS version:</description>
    </item>
    
    <item>
      <title>75 - Sort Colors</title>
      <link>//alfmunny.com/leetcode-blog/posts/75-sort-colors/</link>
      <pubDate>Fri, 06 Mar 2020 17:26:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/75-sort-colors/</guid>
      <description>leetcode
Problem Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library&amp;#39;s sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.</description>
    </item>
    
    <item>
      <title>64 - Minimum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/64-unique-path-sum/</link>
      <pubDate>Wed, 04 Mar 2020 18:47:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/64-unique-path-sum/</guid>
      <description>leetcode
Problem Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. Notes Thinking: It seems to be a greedy algorithm problem.</description>
    </item>
    
    <item>
      <title></title>
      <link>//alfmunny.com/leetcode-blog/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/about/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>