<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode In The Shell</title>
    <link>//alfmunny.com/leetcode-blog/</link>
    <description>Recent content on LeetCode In The Shell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 18 Jul 2020 00:30:00 +0200</lastBuildDate>
    
	<atom:link href="//alfmunny.com/leetcode-blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>461 - Hamming Distance</title>
      <link>//alfmunny.com/leetcode-blog/posts/461-hamming-distance/</link>
      <pubDate>Sat, 18 Jul 2020 00:30:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/461-hamming-distance/</guid>
      <description>leetcode
Problem The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note: 0 ≤ x, y &amp;lt; 231. Example: Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different.</description>
    </item>
    
    <item>
      <title>190 - Reverse Bits</title>
      <link>//alfmunny.com/leetcode-blog/posts/190-reverse-bits/</link>
      <pubDate>Mon, 13 Jul 2020 00:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/190-reverse-bits/</guid>
      <description>leetcode
Problem Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Note: Note that in some languages such as Java, there is no unsigned integer type.</description>
    </item>
    
    <item>
      <title>36 - Valid Sudoku</title>
      <link>//alfmunny.com/leetcode-blog/posts/36-valid-sudoku/</link>
      <pubDate>Sun, 12 Jul 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/36-valid-sudoku/</guid>
      <description>leetcode
Problem Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. Solution class Solution: def isValidSudoku(self, board: List[List[str]]) -&amp;gt; bool: for row in board: nums = [x for x in row if x !</description>
    </item>
    
    <item>
      <title>37 - Sudoku Solver</title>
      <link>//alfmunny.com/leetcode-blog/posts/37-sodoku-solver/</link>
      <pubDate>Fri, 10 Jul 2020 17:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/37-sodoku-solver/</guid>
      <description>leetcode
Problem Write a program to solve a Sudoku puzzle by filling the empty cells. A sudoku solution must satisfy all of the following rules: Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. Empty cells are indicated by the character &amp;#39;.</description>
    </item>
    
    <item>
      <title>LeetCode [145/146]</title>
      <link>//alfmunny.com/leetcode-blog/posts/leetcode/</link>
      <pubDate>Fri, 10 Jul 2020 02:21:54 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/leetcode/</guid>
      <description>41 - First Missing Positive  Problem Notes Solution   48 - Rotate Image  Problem Notes Solution   53 - Maximum Subarray  Problem Notes Solution   55 - Jump Game  Problem Notes Solition   62 - Unique Paths  Problem Notes Solution   64 - Minimum Path Sum  Problem Notes Solution   70 - Climbing Stairs  Problem Notes Solution   91 - Decode Ways  Problem Notes Solution   509 - Fibonacci Number  Problem Notes Solution   75 - Sort Colors  Problem Notes   78 - Subsets  Problem Solution   79 - Word Search  Problem Notes Solution   45 - Jump Game II  Problem Notes Solution   1306 - Jump Game III  Problem Notes Solution   84 - Largest Rectangle in Histogram  Problem Notes Solution   85 - Maximal Rectangle  Problem Notes Solution   121 - Best Time to Buy and Sell Stock  Problem Notes Solution   122 - Best Time to Buy and Sell Stock II  Problem Notes Solution   123 - Best Time to Buy and Sell Stock III  Problem Notes Solution   188 - Best Time to Buy and Sell Stock IV  Problem Notes Solution   309 - Best Time to Buy and Sell Stock with Cooldown  Problem Notes Solution   104 - Maximum Depth of Binary Tree  Problem Notes Solution   21 - Merge Two Sorted Lists  Problem Notes Solution   101 - Symmetric Tree  Problem Notes Solution   198 - House Robber  Problem Notes Solution   300 - Longest Increasing Subsequence  Problem Solution   322 - Coin Change  Problem Notes Solution   152 - Maximum Product Subarray  Problem Notes Solution   96 - Unique Binary Search Trees  Problem Notes Solution   221 - Maximal Square  Problem Notes Solution   279 - Perfect Squares  Problem Notes Solution   647 - Palindromic Substrings  Problem Notes Solution   5 - Longest Palindromic Substring  Problem Notes Solution   136 - Single Number  Problem Notes Solution   202 - Happy Number  Problem Notes Solution   338 - Counting Bits  Problem Notes Solution   494 - Target Sum  Problem Solution   283 - Move Zeros  Problem Solution   416 - Partition Equal Subset Sum  Problem Solution   698 - Partition to K Equal Sum Subsets  Problem Solution   215 - Kth Largest Element in an Array  Problem Solution   49 - Group Anagrams  Problem Solution   876 - Middle of the Linked List  Problem Solution   844 - Backspace String Compare  Problem Solution   155 - Min Stack  Problem Solution   543 - Diameter of Binary Tree  Problem Solution   1046 - Last Stone Weight  Problem Solution   525 - Contiguous Array  Problem Solution   Perform String Shifts  Problem Solution   238 - Product of Array Except Self  Problem Solution   678 - Valid Parenthesis String  Problem Solution   200 - Number of Islands  Problem Solution   46 - Permutations  Problem Solution   47 - Permutations II  Problem Solution   1008 - Construct Binary Search Tree from Preorder Traversal  Problem Solution   105 - Construct Binary Tree from Preorder and Inorder Traversal  Problem Solution   Leftmost Column with at Least a One  Problem Solution   560 Subarray Sum Equals K  Problem Solution   201 - Bitwise AND of Numbers Range  Problem Solution   146 - LRU Cache  Problem Solution   460 - LFU Cache  Problem Solution   437 - Path Sum III  Problem Solution   1143 - Longest Common Subsequence  Problem Solution   887 - Super Egg Drop  Problem Solution   28 - Implement strStr() (KMP Algorithm)  Problem Solution   169 - Majority Element  Problem Solution   448 - Find All Numbers Disappeard in an Array  Problem Solution   124 - Binary Tree Maximum Path Sum  Problem Solution   278 - First Bad Version  Problem Solution   106 - Construct Binary Tree from Inorder and Postorder Traversal  Problem Solution   128 - Longest Consecutive Sequence  Problem Solution   98 - Validate Binary Search Tree  Problem Solution   1009 - Complement of Base 10 Integer  Problem Solution   337 - House Robber III  Problem Solution   Cousins in Binary Tree  Problem Solution   1232 - Check If It Is a Straight Line  Problem Solution   733 - Flood Fill  Problem Solution   997 - Find the Town Judge  Problem Solution   540 - Single Element in a Sorted Array  Problem Solution   402 - Remove K Digits  Problem Solution   208 - Implement Trie (Prefix Tree)  Problem Solution   918 - Maximum Sum Circular Subarray  Problem Solution   328 - Odd Even Linked List  Problem Solution   438 - Find All Anagrams in a String  Problem Solution   567 - Permutation in String  Problem Solution   901 - Onine Stock Span  Problem Solution   230 - Kth Smallest Element in a BST  Problem Solution   1277 - Count Square Submatrices with All Ones  Problem Solution   76 - Minimum Window Substring  Problem Solution   451 - Sort Characters By Frequency  Problem Solution Similar Problems   986 - Interval List Intersections  Problem Solution   1035 - Uncrossed Lines  Problem Solution   886 - Possible Bipartition  Problem Solution   207 - Course Schedule  Problem Solution   210 - Course Schedule II  Problem Solution   973 - K Closest Points to Origin  Problem Solution   72 - Edit Distance  Problem Solution   226 - Invert Binary Tree  Problem Solution   746 - Min Cost Climbing Stairs  Problem Solution   237 - Delete Node in a Linked List  Problem Solution   1029 - Two City Scheduling  Problem Solution   528 - Random Pick with Weight  Problem Solution   518 - Coin Change 2  Problem Solution   231 - Power of Two  Problem Solution   406 - Queue Reconstruction by Height  Problem Solution   213 - House Robber II  Problem Solution   38 - Count and Say  Problem Solution   66 - Plus One  Problem Solution   392 - Is Subsequence  Problem Solution   40 - Combination Sum II  Problem Solution   39 Combination Sum  Problem Solution   377 - Combination Sum IV  Problem Solution   216 - Combination Sum III  Problem Solution   47 - Permutations II  Problem Solution   51 - N-Queens  Problem Solution   52 - N-Queens II  Problem Solution   77 - Combinations  Problem Solution   90 - Subsets II  Problem Solution   100 - Same Tree  Problem Solution   112 - Path Sum  Problem Solution   113 - Path Sum II  Problem Solution   118 - Pascal&amp;rsquo;s Triangle  Problem Solution   54 - Spiral Matrix  Problem Solution   58 - Length of Last Word  Problem Solution   59 - Spiral Matrix II  Problem Solution   61 - Rotate List  Problem Solution   63 - Unique Paths II  Problem Solution   74 - Search a 2D Matrix  Problem Solution   162 - Find Peak Element  Problem Solution   83 - Remove Duplicates from Sorted List  Problem Solution   95 - Unique Binary Search Trees II  Problem Solution   222 - Count Complete Tree Nodes  Problem Solution   130 - Surrounded Regions  Problem Solution   129 - Sum Root to Leaf Numbers  Problem Solution   988 - Smallest String Starting From Leaf  Problem Solution   303 - Range Sum Query - Immutable  Problem Solution   264 - Ugly Number II  Problem Solution   263 - Ugly Number  Problem Solution   332 - Reconstruct Itinerary  Problem Solution   212 - Word Search II  Problem Solution   441 - Arranging Coins  Problem Solution   107 - Binary Tree Level Order Traversal II  Problem Solution   463 - Island Perimeter  Problem Solution   695 - Max Area of Island  Problem Solution   15 - 3SUM  Problem Solution   10 - Regular Expression Matching  Problem Solution    41 - First Missing Positive Problem Given an unsorted integer array, find the smallest missing positive integer.</description>
    </item>
    
    <item>
      <title>10 - Regular Expression Matching</title>
      <link>//alfmunny.com/leetcode-blog/posts/10-regular-expression-matching/</link>
      <pubDate>Fri, 10 Jul 2020 02:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/10-regular-expression-matching/</guid>
      <description>leetcode
Problem Given an input string (s) and a pattern (p), implement regular expression matching with support for &amp;#39;.&amp;#39; and &amp;#39;*&amp;#39;. &amp;#39;.&amp;#39; Matches any single character. &amp;#39;*&amp;#39; Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *.</description>
    </item>
    
    <item>
      <title>15 - 3SUM</title>
      <link>//alfmunny.com/leetcode-blog/posts/15-3sum/</link>
      <pubDate>Thu, 09 Jul 2020 23:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/15-3sum/</guid>
      <description>leetcode
Problem Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Solution class Solution: def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]: if len(nums) &amp;lt; 3: return [] ans = [] nums.</description>
    </item>
    
    <item>
      <title>695 - Max Area of Island</title>
      <link>//alfmunny.com/leetcode-blog/posts/695-max-area-of-island/</link>
      <pubDate>Tue, 07 Jul 2020 16:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/695-max-area-of-island/</guid>
      <description>leetcode
Problem Given a non-empty 2D array grid of 0&amp;#39;s and 1&amp;#39;s, an island is a group of 1&amp;#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6.</description>
    </item>
    
    <item>
      <title>463 - Island Perimeter</title>
      <link>//alfmunny.com/leetcode-blog/posts/463-island-perimeter/</link>
      <pubDate>Tue, 07 Jul 2020 16:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/463-island-perimeter/</guid>
      <description>leetcode
Problem You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn&amp;#39;t have &amp;#34;lakes&amp;#34; (water inside that isn&amp;#39;t connected to the water around the island). One cell is a square with side length 1.</description>
    </item>
    
    <item>
      <title>107 - Binary Tree Level Order Traversal II</title>
      <link>//alfmunny.com/leetcode-blog/posts/107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Fri, 03 Jul 2020 22:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/107-binary-tree-level-order-traversal-ii/</guid>
      <description>leetcode
Problem Given a binary tree, return the bottom-up level order traversal of its nodes&amp;#39; values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as: [ [15,7], [9,20], [3] ] Solution class Solution: def levelOrderBottom(self, root: TreeNode) -&amp;gt; List[List[int]]: if not root: return [] queue = [root] stack = [] while queue: next_queue = [] tmp = [] while queue: n = queue.</description>
    </item>
    
    <item>
      <title>441 - Arranging Coins</title>
      <link>//alfmunny.com/leetcode-blog/posts/441-arranging-coins/</link>
      <pubDate>Wed, 01 Jul 2020 23:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/441-arranging-coins/</guid>
      <description>leetcode
Problem You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins. Given n, find the total number of full staircase rows that can be formed. n is a non-negative integer and fits within the range of a 32-bit signed integer. Example 1: n = 5 The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ Because the 3rd row is incomplete, we return 2.</description>
    </item>
    
    <item>
      <title>212 - Word Search II</title>
      <link>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</link>
      <pubDate>Wed, 01 Jul 2020 00:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/212-word-search-ii/</guid>
      <description>leetcode
Problem Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input: board = [ [&amp;#39;o&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;n&amp;#39;], [&amp;#39;e&amp;#39;,&amp;#39;t&amp;#39;,&amp;#39;a&amp;#39;,&amp;#39;e&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;h&amp;#39;,&amp;#39;k&amp;#39;,&amp;#39;r&amp;#39;], [&amp;#39;i&amp;#39;,&amp;#39;f&amp;#39;,&amp;#39;l&amp;#39;,&amp;#39;v&amp;#39;] ] words = [&amp;#34;oath&amp;#34;,&amp;#34;pea&amp;#34;,&amp;#34;eat&amp;#34;,&amp;#34;rain&amp;#34;] Output: [&amp;#34;eat&amp;#34;,&amp;#34;oath&amp;#34;] Note: All inputs are consist of lowercase letters a-z.</description>
    </item>
    
    <item>
      <title>332 - Reconstruct Itinerary</title>
      <link>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinerary/</link>
      <pubDate>Mon, 29 Jun 2020 23:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinerary/</guid>
      <description>leetcode
Problem Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&amp;#34;JFK&amp;#34;, &amp;#34;LGA&amp;#34;] has a smaller lexical order than [&amp;#34;JFK&amp;#34;, &amp;#34;LGB&amp;#34;].</description>
    </item>
    
    <item>
      <title>332 - Reconstruct Itinrary</title>
      <link>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinrary/</link>
      <pubDate>Mon, 29 Jun 2020 23:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/332-reconstruct-itinrary/</guid>
      <description>leetcode
Problem Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [&amp;#34;JFK&amp;#34;, &amp;#34;LGA&amp;#34;] has a smaller lexical order than [&amp;#34;JFK&amp;#34;, &amp;#34;LGB&amp;#34;].</description>
    </item>
    
    <item>
      <title>263 - Ugly Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/263-ugly-number/</link>
      <pubDate>Sat, 27 Jun 2020 23:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/263-ugly-number/</guid>
      <description>leetcode
Problem Write a program to check whether a given number is an ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example 1: Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2: Input: 8 Output: true Explanation: 8 = 2 × 2 × 2 Example 3: Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7.</description>
    </item>
    
    <item>
      <title>264 - Ugly Number II</title>
      <link>//alfmunny.com/leetcode-blog/posts/264-ugly-number-ii/</link>
      <pubDate>Sat, 27 Jun 2020 23:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/264-ugly-number-ii/</guid>
      <description>leetcode
Problem Write a program to find the n-th ugly number. Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. Example: Input: n = 10 Output: 12 Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers. Note: 1 is typically treated as an ugly number. n does not exceed 1690. Solution class Solution: ugly = sorted(2**a * 3**b * 5**c for a in range(32) for b in range(32) for c in range(32)) def nthUglyNumber(self, n: int) -&amp;gt; int: return self.</description>
    </item>
    
    <item>
      <title>303 - Range Sum Query - Immutable</title>
      <link>//alfmunny.com/leetcode-blog/posts/303-range-sum-query-immutable/</link>
      <pubDate>Sat, 27 Jun 2020 15:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/303-range-sum-query-immutable/</guid>
      <description>leetcode
Problem Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Note: You may assume that the array does not change. There are many calls to sumRange function. Solution class NumArray: def __init__(self, nums: List[int]): self.dp = list(nums) self.</description>
    </item>
    
    <item>
      <title>988 - Smallest String Starting From Leaf</title>
      <link>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</link>
      <pubDate>Sat, 27 Jun 2020 15:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/998-smallest-string-starting-from-leaf/</guid>
      <description>leetcode
Problem Given the root of a binary tree, each node has a value from 0 to 25 representing the letters &amp;#39;a&amp;#39; to &amp;#39;z&amp;#39;: a value of 0 represents &amp;#39;a&amp;#39;, a value of 1 represents &amp;#39;b&amp;#39;, and so on. Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root. (As a reminder, any shorter prefix of a string is lexicographically smaller: for example, &amp;#34;ab&amp;#34; is lexicographically smaller than &amp;#34;aba&amp;#34;.</description>
    </item>
    
    <item>
      <title>130 - Surrounded Regions</title>
      <link>//alfmunny.com/leetcode-blog/posts/130-surrounded-regions/</link>
      <pubDate>Fri, 26 Jun 2020 01:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/130-surrounded-regions/</guid>
      <description>leetcode
Problem Given a 2D board containing &amp;#39;X&amp;#39; and &amp;#39;O&amp;#39; (the letter O), capture all regions surrounded by &amp;#39;X&amp;#39;. A region is captured by flipping all &amp;#39;O&amp;#39;s into &amp;#39;X&amp;#39;s in that surrounded region. Example: X X X X X O O X X X O X X O X X After running your function, the board should be: X X X X X X X X X X X X X O X X Explanation: Surrounded regions shouldn’t be on the border, which means that any &amp;#39;O&amp;#39; on the border of the board are not flipped to &amp;#39;X&amp;#39;.</description>
    </item>
    
    <item>
      <title>222 - Count Complete Tree Nodes</title>
      <link>//alfmunny.com/leetcode-blog/posts/222-count-complete-tree-nodes/</link>
      <pubDate>Tue, 23 Jun 2020 23:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/222-count-complete-tree-nodes/</guid>
      <description>leetcode
Problem Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Example: Input: 1 / \ 2 3 / \ / 4 5 6 Output: 6 Solution class Solution: def countNodes(self, root: TreeNode) -&amp;gt; int: if not root: return 0 rd = self.</description>
    </item>
    
    <item>
      <title>95 - Unique Binary Search Trees II</title>
      <link>//alfmunny.com/leetcode-blog/posts/95-unique-binary-search-treea-ii/</link>
      <pubDate>Sat, 20 Jun 2020 02:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/95-unique-binary-search-treea-ii/</guid>
      <description>leetcode
Problem Given an integer n, generate all structurally unique BST&amp;#39;s (binary search trees) that store values 1 ... n. Example: Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST&amp;#39;s shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 Solution class Solution: def generateTrees(self, n: int) -&amp;gt; List[TreeNode]: if n == 0: return [] return self.</description>
    </item>
    
    <item>
      <title>83 - Remove Duplicates from Sorted List</title>
      <link>//alfmunny.com/leetcode-blog/posts/83-remove-duplicates-from-sorted-list/</link>
      <pubDate>Sat, 20 Jun 2020 01:42:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/83-remove-duplicates-from-sorted-list/</guid>
      <description>leetcode
Problem Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2 Example 2: Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3 Solution class Solution: def deleteDuplicates(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head first = head second = first.next while second: if first.val == second.val: first.next = second.next second = first.next else: first, second = second, second.next return head </description>
    </item>
    
    <item>
      <title>162 - Find Peak Element</title>
      <link>//alfmunny.com/leetcode-blog/posts/162-find-peak-element/</link>
      <pubDate>Thu, 18 Jun 2020 16:09:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/162-find-peak-element/</guid>
      <description>leetcode
Problem A peak element is an element that is greater than its neighbors. Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that nums[-1] = nums[n] = -∞. Example 1: Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description>
    </item>
    
    <item>
      <title>74 - Search a 2D Matrix</title>
      <link>//alfmunny.com/leetcode-blog/posts/74-search-a-2d-matrix/</link>
      <pubDate>Thu, 18 Jun 2020 14:46:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/74-search-a-2d-matrix/</guid>
      <description>leetcode
Problem Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2: Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 13 Output: false Solution class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: if not matrix or not matrix[0]: return False rl, rr = 0, len(matrix) - 1 cl, cr = 0, len(matrix[0]) - 1 while rl &amp;lt;= rr: mid = (rl + rr) // 2 if target &amp;lt; matrix[mid][0]: rr = mid - 1 elif target &amp;gt; matrix[mid][-1]: rl = mid + 1 else: rl = mid break if rl &amp;gt; rr: return False while cl &amp;lt;= cr: mid = (cl + cr) // 2 if target &amp;lt; matrix[rl][mid]: cr = mid - 1 elif target &amp;gt; matrix[rl][mid]: cl = mid + 1 else: return True return False </description>
    </item>
    
    <item>
      <title>63 - Unique Paths II</title>
      <link>//alfmunny.com/leetcode-blog/posts/63-unique-paths-ii/</link>
      <pubDate>Thu, 18 Jun 2020 14:25:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/63-unique-paths-ii/</guid>
      <description>leetcode
Problem A robot is located at the top-left corner of a m x n grid (marked &amp;#39;Start&amp;#39; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;#39;Finish&amp;#39; in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be?</description>
    </item>
    
    <item>
      <title>61 - Rotate List</title>
      <link>//alfmunny.com/leetcode-blog/posts/61-rotate-list/</link>
      <pubDate>Thu, 18 Jun 2020 14:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/61-rotate-list/</guid>
      <description>leetcode
Problem Given a linked list, rotate the list to the right by k places, where k is non-negative. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 Output: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Explanation: rotate 1 steps to the right: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL rotate 2 steps to the right: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Example 2: Input: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL, k = 4 Output: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Explanation: rotate 1 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL rotate 2 steps to the right: 1-&amp;gt;2-&amp;gt;0-&amp;gt;NULL rotate 3 steps to the right: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL rotate 4 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Solution Note: k may be larger than the total count of nodes.</description>
    </item>
    
    <item>
      <title>59 - Spiral Matrix II</title>
      <link>//alfmunny.com/leetcode-blog/posts/59-spiral-matrix-ii/</link>
      <pubDate>Thu, 18 Jun 2020 13:59:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/59-spiral-matrix-ii/</guid>
      <description>leetcode
Problem Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] Solution class Solution: def generateMatrix(self, n: int) -&amp;gt; List[List[int]]: matrix = [[0] * n for _ in range(n)] step = [[0,1], [1, 0], [0, -1], [-1, 0]] i = j = di = 0 for x in range(1, n * n+1): matrix[i][j] = x ni = i + step[di][0] nj = j + step[di][1] if 0 &amp;lt;= ni &amp;lt; n and 0 &amp;lt;= nj &amp;lt; n and not matrix[ni][nj]: i, j = ni, nj else: di = (di + 1) % 4 i, j = i + step[di][0], j + step[di][1] return matrix </description>
    </item>
    
    <item>
      <title>58 - Length of Last Word</title>
      <link>//alfmunny.com/leetcode-blog/posts/58-length-of-last-word/</link>
      <pubDate>Thu, 18 Jun 2020 13:46:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/58-length-of-last-word/</guid>
      <description>leetcode
Problem Given a string s consists of upper/lower-case alphabets and empty space characters &amp;#39; &amp;#39;, return the length of last word (last word means the last appearing word if we loop from left to right) in the string. If the last word does not exist, return 0. Note: A word is defined as a maximal substring consisting of non-space characters only. Example: Input: &amp;#34;Hello World&amp;#34; Output: 5 Solution class Solution: def lengthOfLastWord(self, s: str) -&amp;gt; int: if s.</description>
    </item>
    
    <item>
      <title>54 - Spiral Matrix</title>
      <link>//alfmunny.com/leetcode-blog/posts/54-spiral-matrix/</link>
      <pubDate>Thu, 18 Jun 2020 13:34:19 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/54-spiral-matrix/</guid>
      <description>leetcode
Problem Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Solution class Solution: def spiralOrder(self, matrix: List[List[int]]) -&amp;gt; List[int]: if not matrix: return [] i = j = 0 m = len(matrix) n = len(matrix[0]) marked = [[False] * n for _ in matrix] step = [[0, 1], [1, 0], [0, -1], [-1, 0]] i = j = di = 0 ans = [] for _ in range(m*n): ans.</description>
    </item>
    
    <item>
      <title>118 - Pascal&#39;s Triangle</title>
      <link>//alfmunny.com/leetcode-blog/posts/118-pascals-triangle/</link>
      <pubDate>Wed, 17 Jun 2020 23:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/118-pascals-triangle/</guid>
      <description>leetcode
Problem Given a non-negative integer numRows, generate the first numRows of Pascal&amp;#39;s triangle. Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] Solution class Solution: def generate(self, numRows: int) -&amp;gt; List[List[int]]: ans = [] for i in range(1, numRows+1): level = [1] * i if ans: for j in range(1, i-1): level[j] = ans[-1][j-1] + ans[-1][j] ans.append(level) return ans </description>
    </item>
    
    <item>
      <title>113 - Path Sum II</title>
      <link>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</link>
      <pubDate>Wed, 17 Jun 2020 23:51:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/113-path-sum-ii/</guid>
      <description>leetcode
Problem Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;#39;s sum equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return: [ [5,4,11,2], [5,8,4,5] ] Solution class Solution: def pathSum(self, root: TreeNode, sum: int) -&amp;gt; List[List[int]]: ans = [] self.</description>
    </item>
    
    <item>
      <title>112 - Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/112-path-sum/</link>
      <pubDate>Wed, 17 Jun 2020 23:50:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/112-path-sum/</guid>
      <description>leetcode
Problem Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. Note: A leaf is a node with no children. Example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>100 - Same Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/100-same-tree/</link>
      <pubDate>Wed, 17 Jun 2020 23:48:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/100-same-tree/</guid>
      <description>leetcode
Problem Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2] Output: false Solution class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&amp;gt; bool: if p and not q: return False if not p and q: return False if not p and not q: return True if p.</description>
    </item>
    
    <item>
      <title>90 - Subsets II</title>
      <link>//alfmunny.com/leetcode-blog/posts/90-subsets-ii/</link>
      <pubDate>Wed, 17 Jun 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/90-subsets-ii/</guid>
      <description>leetcode
Problem Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] Solution class Solution: def subsetsWithDup(self, nums: List[int]) -&amp;gt; List[List[int]]: ans = [] marked = [False] * len(nums) self.dfs(sorted(nums), 0, [], ans, marked) return ans def dfs(self, nums, index, path, ans, marked): ans.</description>
    </item>
    
    <item>
      <title>77 - Combinations</title>
      <link>//alfmunny.com/leetcode-blog/posts/77-combinations/</link>
      <pubDate>Fri, 12 Jun 2020 17:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/77-combinations/</guid>
      <description>leetcode
Problem Share Given two integers n and k, return all possible combinations of k numbers out of 1 ... n. Example: Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] Solution class Solution: def combine(self, n: int, k: int) -&amp;gt; List[List[int]]: ans = [] self.dfs(1, n, k, [], ans) return ans def dfs(self, index, n, k, path, ans): if k == 0: ans.</description>
    </item>
    
    <item>
      <title>52 - N-Queens II</title>
      <link>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</link>
      <pubDate>Fri, 12 Jun 2020 17:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/52-n-queens-ii/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return the number of distinct solutions to the n-queens puzzle. Solution class Solution: def totalNQueens(self, n): self.ans = 0 self.dfs(0, n, []) return self.ans def dfs(self, row, n, path): if row == n and len(path) == n: self.ans += 1 for i in range(n): if self.</description>
    </item>
    
    <item>
      <title>51 - N-Queens</title>
      <link>//alfmunny.com/leetcode-blog/posts/51-n-queens/</link>
      <pubDate>Fri, 12 Jun 2020 17:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/51-n-queens/</guid>
      <description>leetcode
Problem The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens&amp;#39; placement, where &amp;#39;Q&amp;#39; and &amp;#39;.&amp;#39; both indicate a queen and an empty space respectively. Solution class Solution: def solveNQueens(self, n): ans = [] self.dfs(0, n, [], ans) return ans def dfs(self, row, n, path, ans): if row == n and len(path) == n: ans.</description>
    </item>
    
    <item>
      <title>17 - Letter Combinations of a Phone Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/17-letter-combinations-of-a-phone-number/</link>
      <pubDate>Thu, 11 Jun 2020 16:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/17-letter-combinations-of-a-phone-number/</guid>
      <description>leetcode
Problem Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: &amp;#34;23&amp;#34; Output: [&amp;#34;ad&amp;#34;, &amp;#34;ae&amp;#34;, &amp;#34;af&amp;#34;, &amp;#34;bd&amp;#34;, &amp;#34;be&amp;#34;, &amp;#34;bf&amp;#34;, &amp;#34;cd&amp;#34;, &amp;#34;ce&amp;#34;, &amp;#34;cf&amp;#34;]. Solution Solution 1: DFS class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: m = { 2: &amp;#34;abc&amp;#34;, 3: &amp;#34;def&amp;#34;, 4: &amp;#34;ghi&amp;#34;, 5: &amp;#34;jkl&amp;#34;, 6: &amp;#34;mno&amp;#34;, 7: &amp;#34;pqrs&amp;#34;, 8: &amp;#34;tuv&amp;#34;, 9: &amp;#34;wxyz&amp;#34; } ans = [] self.</description>
    </item>
    
    <item>
      <title>216 - Combination Sum III</title>
      <link>//alfmunny.com/leetcode-blog/posts/216-combination-sum-iii/</link>
      <pubDate>Thu, 11 Jun 2020 15:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/216-combination-sum-iii/</guid>
      <description>leetcode
Problem Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Note: All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] Example 2: Input: k = 3, n = 9 Output: [[1,2,6], [1,3,5], [2,3,4]] Solution class Solution: def combinationSum3(self, k: int, n: int) -&amp;gt; List[List[int]]: ans = [] self.</description>
    </item>
    
    <item>
      <title>377 - Combination Sum IV</title>
      <link>//alfmunny.com/leetcode-blog/posts/337-combination-sum-iv/</link>
      <pubDate>Thu, 11 Jun 2020 15:12:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/337-combination-sum-iv/</guid>
      <description>leetcode
Problem Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target. Example: nums = [1, 2, 3] target = 4 The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Note that different sequences are counted as different combinations. Therefore the output is 7.</description>
    </item>
    
    <item>
      <title>39 Combination Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/39-combination-sum/</link>
      <pubDate>Wed, 10 Jun 2020 23:55:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/39-combination-sum/</guid>
      <description>leetcode
Problem Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5], target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] Solution Backtracking problem.</description>
    </item>
    
    <item>
      <title>40 - Combination Sum II</title>
      <link>//alfmunny.com/leetcode-blog/posts/40-combination-sum-ii/</link>
      <pubDate>Wed, 10 Jun 2020 23:33:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/40-combination-sum-ii/</guid>
      <description>leetcode
Problem Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number in candidates may only be used once in the combination. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ] Solution Backtracking problem.</description>
    </item>
    
    <item>
      <title>392 - Is Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/392-is-subsequence/</link>
      <pubDate>Tue, 09 Jun 2020 23:56:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/392-is-subsequence/</guid>
      <description>leetcode
Problem Given a string s and a string t, check if s is subsequence of t. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &amp;#34;ace&amp;#34; is a subsequence of &amp;#34;abcde&amp;#34; while &amp;#34;aec&amp;#34; is not). Follow up: If there are lots of incoming S, say S1, S2, .</description>
    </item>
    
    <item>
      <title>66 - Plus One</title>
      <link>//alfmunny.com/leetcode-blog/posts/66-plus-one/</link>
      <pubDate>Mon, 08 Jun 2020 23:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/66-plus-one/</guid>
      <description>leetcode
Problem Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description>
    </item>
    
    <item>
      <title>38 - Count and Say</title>
      <link>//alfmunny.com/leetcode-blog/posts/38-count-and-say/</link>
      <pubDate>Mon, 08 Jun 2020 23:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/38-count-and-say/</guid>
      <description>leetcode
Problem The count-and-say sequence is the sequence of integers with the first five terms as following: 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 is read off as &amp;#34;one 1&amp;#34; or 11. 11 is read off as &amp;#34;two 1s&amp;#34; or 21. 21 is read off as &amp;#34;one 2, then one 1&amp;#34; or 1211. Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</description>
    </item>
    
    <item>
      <title>213 - House Robber II</title>
      <link>//alfmunny.com/leetcode-blog/posts/213-house-robber-ii/</link>
      <pubDate>Mon, 08 Jun 2020 23:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/213-house-robber-ii/</guid>
      <description>leetcode
Problem You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>406 - Queue Reconstruction by Height</title>
      <link>//alfmunny.com/leetcode-blog/posts/406-queue-reconstruction-by-height/</link>
      <pubDate>Mon, 08 Jun 2020 22:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/406-queue-reconstruction-by-height/</guid>
      <description>leetcode
Problem Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note: The number of people is less than 1,100.</description>
    </item>
    
    <item>
      <title>231 - Power of Two</title>
      <link>//alfmunny.com/leetcode-blog/posts/231-power-of-two/</link>
      <pubDate>Mon, 08 Jun 2020 22:35:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/231-power-of-two/</guid>
      <description>leetcode
Problem Given an integer, write a function to determine if it is a power of two. Example 1: Input: 1 Output: true Explanation: 20 = 1 Example 2: Input: 16 Output: true Explanation: 24 = 16 Example 3: Input: 218 Output: false Solution Solution 1: Straight forward class Solution: def powerOfTwo(self, n): while n != 1: if n % 2: return False n //= 2 return True Solution 2: Bit manipulation power of two: n = 1000000 n - 1 = 111111 n &amp;amp; (n-1) == 0</description>
    </item>
    
    <item>
      <title>518 - Coin Change 2</title>
      <link>//alfmunny.com/leetcode-blog/posts/518-coin-change-2/</link>
      <pubDate>Sun, 07 Jun 2020 21:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/518-coin-change-2/</guid>
      <description>leetcode
Problem You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin. Example 1: Input: amount = 5, coins = [1, 2, 5] Output: 4 Explanation: there are four ways to make up the amount: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 Example 2: Input: amount = 3, coins = [2] Output: 0 Explanation: the amount of 3 cannot be made up just with coins of 2.</description>
    </item>
    
    <item>
      <title>528 - Random Pick with Weight</title>
      <link>//alfmunny.com/leetcode-blog/posts/528-random-pick-with-weight/</link>
      <pubDate>Fri, 05 Jun 2020 22:00:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/528-random-pick-with-weight/</guid>
      <description>leetcode
Problem Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight. Note: 1 &amp;lt;= w.length &amp;lt;= 10000 1 &amp;lt;= w[i] &amp;lt;= 10^5 pickIndex will be called at most 10000 times. Example 1: Input: [&amp;#34;Solution&amp;#34;,&amp;#34;pickIndex&amp;#34;] [[[1]],[]] Output: [null,0] Example 2: Input: [&amp;#34;Solution&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;,&amp;#34;pickIndex&amp;#34;] [[[1,3]],[],[],[],[],[]] Output: [null,0,1,1,1,0] Explanation of Input Syntax: The input is two lists: the subroutines called and their arguments.</description>
    </item>
    
    <item>
      <title>1029 - Two City Scheduling</title>
      <link>//alfmunny.com/leetcode-blog/posts/1029-two-city-scheduling/</link>
      <pubDate>Wed, 03 Jun 2020 20:30:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1029-two-city-scheduling/</guid>
      <description>leetcode
Problem There are 2N people a company is planning to interview. The cost of flying the i-th person to city A is costs[i][0], and the cost of flying the i-th person to city B is costs[i][1]. Return the minimum cost to fly every person to a city such that exactly N people arrive in each city. Example 1: Input: [[10,20],[30,200],[400,50],[30,20]] Output: 110 Explanation: The first person goes to city A for a cost of 10.</description>
    </item>
    
    <item>
      <title>237 - Delete Node in a Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/237-delete-node-in-a-linked-list/</link>
      <pubDate>Wed, 03 Jun 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/237-delete-node-in-a-linked-list/</guid>
      <description>leetcode
Problem Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Given linked list -- head = [4,5,1,9], which looks like following: Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&amp;gt; 1 -&amp;gt; 9 after calling your function. Example 2: Input: head = [4,5,1,9], node = 1 Output: [4,5,9] Explanation: You are given the third node with value 1, the linked list should become 4 -&amp;gt; 5 -&amp;gt; 9 after calling your function.</description>
    </item>
    
    <item>
      <title>746 - Min Cost Climbing Stairs</title>
      <link>//alfmunny.com/leetcode-blog/posts/746-min-cost-climbing-stairs/</link>
      <pubDate>Tue, 02 Jun 2020 00:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/746-min-cost-climbing-stairs/</guid>
      <description>leetcode
Problem On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</description>
    </item>
    
    <item>
      <title>226 - Invert Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/226-invert-binary-tree/</link>
      <pubDate>Mon, 01 Jun 2020 23:36:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/226-invert-binary-tree/</guid>
      <description>leetcode
Problem Invert a binary tree. Example: Input: 4 / \ 2 7 / \ / \ 1 3 6 9 Output: 4 / \ 7 2 / \ / \ 9 6 3 1 Solution class Solution: def invertTree(self): if root: tmp = root.left root.left = self.invertTree(root.right) root.right = self.invertTree(tmp) return root </description>
    </item>
    
    <item>
      <title>72 - Edit Distance</title>
      <link>//alfmunny.com/leetcode-blog/posts/72-edit-distance/</link>
      <pubDate>Sun, 31 May 2020 17:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/72-edit-distance/</guid>
      <description>leetcode
Problem Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2. You have the following 3 operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = &amp;#34;horse&amp;#34;, word2 = &amp;#34;ros&amp;#34; Output: 3 Explanation: horse -&amp;gt; rorse (replace &amp;#39;h&amp;#39; with &amp;#39;r&amp;#39;) rorse -&amp;gt; rose (remove &amp;#39;r&amp;#39;) rose -&amp;gt; ros (remove &amp;#39;e&amp;#39;) Example 2: Input: word1 = &amp;#34;intention&amp;#34;, word2 = &amp;#34;execution&amp;#34; Output: 5 Explanation: intention -&amp;gt; inention (remove &amp;#39;t&amp;#39;) inention -&amp;gt; enention (replace &amp;#39;i&amp;#39; with &amp;#39;e&amp;#39;) enention -&amp;gt; exention (replace &amp;#39;n&amp;#39; with &amp;#39;x&amp;#39;) exention -&amp;gt; exection (replace &amp;#39;n&amp;#39; with &amp;#39;c&amp;#39;) exection -&amp;gt; execution (insert &amp;#39;u&amp;#39;) Solution class Solution: def minDistance(self, word1: str, word2: str) -&amp;gt; int: dp = [[0] * (1+len(word2)) for _ in range(1+len(word1))] for i in range(1+len(word1)): dp[i][0] = i for j in range(1+len(word2)): dp[0][j] = j for i in range(1, 1+len(word1)): for j in range(1, 1+len(word2)): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j], dp[i-1][j-1], dp[i][j-1]) + 1 return dp[-1][-1] </description>
    </item>
    
    <item>
      <title>973 - K Closest Points to Origin</title>
      <link>//alfmunny.com/leetcode-blog/posts/973-k-closest-points-to-origin/</link>
      <pubDate>Sat, 30 May 2020 23:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/973-k-closest-points-to-origin/</guid>
      <description>leetcode
Problem We have a list of points on the plane. Find the K closest points to the origin (0, 0). (Here, the distance between two points on a plane is the Euclidean distance.) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.) Example 1: Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10).</description>
    </item>
    
    <item>
      <title>210 - Course Schedule II</title>
      <link>//alfmunny.com/leetcode-blog/posts/210-course-schedule-ii/</link>
      <pubDate>Fri, 29 May 2020 20:45:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/210-course-schedule-ii/</guid>
      <description>leetcode
Problem There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them.</description>
    </item>
    
    <item>
      <title>207 - Course Schedule</title>
      <link>//alfmunny.com/leetcode-blog/posts/207-course-schedule/</link>
      <pubDate>Fri, 29 May 2020 19:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/207-course-schedule/</guid>
      <description>leetcode
Problem There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? Example 1: Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take.</description>
    </item>
    
    <item>
      <title>886 - Possible Bipartition</title>
      <link>//alfmunny.com/leetcode-blog/posts/886-possible-bipartition/</link>
      <pubDate>Wed, 27 May 2020 16:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/886-possible-bipartition/</guid>
      <description>leetcode
Problem Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group. Return true if and only if it is possible to split everyone into two groups in this way.</description>
    </item>
    
    <item>
      <title>1035 - Uncrossed Lines</title>
      <link>//alfmunny.com/leetcode-blog/posts/1035-uncrossed-lines/</link>
      <pubDate>Mon, 25 May 2020 16:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1035-uncrossed-lines/</guid>
      <description>leetcode
Problem We write the integers of A and B (in the order they are given) on two separate horizontal lines. Now, we may draw connecting lines: a straight line connecting two numbers A[i] and B[j] such that: A[i] == B[j]; The line we draw does not intersect any other connecting (non-horizontal) line. Note that a connecting lines cannot intersect even at the endpoints: each number can only belong to one connecting line.</description>
    </item>
    
    <item>
      <title>986 - Interval List Intersections</title>
      <link>//alfmunny.com/leetcode-blog/posts/996-interval-list-intersections/</link>
      <pubDate>Sun, 24 May 2020 01:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/996-interval-list-intersections/</guid>
      <description>leetcode
Problem Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order. Return the intersection of these two interval lists. (Formally, a closed interval [a, b] (with a &amp;lt;= b) denotes the set of real numbers x with a &amp;lt;= x &amp;lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.</description>
    </item>
    
    <item>
      <title>451 - Sort Characters By Frequency</title>
      <link>//alfmunny.com/leetcode-blog/posts/451-sort-characters-by-frequency/</link>
      <pubDate>Fri, 22 May 2020 14:19:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/451-sort-characters-by-frequency/</guid>
      <description>leetcode
Problem Given a string, sort it in decreasing order based on the frequency of characters. Example 1: Input: &amp;#34;tree&amp;#34; Output: &amp;#34;eert&amp;#34; Explanation: &amp;#39;e&amp;#39; appears twice while &amp;#39;r&amp;#39; and &amp;#39;t&amp;#39; both appear once. So &amp;#39;e&amp;#39; must appear before both &amp;#39;r&amp;#39; and &amp;#39;t&amp;#39;. Therefore &amp;#34;eetr&amp;#34; is also a valid answer. Example 2: Input: &amp;#34;cccaaa&amp;#34; Output: &amp;#34;cccaaa&amp;#34; Explanation: Both &amp;#39;c&amp;#39; and &amp;#39;a&amp;#39; appear three times, so &amp;#34;aaaccc&amp;#34; is also a valid answer. Note that &amp;#34;cacaca&amp;#34; is incorrect, as the same characters must be together.</description>
    </item>
    
    <item>
      <title>76 - Minimum Window Substring</title>
      <link>//alfmunny.com/leetcode-blog/posts/76-minimum-window-substring/</link>
      <pubDate>Fri, 22 May 2020 00:41:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/76-minimum-window-substring/</guid>
      <description>leetcode
Problem Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = &amp;#34;ADOBECODEBANC&amp;#34;, T = &amp;#34;ABC&amp;#34; Output: &amp;#34;BANC&amp;#34; Note: If there is no such window in S that covers all characters in T, return the empty string &amp;#34;&amp;#34;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</description>
    </item>
    
    <item>
      <title>1277 - Count Square Submatrices with All Ones</title>
      <link>//alfmunny.com/leetcode-blog/posts/1227-count-square-submatrices-with-all-ones/</link>
      <pubDate>Fri, 22 May 2020 00:01:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1227-count-square-submatrices-with-all-ones/</guid>
      <description>leetcode
Problem Given a m * n matrix of ones and zeros, return how many square submatrices have all ones. Example 1: Input: matrix = [ [0,1,1,1], [1,1,1,1], [0,1,1,1] ] Output: 15 Explanation: There are 10 squares of side 1. There are 4 squares of side 2. There is 1 square of side 3. Total number of squares = 10 + 4 + 1 = 15. Example 2: Input: matrix = [ [1,0,1], [1,1,0], [1,1,0] ] Output: 7 Explanation: There are 6 squares of side 1.</description>
    </item>
    
    <item>
      <title>230 - Kth Smallest Element in a BST</title>
      <link>//alfmunny.com/leetcode-blog/posts/230-kth-smallest-element-in-a-bst/</link>
      <pubDate>Wed, 20 May 2020 22:37:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/230-kth-smallest-element-in-a-bst/</guid>
      <description>leetcode
Problem 230. Kth Smallest Element in a BST Medium 2239 57 Add to List Share Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note: You may assume k is always valid, 1 ≤ k ≤ BST&amp;#39;s total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 Output: 3 Solution class Solution: def kthSmallest(self, root): self.</description>
    </item>
    
    <item>
      <title>901 - Onine Stock Span</title>
      <link>//alfmunny.com/leetcode-blog/posts/901-online-stock-span/</link>
      <pubDate>Tue, 19 May 2020 21:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/901-online-stock-span/</guid>
      <description>leetcode
Problem Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock&amp;#39;s price for the current day. The span of the stock&amp;#39;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today&amp;#39;s price. For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].</description>
    </item>
    
    <item>
      <title>567 - Permutation in String</title>
      <link>//alfmunny.com/leetcode-blog/posts/567-permutation-in-string/</link>
      <pubDate>Mon, 18 May 2020 18:14:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/567-permutation-in-string/</guid>
      <description>leetcode
Problem Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string&amp;#39;s permutations is the substring of the second string. Example 1: Input: s1 = &amp;#34;ab&amp;#34; s2 = &amp;#34;eidbaooo&amp;#34; Output: True Explanation: s2 contains one permutation of s1 (&amp;#34;ba&amp;#34;). Example 2: Input:s1= &amp;#34;ab&amp;#34; s2 = &amp;#34;eidboaoo&amp;#34; Output: False Note: The input strings only contain lower case letters.</description>
    </item>
    
    <item>
      <title>438 - Find All Anagrams in a String</title>
      <link>//alfmunny.com/leetcode-blog/posts/438-find-all-anagrams-in-a-string/</link>
      <pubDate>Mon, 18 May 2020 05:08:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/438-find-all-anagrams-in-a-string/</guid>
      <description>leetcode
Problem Given a string s and a non-empty string p, find all the start indices of p&amp;#39;s anagrams in s. Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100. The order of output does not matter. Example 1: Input: s: &amp;#34;cbaebabacd&amp;#34; p: &amp;#34;abc&amp;#34; Output: [0, 6] Explanation: The substring with start index = 0 is &amp;#34;cba&amp;#34;, which is an anagram of &amp;#34;abc&amp;#34;.</description>
    </item>
    
    <item>
      <title>328 - Odd Even Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/328-odd-even-linked-list/</link>
      <pubDate>Sat, 16 May 2020 17:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/328-odd-even-linked-list/</guid>
      <description>leetcode
Problem Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example 1: Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL Example 2: Input: 2-&amp;gt;1-&amp;gt;3-&amp;gt;5-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;NULL Output: 2-&amp;gt;3-&amp;gt;6-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;4-&amp;gt;NULL Note: The relative order inside both the even and odd groups should remain as it was in the input.</description>
    </item>
    
    <item>
      <title>918 - Maximum Sum Circular Subarray</title>
      <link>//alfmunny.com/leetcode-blog/posts/918-maximum-sum-circular-subarray/</link>
      <pubDate>Fri, 15 May 2020 22:27:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/918-maximum-sum-circular-subarray/</guid>
      <description>leetcode
Problem  Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.
Here, a circular array means the end of the array connects to the beginning of the array. (Formally, C[i] = A[i] when 0 &amp;lt;= i &amp;lt; A.length, and C[i+A.length] = C[i] when i &amp;gt;= 0.)
Also, a subarray may only include each element of the fixed buffer A at most once.</description>
    </item>
    
    <item>
      <title>208 - Implement Trie (Prefix Tree)</title>
      <link>//alfmunny.com/leetcode-blog/posts/208-implement-trie/</link>
      <pubDate>Thu, 14 May 2020 21:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/208-implement-trie/</guid>
      <description>leetcode
Problem  Implement a trie with insert, search, and startsWith methods.
Example:
Trie trie = new Trie();
trie.insert(&amp;ldquo;apple&amp;rdquo;); trie.search(&amp;ldquo;apple&amp;rdquo;); / returns true trie.search(&amp;ldquo;app&amp;rdquo;); / returns false trie.startsWith(&amp;ldquo;app&amp;rdquo;); // returns true trie.insert(&amp;ldquo;app&amp;rdquo;); trie.search(&amp;ldquo;app&amp;rdquo;); // returns true
 Solution Trie.
Use a &amp;ldquo;END&amp;rdquo; Symbol for word ending.
search method checks for &amp;ldquo;END&amp;rdquo;, startsWith not.
class Trie: def __init__(self): self.root = Node() def search(self, s): node = self.root for c in s: node = node.</description>
    </item>
    
    <item>
      <title>402 - Remove K Digits</title>
      <link>//alfmunny.com/leetcode-blog/posts/402-remove-k-digits/</link>
      <pubDate>Wed, 13 May 2020 22:26:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/402-remove-k-digits/</guid>
      <description>leetcode
Problem  Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.
Example 1:
Input: num = &amp;ldquo;1432219&amp;rdquo;, k = 3 Output: &amp;ldquo;1219&amp;rdquo; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description>
    </item>
    
    <item>
      <title>540 - Single Element in a Sorted Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/540-single-element-in-a-sorted-array/</link>
      <pubDate>Tue, 12 May 2020 18:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/540-single-element-in-a-sorted-array/</guid>
      <description>leetcode
Problem  You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.
Example 1:
Input: [1,1,2,3,3,4,4,8,8] Output: 2
Example 2:
Input: [3,3,7,7,10,11,11] Output: 10
 Solution class Solution: def singleNonDuplicate(self, nums): lo = 0 hi = len(nums) - 1 while lo &amp;lt; hi: mid = (lo + hi) // 2 if mid == 0: return mid if (mid - lo + 1) % 2 == 0: if nums[mid] == nums[mid - 1]: lo = mid + 1 else: hi = mid - 1 else: if nums[mid] == nums[mid - 1]: hi = mid - 2 else: lo = mid return nums[lo] print(Solution().</description>
    </item>
    
    <item>
      <title>997 - Find the Town Judge</title>
      <link>//alfmunny.com/leetcode-blog/posts/997-find-the-town-judge/</link>
      <pubDate>Sun, 10 May 2020 21:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/997-find-the-town-judge/</guid>
      <description>leetcode
Problem In a town, there are N people labelled from 1 to N. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: 1. The town judge trusts nobody. 2. Everybody (except for the town judge) trusts the town judge. 3. There is exactly one person that satisfies properties 1 and 2. You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.</description>
    </item>
    
    <item>
      <title>733 - Flood Fill</title>
      <link>//alfmunny.com/leetcode-blog/posts/733-flood-fill/</link>
      <pubDate>Sat, 09 May 2020 15:50:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/733-flood-fill/</guid>
      <description>leetcode
Problem An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535). Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, &amp;#34;flood fill&amp;#34; the image. To perform a &amp;#34;flood fill&amp;#34;, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.</description>
    </item>
    
    <item>
      <title>1232 - Check If It Is a Straight Line</title>
      <link>//alfmunny.com/leetcode-blog/posts/1232-check-if-it-is-a-straight-line/</link>
      <pubDate>Sat, 09 May 2020 01:18:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1232-check-if-it-is-a-straight-line/</guid>
      <description>leetcode
Problem You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane. Solution Important
Notice the divider. It may be zero, when the lines are horizontal.
class Solution: def checkStraightLine(self, coordinates: List[List[int]]) -&amp;gt; bool: p1 = coordinates[0] p2 = coordinates[1] slope = self.slope(p1, p2) for i in range(2, len(coordinates)): if self.</description>
    </item>
    
    <item>
      <title>Cousins in Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/counsins-in-binary-tree/</link>
      <pubDate>Thu, 07 May 2020 21:54:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/counsins-in-binary-tree/</guid>
      <description>leetcode
Problem In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1. Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins.</description>
    </item>
    
    <item>
      <title>337 - House Robber III</title>
      <link>//alfmunny.com/leetcode-blog/posts/337-house-robber-ii/</link>
      <pubDate>Wed, 06 May 2020 17:43:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/337-house-robber-ii/</guid>
      <description>leetcode
Problem The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;#34;root.&amp;#34; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;#34;all houses in this place forms a binary tree&amp;#34;. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description>
    </item>
    
    <item>
      <title>1009 - Complement of Base 10 Integer</title>
      <link>//alfmunny.com/leetcode-blog/posts/1009-complement-of-base-10-integer/</link>
      <pubDate>Mon, 04 May 2020 17:59:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1009-complement-of-base-10-integer/</guid>
      <description>leetcode
Problem Every non-negative integer N has a binary representation. For example, 5 can be represented as &amp;#34;101&amp;#34; in binary, 11 as &amp;#34;1011&amp;#34; in binary, and so on. Note that except for N = 0, there are no leading zeroes in any binary representation. The complement of a binary representation is the number in binary you get when changing every 1 to a 0 and 0 to a 1. For example, the complement of &amp;#34;101&amp;#34; in binary is &amp;#34;010&amp;#34; in binary.</description>
    </item>
    
    <item>
      <title>887 - Super Egg Drop</title>
      <link>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</link>
      <pubDate>Sun, 03 May 2020 01:16:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/887-super-egg-drop/</guid>
      <description>leetcode
Problem You are given K eggs, and you have access to a building with N floors from 1 to N. Each egg is identical in function, and if an egg breaks, you cannot drop it again. You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.</description>
    </item>
    
    <item>
      <title>98 - Validate Binary Search Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/98-validate-binary-search-tree/</link>
      <pubDate>Sat, 02 May 2020 17:19:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/98-validate-binary-search-tree/</guid>
      <description>leetcode
Problem Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: - The left subtree of a node contains only nodes with keys less than the node&amp;#39;s key. - The right subtree of a node contains only nodes with keys greater than the node&amp;#39;s key. - Both the left and right subtrees must also be binary search trees. Example 1: 2 / \ 1 3 Input: [2,1,3] Output: true Example 2: 5 / \ 1 4 / \ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node&amp;#39;s value is 5 but its right child&amp;#39;s value is 4.</description>
    </item>
    
    <item>
      <title>128 - Longest Consecutive Sequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</link>
      <pubDate>Sat, 02 May 2020 16:34:20 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/128-longest-consecutive-sequence/</guid>
      <description>leetcode
Problem Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example: Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Solution Solution 1: Hash Map For each value, we maintain the left bound and right bound of range and also update the bounds for left value and right value.</description>
    </item>
    
    <item>
      <title>106 - Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Sat, 02 May 2020 00:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>leetcode
Problem Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution The problem is almost the same as 105 Construct BT from Preorder and Inorder. Notes can be found there.
class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&amp;gt; TreeNode: if inorder: node = TreeNode(postorder.</description>
    </item>
    
    <item>
      <title>105 - Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Sat, 02 May 2020 00:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>leetcode
Problem Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \ 9 20 / \ 15 7 Solution  The first node of the preorder is always the root. Find the root in the inorder array, split it there.</description>
    </item>
    
    <item>
      <title>278 - First Bad Version</title>
      <link>//alfmunny.com/leetcode-blog/posts/278-first-bad-version/</link>
      <pubDate>Fri, 01 May 2020 22:00:09 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/278-first-bad-version/</guid>
      <description>leetcode
Problem You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
    <item>
      <title>28 - Implement strStr() (KMP Algorithm)</title>
      <link>//alfmunny.com/leetcode-blog/posts/28-kmp/</link>
      <pubDate>Wed, 29 Apr 2020 21:42:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/28-kmp/</guid>
      <description>leetcode
Problem Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: Input: haystack = &amp;#34;hello&amp;#34;, needle = &amp;#34;ll&amp;#34; Output: 2 Example 2: Input: haystack = &amp;#34;aaaaa&amp;#34;, needle = &amp;#34;bba&amp;#34; Output: -1 Solution KMP tutorial
class Solution: def __init__(self, pat): self.pat = pat self.dp = [] self.KMP(self.pat) def KMP(self, pat): M = len(pat) self.dp = [[0] * 256 for _ in range(M)] self.</description>
    </item>
    
    <item>
      <title>124 - Binary Tree Maximum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</link>
      <pubDate>Wed, 29 Apr 2020 16:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/124-binary-tree-maximum-path-sum/</guid>
      <description>leetcode
Problem Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3]
1 / \
2 3
Output: 6 Example 2:
Input: [-10,9,20,null,null,15,7]</description>
    </item>
    
    <item>
      <title>448 - Find All Numbers Disappeard in an Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/448-find-all-numbers-disappeard-in-an-array/</link>
      <pubDate>Tue, 28 Apr 2020 17:10:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/448-find-all-numbers-disappeard-in-an-array/</guid>
      <description>leetcode
Problem Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.
Example:
Input: [4,3,2,7,8,2,3,1]
Output: [5,6]
Solution Move all the numbers to its position.</description>
    </item>
    
    <item>
      <title>169 - Majority Element</title>
      <link>//alfmunny.com/leetcode-blog/posts/169-majority-element/</link>
      <pubDate>Tue, 28 Apr 2020 16:22:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/169-majority-element/</guid>
      <description>leetcode
Problem Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
Example 1:
Input: [3,2,3] Output: 3
Example 2:
Input: [2,2,1,1,1,2,2] Output: 2
Solution Solution 1: Hash Table from collections import Counter class Solution: def majorityElement(self, nums): c = Counter() l = len(nums) for n in nums: c[n] += 1 if c[n] &amp;gt; l/2: return n print(Solution().</description>
    </item>
    
    <item>
      <title>1143 - Longest Common Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/1143-longest-common-subsequence/</link>
      <pubDate>Mon, 27 Apr 2020 14:49:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1143-longest-common-subsequence/</guid>
      <description>leetcode
Problem Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, &amp;#34;ace&amp;#34; is a subsequence of &amp;#34;abcde&amp;#34; while &amp;#34;aec&amp;#34; is not). A common subsequence of two strings is a subsequence that is common to both strings.</description>
    </item>
    
    <item>
      <title>437 - Path Sum III</title>
      <link>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</link>
      <pubDate>Sun, 26 Apr 2020 15:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/437-path-sum-iii/</guid>
      <description>leetcode
Problem You are given a binary tree in which each node contains an integer value. Find the number of paths that sum to a given value. The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes). The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</description>
    </item>
    
    <item>
      <title>460 - LFU Cache</title>
      <link>//alfmunny.com/leetcode-blog/posts/460-lfu-cache/</link>
      <pubDate>Sun, 26 Apr 2020 00:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/460-lfu-cache/</guid>
      <description>leetcode
Problem Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>146 - LRU Cache</title>
      <link>//alfmunny.com/leetcode-blog/posts/146-lru-cache/</link>
      <pubDate>Sat, 25 Apr 2020 00:17:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/146-lru-cache/</guid>
      <description>leetcode
Problem Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</description>
    </item>
    
    <item>
      <title>201 - Bitwise AND of Numbers Range</title>
      <link>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</link>
      <pubDate>Fri, 24 Apr 2020 01:35:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/201-bitwise-and-of-numbers-range/</guid>
      <description>leetcode
Problem Given a range [m, n] where 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. Example 1: Input: [5,7] Output: 4 Example 2: Input: [0,1] Output: 0 Solution m = xxx1yyyy n = xxx01zzz
xxx is the parts that two numbers are the same. We can definitly find these two numbers in the range
m&amp;rsquo; = xxx1000 n&amp;rsquo; = xxx0100</description>
    </item>
    
    <item>
      <title>560 Subarray Sum Equals K</title>
      <link>//alfmunny.com/leetcode-blog/posts/560-subarray-sum-equals-k/</link>
      <pubDate>Thu, 23 Apr 2020 01:38:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/560-subarray-sum-equals-k/</guid>
      <description>leetcode
Problem Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k. Example 1: Input:nums = [1,1,1], k = 2 Output: 2 Note: The length of the array is in range [1, 20,000]. The range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7]. Solution class Solution: def subArraySum(self, nums, k): h = {0: 1} s = 0 ans = 0 for i in nums: s += i ans += h.</description>
    </item>
    
    <item>
      <title>Leftmost Column with at Least a One</title>
      <link>//alfmunny.com/leetcode-blog/posts/leftmost-column-with-at-least-a-one/</link>
      <pubDate>Wed, 22 Apr 2020 01:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/leftmost-column-with-at-least-a-one/</guid>
      <description>leetcode
Problem A binary matrix means that all elements are 0 or 1. For each individual row of the matrix, this row is sorted in non-decreasing order. Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a 1 in it. If such index doesn&amp;#39;t exist, return -1. You can&amp;#39;t access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface: BinaryMatrix.get(x, y) returns the element of the matrix at index (x, y) (0-indexed).</description>
    </item>
    
    <item>
      <title>1008 - Construct Binary Search Tree from Preorder Traversal</title>
      <link>//alfmunny.com/leetcode-blog/posts/1008-construct-binary-search-tree-from-preorder-traversal/</link>
      <pubDate>Tue, 21 Apr 2020 07:44:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1008-construct-binary-search-tree-from-preorder-traversal/</guid>
      <description>leetcode
Problem Return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &amp;lt; node.val, and any descendant of node.right has a value &amp;gt; node.val. Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.) Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12] Solution We keep track of a low bound for the function.</description>
    </item>
    
    <item>
      <title>46 - Permutations</title>
      <link>//alfmunny.com/leetcode-blog/posts/46-permutations/</link>
      <pubDate>Sun, 19 Apr 2020 02:11:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/46-permutations/</guid>
      <description>leetcode
Problem Given a collection of distinct integers, return all possible permutations. Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] Solution class Solution: def permute(self, nums): ans = [] self.backtrack([], nums, ans) return ans def backtrack(self, path, nums, ans): if not nums: ans.append(path[:]) return for i, v in enumerate(nums): self.backtrack(path+[v], nums[:i]+nums[i+1:], ans) </description>
    </item>
    
    <item>
      <title>47 - Permutations II</title>
      <link>//alfmunny.com/leetcode-blog/posts/47-permutations-ii/</link>
      <pubDate>Sun, 19 Apr 2020 01:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/47-permutations-ii/</guid>
      <description>leetcode
Problem Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] Solution Backtrack problem.
Framework of backtrack problem:
 choose a path selection pool return condition  ans = [] def backtrack(path, pool): if meet condition: ans.add(path) return for selection in pool: path.add(selection) backtrack(path, new_pool) path.remove(selection) Important:
Pay attention, you must add a copy of the path to result, not the path it self.</description>
    </item>
    
    <item>
      <title>200 - Number of Islands</title>
      <link>//alfmunny.com/leetcode-blog/posts/200-numebr-of-islands/</link>
      <pubDate>Fri, 17 Apr 2020 17:01:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/200-numebr-of-islands/</guid>
      <description>leetcode
Problem Given a 2d grid map of &amp;#39;1&amp;#39;s (land) and &amp;#39;0&amp;#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3 Solution DFS problem. Straight forward.</description>
    </item>
    
    <item>
      <title>678 - Valid Parenthesis String</title>
      <link>//alfmunny.com/leetcode-blog/posts/678-valid-parenthesis-string/</link>
      <pubDate>Thu, 16 Apr 2020 23:07:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/678-valid-parenthesis-string/</guid>
      <description>leetcode
Problem Given a string containing only three types of characters: &amp;#39;(&amp;#39;, &amp;#39;)&amp;#39; and &amp;#39;*&amp;#39;, write a function to check whether this string is valid. We define the validity of a string by these rules: Any left parenthesis &amp;#39;(&amp;#39; must have a corresponding right parenthesis &amp;#39;)&amp;#39;. Any right parenthesis &amp;#39;)&amp;#39; must have a corresponding left parenthesis &amp;#39;(&amp;#39;. Left parenthesis &amp;#39;(&amp;#39; must go before the corresponding right parenthesis &amp;#39;)&amp;#39;. &amp;#39;*&amp;#39; could be treated as a single right parenthesis &amp;#39;)&amp;#39; or a single left parenthesis &amp;#39;(&amp;#39; or an empty string.</description>
    </item>
    
    <item>
      <title>Perform String Shifts</title>
      <link>//alfmunny.com/leetcode-blog/posts/perform-string-shifts/</link>
      <pubDate>Wed, 15 Apr 2020 00:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/perform-string-shifts/</guid>
      <description>leetcode
Problem You are given a string s containing lowercase English letters, and a matrix shift, where shift[i] = [direction, amount]: direction can be 0 (for left shift) or 1 (for right shift). amount is the amount by which string s is to be shifted. A left shift by 1 means remove the first character of s and append it to the end. Similarly, a right shift by 1 means remove the last character of s and add it to the beginning.</description>
    </item>
    
    <item>
      <title>525 - Contiguous Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/525-contiguous-array/</link>
      <pubDate>Mon, 13 Apr 2020 23:06:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/525-contiguous-array/</guid>
      <description>leetcode
Problem Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1. Example 1: Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2: Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000.</description>
    </item>
    
    <item>
      <title>1046 - Last Stone Weight</title>
      <link>//alfmunny.com/leetcode-blog/posts/1046-last-stone-weight/</link>
      <pubDate>Mon, 13 Apr 2020 01:46:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1046-last-stone-weight/</guid>
      <description>leetcode
Problem We have a collection of stones, each stone has a positive integer weight. Each turn, we choose the two heaviest stones and smash them together. Suppose the stones have weights x and y with x &amp;lt;= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x.</description>
    </item>
    
    <item>
      <title>543 - Diameter of Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/543-diameter-of-binary-tree/</link>
      <pubDate>Sat, 11 Apr 2020 23:58:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/543-diameter-of-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. Example: Given a binary tree 1 / \ 2 3 / \ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    
    <item>
      <title>155 - Min Stack</title>
      <link>//alfmunny.com/leetcode-blog/posts/155-min-stack/</link>
      <pubDate>Fri, 10 Apr 2020 20:47:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/155-min-stack/</guid>
      <description>leetcode
Problem Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. push(x) -- Push element x onto stack. pop() -- Removes the element on top of the stack. top() -- Get the top element. getMin() -- Retrieve the minimum element in the stack. Example: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.pop(); minStack.top(); --&amp;gt; Returns 0. minStack.getMin(); --&amp;gt; Returns -2.</description>
    </item>
    
    <item>
      <title>844 - Backspace String Compare</title>
      <link>//alfmunny.com/leetcode-blog/posts/844-backspace-string-compare/</link>
      <pubDate>Thu, 09 Apr 2020 22:52:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/844-backspace-string-compare/</guid>
      <description>leetcode
Problem Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character. Example 1: Input: S = &amp;#34;ab#c&amp;#34;, T = &amp;#34;ad#c&amp;#34; Output: true Explanation: Both S and T become &amp;#34;ac&amp;#34;. Example 2: Input: S = &amp;#34;ab##&amp;#34;, T = &amp;#34;c#d#&amp;#34; Output: true Explanation: Both S and T become &amp;#34;&amp;#34;. Example 3: Input: S = &amp;#34;a##c&amp;#34;, T = &amp;#34;#a#c&amp;#34; Output: true Explanation: Both S and T become &amp;#34;c&amp;#34;.</description>
    </item>
    
    <item>
      <title>876 - Middle of the Linked List</title>
      <link>//alfmunny.com/leetcode-blog/posts/876-middle-of-the-linked-list/</link>
      <pubDate>Wed, 08 Apr 2020 11:28:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/876-middle-of-the-linked-list/</guid>
      <description>leetcode
Problem Given a non-empty, singly linked list with head node head, return a middle node of linked list. If there are two middle nodes, return the second middle node. Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge&amp;#39;s serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.</description>
    </item>
    
    <item>
      <title>49 - Group Anagrams</title>
      <link>//alfmunny.com/leetcode-blog/posts/49-group-anagrams/</link>
      <pubDate>Tue, 07 Apr 2020 00:48:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/49-group-anagrams/</guid>
      <description>leetcode
Problem Given an array of strings, group anagrams together. Example: Input: [&amp;#34;eat&amp;#34;, &amp;#34;tea&amp;#34;, &amp;#34;tan&amp;#34;, &amp;#34;ate&amp;#34;, &amp;#34;nat&amp;#34;, &amp;#34;bat&amp;#34;], Output: [ [&amp;#34;ate&amp;#34;,&amp;#34;eat&amp;#34;,&amp;#34;tea&amp;#34;], [&amp;#34;nat&amp;#34;,&amp;#34;tan&amp;#34;], [&amp;#34;bat&amp;#34;] ] Note: All inputs will be in lowercase. The order of your output does not matter. Solution Use the sorted string as key in hash table
import collections class Solution: def groupAnagrams(self, strs): ans = collections.defaultdict(list) for s in strs: ans[tuple(sorted(s))].append(s) return list(ans.values()) Or use the counter</description>
    </item>
    
    <item>
      <title>215 - Kth Largest Element in an Array</title>
      <link>//alfmunny.com/leetcode-blog/posts/215-kth-largest-element-in-an-array/</link>
      <pubDate>Mon, 06 Apr 2020 01:05:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/215-kth-largest-element-in-an-array/</guid>
      <description>leetcode
Problem 215. Kth Largest Element in an Array Medium 3152 222 Add to List Share Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Example 1: Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2: Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note: You may assume k is always valid, 1 ≤ k ≤ array&amp;#39;s length.</description>
    </item>
    
    <item>
      <title>416 - Partition Equal Subset Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</link>
      <pubDate>Sun, 05 Apr 2020 21:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/416-partition-equal-subset-sum/</guid>
      <description>leetcode
Problem Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets.</description>
    </item>
    
    <item>
      <title>283 - Move Zeros</title>
      <link>//alfmunny.com/leetcode-blog/posts/283-move-zeros/</link>
      <pubDate>Sat, 04 Apr 2020 17:20:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/283-move-zeros/</guid>
      <description>leetcode
Problem Given an array nums, write a function to move all 0&amp;#39;s to the end of it while maintaining the relative order of the non-zero elements. Example: Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Solution Two pointers.
One pointer is for the start of 0.
One pointer keeps going forward.
class Solution: def moveZeros(self, nums): p1, p2 = 0, 0 for p2 &amp;lt; len(nums): if nums[p1] !</description>
    </item>
    
    <item>
      <title>494 - Target Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/494-target-sum/</link>
      <pubDate>Sat, 04 Apr 2020 16:24:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/494-target-sum/</guid>
      <description>leetcode
Problem You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol. Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: Input: nums is [1, 1, 1, 1, 1], S is 3.</description>
    </item>
    
    <item>
      <title>338 - Counting Bits</title>
      <link>//alfmunny.com/leetcode-blog/posts/338-counting-bit/</link>
      <pubDate>Thu, 02 Apr 2020 17:03:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/338-counting-bit/</guid>
      <description>leetcode
Problem Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;#39;s in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Notes DP problem
 States: index Transition:  dp[0] = 0 dp[1] = dp[1-1] + 1 = 1 dp[2] = dp[2-2] + 1 = 1 dp[3] = dp[3-2] + 1 = 2 dp[4] = dp[4-4] + 1 = 1 dp[5] = dp[5-4] + 1 = 2 dp[6] = dp[6-4] + 1 = 2 dp[7] = dp[7-4] + 1 = 3 dp[8] = dp[8-8] + 1 = 1 dp[9] = dp[9-8] + 1 = 2 dp[i] = dp[i - log_2 (i)] + 1 A trick using bit manipulation: 8 -&amp;gt; 1000 9 -&amp;gt; 1001 10 -&amp;gt; 1010 9 &amp;amp; 8 -&amp;gt; 1001 &amp;amp; 1000 -&amp;gt; 1000 dp[8] + 1 = 2 10 &amp;amp; 9 -&amp;gt; 1010 &amp;amp; 1001 -&amp;gt; 1000 dp[8] + 1 = 2 11 &amp;amp; 10 -&amp;gt; 1011 &amp;amp; 1010 -&amp;gt; 1010 dp[10] + 1 = 3 12 &amp;amp; 11 -&amp;gt; 1100 &amp;amp; 1011 -&amp;gt; 1000 dp[8] + 1 = 2 dp[i] = dp[i &amp;amp; (i-1)] + 1 Solution Solution 1: DP class Solution: def countBits(self, num): offset = 1 dp = [0] * (num + 1) for i in range(1, num + 1): if offset * 2 == i: offset *= 2 dp[i] = dp[i - offset] + 1 return dp Solution 2: Bit manipulation on couting bits class Solution: def countBits(self, num): dp = [0] * (num + 1) for i in range(1, num + 1): dp[i] = dp[i &amp;amp; (i - 1)] + 1 return dp Solution 3: class Solution(object): def countBits(self, num): res=[0] while len(res)&amp;lt;=num: res+=[i+1 for i in res] return res[:num+1] Solution 4: class Solution: def countBits(self, num): dp = [0] * (num + 1) for i in range(1, num+1): if not i % 2: dp[i] = dp[i &amp;gt;&amp;gt; 1] else: dp[i] = dp[i &amp;gt;&amp;gt; 1] + 1 return dp[num] </description>
    </item>
    
    <item>
      <title>202 - Happy Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/202-happy-number/</link>
      <pubDate>Thu, 02 Apr 2020 16:03:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/202-happy-number/</guid>
      <description>leetcode
Problem Write an algorithm to determine if a number is &amp;#34;happy&amp;#34;. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</description>
    </item>
    
    <item>
      <title>136 - Single Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/136-single-number/</link>
      <pubDate>Wed, 01 Apr 2020 22:36:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/136-single-number/</guid>
      <description>leetcode
Problem Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 Notes Solution 1: Hash Table Solution 2: Bit manipulation Consider XOR all element together. The left number is the single number.
Solution Solution 1: Hash Table class Solution: def singleNumber(self, nums): table = {} for i in nums: table[i] = table.</description>
    </item>
    
    <item>
      <title>5 - Longest Palindromic Substring</title>
      <link>//alfmunny.com/leetcode-blog/posts/5-longest-palindromic-substring/</link>
      <pubDate>Tue, 31 Mar 2020 23:57:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/5-longest-palindromic-substring/</guid>
      <description>leetcode
Problem Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: &amp;#34;babad&amp;#34; Output: &amp;#34;bab&amp;#34; Note: &amp;#34;aba&amp;#34; is also a valid answer. Example 2: Input: &amp;#34;cbbd&amp;#34; Output: &amp;#34;bb&amp;#34; Notes DP problem
  States:
left_index, right_index, mark if s[left_index, right_index+1] is palindromic
  Transition:
if s[l] == s[r]: # mark it only when both ends are same values dp[l][r] = 1 if r == l # if only one element dp[l][r] = 1 if r+1 == l # if only two elements dp[l][r] = 1 if dp[l+1][r+1] = 1 # if the string in between is palindromic results = s[l:r+1] if r-l+1&amp;gt;len(results) # comparing the length, record the maximum   Base case:</description>
    </item>
    
    <item>
      <title>647 - Palindromic Substrings</title>
      <link>//alfmunny.com/leetcode-blog/posts/647-palindromic-substrings/</link>
      <pubDate>Tue, 31 Mar 2020 23:41:02 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/647-palindromic-substrings/</guid>
      <description>leetcode
Problem Given a string, your task is to count how many palindromic substrings in this string. The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters. Example 1: Input: &amp;#34;abc&amp;#34; Output: 3 Explanation: Three palindromic strings: &amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;. Example 2: Input: &amp;#34;aaa&amp;#34; Output: 6 Explanation: Six palindromic strings: &amp;#34;a&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;aa&amp;#34;, &amp;#34;aa&amp;#34;, &amp;#34;aaa&amp;#34;. Note: The input string length won&amp;#39;t exceed 1000.</description>
    </item>
    
    <item>
      <title>279 - Perfect Squares</title>
      <link>//alfmunny.com/leetcode-blog/posts/279-perfect-squares/</link>
      <pubDate>Tue, 31 Mar 2020 00:13:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/279-perfect-squares/</guid>
      <description>leetcode
Problem Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n. Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Notes DP problem
  States: n
  Transition:
  dp[i] = min([_dp[i-j*j]+1 if i-j*j &amp;gt;= 0 else break for j in range(1, sqrt(i)+1)])   Base case:</description>
    </item>
    
    <item>
      <title>221 - Maximal Square</title>
      <link>//alfmunny.com/leetcode-blog/posts/221-maximal-square/</link>
      <pubDate>Mon, 30 Mar 2020 20:21:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/221-maximal-square/</guid>
      <description>leetcode
Problem Given a 2D binary matrix filled with 0&amp;#39;s and 1&amp;#39;s, find the largest square containing only 1&amp;#39;s and return its area. Example: Input: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Output: 4 Notes DP Problem:
  States:
 position -&amp;gt; [i][j] how many continues 1 in vertical direction -&amp;gt; [i][j][0] how many continues 1 in horizontal direction -&amp;gt; [i][j][1] square value(or the length of the square) -&amp;gt; [i][j][2]  dp[i][j][0 or 1 or 2]</description>
    </item>
    
    <item>
      <title>96 - Unique Binary Search Trees</title>
      <link>//alfmunny.com/leetcode-blog/posts/96-unique-binary-search-trees/</link>
      <pubDate>Mon, 30 Mar 2020 15:17:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/96-unique-binary-search-trees/</guid>
      <description>leetcode
Problem Given n, how many structurally unique BST&amp;#39;s (binary search trees) that store values 1 ... n? Example: Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST&amp;#39;s: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 Notes Solution 1: DP In this dp problem, the hard part is to figure out the transition.</description>
    </item>
    
    <item>
      <title>152 - Maximum Product Subarray</title>
      <link>//alfmunny.com/leetcode-blog/posts/152-maximum-product-subarray/</link>
      <pubDate>Sun, 29 Mar 2020 17:40:00 +0200</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/152-maximum-product-subarray/</guid>
      <description>leetcode
Problem Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Notes DP problem:
  States: We have to know two previous states to deduct the current max product:</description>
    </item>
    
    <item>
      <title>322 - Coin Change</title>
      <link>//alfmunny.com/leetcode-blog/posts/322-coin-change/</link>
      <pubDate>Sat, 28 Mar 2020 02:17:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/322-coin-change/</guid>
      <description>leetcode
Problem You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. Example 1: Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Note: You may assume that you have an infinite number of each kind of coin.</description>
    </item>
    
    <item>
      <title>300 - Longest Increasing Subsequence</title>
      <link>//alfmunny.com/leetcode-blog/posts/300-longest-increasing-subsequence/</link>
      <pubDate>Sat, 28 Mar 2020 00:08:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/300-longest-increasing-subsequence/</guid>
      <description>leetcode
Problem Given an unsorted array of integers, find the length of longest increasing subsequence. Example: Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note: There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n2) complexity. Follow up: Could you improve it to O(n log n) time complexity? Solution DP problem.</description>
    </item>
    
    <item>
      <title>198 - House Robber</title>
      <link>//alfmunny.com/leetcode-blog/posts/198-house-robber/</link>
      <pubDate>Fri, 27 Mar 2020 23:58:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/198-house-robber/</guid>
      <description>leetcode
Problem You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description>
    </item>
    
    <item>
      <title>91 - Decode Ways</title>
      <link>//alfmunny.com/leetcode-blog/posts/91-decode-ways/</link>
      <pubDate>Wed, 25 Mar 2020 23:44:20 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/91-decode-ways/</guid>
      <description>leetcode
Problem A message containing letters from A-Z is being encoded to numbers using the following mapping: &amp;#39;A&amp;#39; -&amp;gt; 1 &amp;#39;B&amp;#39; -&amp;gt; 2 ... &amp;#39;Z&amp;#39; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: &amp;#34;12&amp;#34; Output: 2 Explanation: It could be decoded as &amp;#34;AB&amp;#34; (1 2) or &amp;#34;L&amp;#34; (12). Example 2: Input: &amp;#34;226&amp;#34; Output: 3 Explanation: It could be decoded as &amp;#34;BZ&amp;#34; (2 26), &amp;#34;VF&amp;#34; (22 6), or &amp;#34;BBF&amp;#34; (2 2 6).</description>
    </item>
    
    <item>
      <title>101 - Symmetric Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/101-symmetric-tree/</link>
      <pubDate>Wed, 25 Mar 2020 21:02:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/101-symmetric-tree/</guid>
      <description>leetcode
Problem Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not: 1 / \ 2 2 \ \ 3 3 Notes Recursion !
Solution Solution 1: recursive class Solution: def isSymmetric(self, root): if not root: return True return self.</description>
    </item>
    
    <item>
      <title>21 - Merge Two Sorted Lists</title>
      <link>//alfmunny.com/leetcode-blog/posts/21-merge-two-sorted-lists/</link>
      <pubDate>Wed, 25 Mar 2020 19:55:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/21-merge-two-sorted-lists/</guid>
      <description>leetcode
Problem Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 Notes Recursion is your friend!
Solution Solution 1: Recursive class Solution: def mergeTwoLists(self, l1, l2): if not l1: return l2 if not l2: return l1 if l1.val &amp;gt; l2.val: l2.next = self.mergeTwoLists(l1, l2.next) return l2 else: l1.</description>
    </item>
    
    <item>
      <title>104 - Maximum Depth of Binary Tree</title>
      <link>//alfmunny.com/leetcode-blog/posts/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Wed, 25 Mar 2020 17:16:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/104-maximum-depth-of-binary-tree/</guid>
      <description>leetcode
Problem Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 Notes Recursion is your friend!
Solution class Solution: def maxDepth(self, root): return 1 + max(self.maxDepth(root.right), self.</description>
    </item>
    
    <item>
      <title>309 - Best Time to Buy and Sell Stock with Cooldown</title>
      <link>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</link>
      <pubDate>Tue, 24 Mar 2020 22:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/309-best-time-to-buy-and-sell-stock-with-cooldown/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>188 - Best Time to Buy and Sell Stock IV</title>
      <link>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</link>
      <pubDate>Tue, 24 Mar 2020 21:46:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/188-best-time-to-buy-and-sell-stock-iv/</guid>
      <description>leetcode
Problem Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: Input: [2,4,1], k = 2 Output: 2 Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</description>
    </item>
    
    <item>
      <title>123 - Best Time to Buy and Sell Stock III</title>
      <link>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Tue, 24 Mar 2020 18:25:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/123-best-time-to-buy-and-sell-stock-iii/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</description>
    </item>
    
    <item>
      <title>122 - Best Time to Buy and Sell Stock II</title>
      <link>//alfmunny.com/leetcode-blog/posts/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Tue, 24 Mar 2020 15:26:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again). Example 1: Input: [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</description>
    </item>
    
    <item>
      <title>121 - Best Time to Buy and Sell Stock</title>
      <link>//alfmunny.com/leetcode-blog/posts/121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Tue, 24 Mar 2020 12:13:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/121-best-time-to-buy-and-sell-stock/</guid>
      <description>leetcode
Problem Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>85 - Maximal Rectangle</title>
      <link>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</link>
      <pubDate>Tue, 24 Mar 2020 00:57:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/85-maximal-rectangle/</guid>
      <description>Problem Notes Solution  leetcode
Problem Given a 2D binary matrix filled with 0&amp;#39;s and 1&amp;#39;s, find the largest rectangle containing only 1&amp;#39;s and return its area. Example: Input: [ [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;1&amp;#34;], [&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;0&amp;#34;,&amp;#34;1&amp;#34;,&amp;#34;0&amp;#34;] ] Output: 6 Notes Two parts:
 generate a heights histogram for every row. apple &amp;ldquo;largest rectangle in histogram&amp;rdquo; on each row of histogram  Solution class Solution: def maximalRectangle(self, matrix): if not matrix or not matrix[0]: return 0 m = len(matrix) n = len(matrix[0]) histograms = [[0] * n for i in range(m)] res = 0 for i in range(m): for j in range(n): if matrix[i][j] == &amp;#34;1&amp;#34;: histograms[i][j] = histograms[i - 1][j] + 1 if i &amp;gt; 0 else 1 for histogram in histograms: res = max(res, self.</description>
    </item>
    
    <item>
      <title>84 - Largest Rectangle in Histogram</title>
      <link>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</link>
      <pubDate>Mon, 23 Mar 2020 00:36:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/84-largest-rectangle-in-histogram/</guid>
      <description>leetcode
Problem Given n non-negative integers representing the histogram&amp;#39;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Example: Input: [2,1,5,6,2,3] Output: 10 Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
The largest rectangle is shown in the shaded area, which has area = 10 unit.
Notes Main idea is to caculate both left edge and right edge for every entry in the array</description>
    </item>
    
    <item>
      <title>1306 - Jump Game III</title>
      <link>//alfmunny.com/leetcode-blog/posts/1306-jump-game-iii/</link>
      <pubDate>Sun, 22 Mar 2020 20:42:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/1306-jump-game-iii/</guid>
      <description>leetcode
Problem Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0. Notice that you can not jump outside of the array at any time. Example 1: Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 index 5 -&amp;gt; index 6 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 2: Input: arr = [4,2,3,0,3,1,2], start = 0 Output: true Explanation: One possible way to reach at index 3 with value 0 is: index 0 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 3: Input: arr = [3,0,2,1,2], start = 2 Output: false Explanation: There is no way to reach at index 1 with value 0.</description>
    </item>
    
    <item>
      <title>45 - Jump Game II</title>
      <link>//alfmunny.com/leetcode-blog/posts/45-jump-game-ii/</link>
      <pubDate>Sun, 22 Mar 2020 00:55:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/45-jump-game-ii/</guid>
      <description>leetcode
Problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps. Example: Input: [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.</description>
    </item>
    
    <item>
      <title>62 - Unique Paths</title>
      <link>//alfmunny.com/leetcode-blog/posts/62-unique-paths/</link>
      <pubDate>Sat, 21 Mar 2020 22:34:22 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/62-unique-paths/</guid>
      <description>leetcode
Problem A robot is located at the top-left corner of a m x n grid (marked &amp;#39;Start&amp;#39; in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;#39;Finish&amp;#39; in the diagram below). How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1.</description>
    </item>
    
    <item>
      <title>509 - Fibonacci Number</title>
      <link>//alfmunny.com/leetcode-blog/posts/509-fibonacci-number/</link>
      <pubDate>Sat, 21 Mar 2020 22:31:20 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/509-fibonacci-number/</guid>
      <description>leetcode
Problem The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N &amp;gt; 1. Given N, calculate F(N). Example 1: Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description>
    </item>
    
    <item>
      <title>91 - Decode Ways</title>
      <link>//alfmunny.com/leetcode-blog/posts/90-decode-ways/</link>
      <pubDate>Sat, 21 Mar 2020 22:28:56 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/90-decode-ways/</guid>
      <description>leetcode
Problem A message containing letters from A-Z is being encoded to numbers using the following mapping: &amp;#39;A&amp;#39; -&amp;gt; 1 &amp;#39;B&amp;#39; -&amp;gt; 2 ... &amp;#39;Z&amp;#39; -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: &amp;#34;12&amp;#34; Output: 2 Explanation: It could be decoded as &amp;#34;AB&amp;#34; (1 2) or &amp;#34;L&amp;#34; (12). Example 2: Input: &amp;#34;226&amp;#34; Output: 3 Explanation: It could be decoded as &amp;#34;BZ&amp;#34; (2 26), &amp;#34;VF&amp;#34; (22 6), or &amp;#34;BBF&amp;#34; (2 2 6).</description>
    </item>
    
    <item>
      <title>70 - Climbing Stairs</title>
      <link>//alfmunny.com/leetcode-blog/posts/70-climbing-stairs/</link>
      <pubDate>Sat, 21 Mar 2020 22:25:51 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/70-climbing-stairs/</guid>
      <description>leetcode
Problem You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top.</description>
    </item>
    
    <item>
      <title>55 - Jump Game</title>
      <link>//alfmunny.com/leetcode-blog/posts/55-jump-game/</link>
      <pubDate>Sat, 21 Mar 2020 22:19:29 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/55-jump-game/</guid>
      <description>leetcode
Problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description>
    </item>
    
    <item>
      <title>53 - Maximum Subarray</title>
      <link>//alfmunny.com/leetcode-blog/posts/53-maximum-subarray/</link>
      <pubDate>Sat, 21 Mar 2020 22:16:34 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/53-maximum-subarray/</guid>
      <description>leetcode
Problem Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Notes Dynamic programming problem.
Use nums[i] always store the maximum sum.</description>
    </item>
    
    <item>
      <title>48 - Rotate Image</title>
      <link>//alfmunny.com/leetcode-blog/posts/48-rotate-image/</link>
      <pubDate>Sat, 21 Mar 2020 22:16:23 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/48-rotate-image/</guid>
      <description>leetcode
Problem You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2: Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] Notes Naive solution, to do it one by one.</description>
    </item>
    
    <item>
      <title>41 - First Missing Positive</title>
      <link>//alfmunny.com/leetcode-blog/posts/41-first-missing-positive/</link>
      <pubDate>Sat, 21 Mar 2020 16:29:53 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/41-first-missing-positive/</guid>
      <description>Problem Given an unsorted integer array, find the smallest missing positive integer. Example 1: Input: [1,2,0] Output: 3 Example 2: Input: [3,4,-1,1] Output: 2 Example 3: Input: [7,8,9,11,12] Output: 1 Note: Your algorithm should run in O(n) time and uses constant extra space. Notes Run in O(n) time and uses constant extra space
  Say the length of the array is l, the number must be in 1&amp;hellip;l+1 (also l possible numbers)</description>
    </item>
    
    <item>
      <title>79 - Word Search</title>
      <link>//alfmunny.com/leetcode-blog/posts/79-word-search/</link>
      <pubDate>Sat, 14 Mar 2020 03:00:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/79-word-search/</guid>
      <description>leetcode
Problem Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where &amp;#34;adjacent&amp;#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ [&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;E&amp;#39;], [&amp;#39;S&amp;#39;,&amp;#39;F&amp;#39;,&amp;#39;C&amp;#39;,&amp;#39;S&amp;#39;], [&amp;#39;A&amp;#39;,&amp;#39;D&amp;#39;,&amp;#39;E&amp;#39;,&amp;#39;E&amp;#39;] ] Given word = &amp;#34;ABCCED&amp;#34;, return true. Given word = &amp;#34;SEE&amp;#34;, return true. Given word = &amp;#34;ABCB&amp;#34;, return false.</description>
    </item>
    
    <item>
      <title>78 - Subsets</title>
      <link>//alfmunny.com/leetcode-blog/posts/78-subsets/</link>
      <pubDate>Sat, 07 Mar 2020 23:59:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/78-subsets/</guid>
      <description>Problem leetcode
Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Notes Three strategies to solve a subset problem:
Recursion, Backtracking, Bitmask
Recursion Iterative version:
Start from empty array [[]]. Step 1: Take 1 into consideration, and add 1 to existing array [[], [1]] Step 2: Take 2 into consideration, and add 2 to existing array [[], [1], [2], [1, 2]] Step 3: Take 3 into consideration, and add 3 to existing array [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] DFS version:</description>
    </item>
    
    <item>
      <title>75 - Sort Colors</title>
      <link>//alfmunny.com/leetcode-blog/posts/75-sort-colors/</link>
      <pubDate>Fri, 06 Mar 2020 17:26:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/75-sort-colors/</guid>
      <description>leetcode
Problem Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library&amp;#39;s sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.</description>
    </item>
    
    <item>
      <title>64 - Minimum Path Sum</title>
      <link>//alfmunny.com/leetcode-blog/posts/64-mnimum-path-sum/</link>
      <pubDate>Wed, 04 Mar 2020 18:47:00 +0100</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/posts/64-mnimum-path-sum/</guid>
      <description>leetcode
Problem Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example: Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. Notes Thinking: It seems to be a greedy algorithm problem.</description>
    </item>
    
    <item>
      <title></title>
      <link>//alfmunny.com/leetcode-blog/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//alfmunny.com/leetcode-blog/about/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>